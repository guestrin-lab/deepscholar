parent_paper_title,parent_arxiv_link,citation_shorthand,raw_citation_text,cited_paper_title,cited_paper_arxiv_link,cited_paper_abstract,bib_paper_authors,bib_paper_year,bib_paper_month,bib_paper_url,bib_paper_doi,bib_paper_journal
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,xfdetector,\cite{xfdetector},Cross-Failure Bug Detection in Persistent Memory Programs,,,"Liu, Sihang and Seemakhupt, Korakit and Wei, Yizhou and Wenisch, Thomas and Kolli, Aasheesh and Khan, Samira",2020,,https://doi.org/10.1145/3373376.3378452,10.1145/3373376.3378452,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,pmtest,\cite{pmtest},{PMTest}: A Fast and Flexible Testing Framework for Persistent Memory Programs,,,"Liu, Sihang and Wei, Yizhou and Zhao, Jishen and Kolli, Aasheesh and Khan, Samira",2019,,https://doi.org/10.1145/3297858.3304015,10.1145/3297858.3304015,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,pmemcheck,\cite{pmemcheck},An introduction to pmemcheck (part 1) - basics,,,Tomasz Kapela,2015,July,,,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,yat,\cite{yat},Yat: A Validation Framework for Persistent Memory Software,,,Philip Lantz and Subramanya Dulloor and Sanjay Kumar and Rajesh Sankaran and Jeff Jackson,2014,June,https://www.usenix.org/conference/atc14/technical-sessions/presentation/lantz,,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,agamotto,\cite{agamotto},{AGAMOTTO}: How Persistent is your Persistent Memory Application?,,,Ian Neal and Ben Reeves and Ben Stoler and Andrew Quinn,2020,November,,,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,pminvariant,\cite{pminvariant},Discovering Likely Program Invariants for Persistent Memory,,,"Huang, Zunchen and Ravi, Srivatsan and Wang, Chao",2024,,https://doi.org/10.1145/3691620.3695544,10.1145/3691620.3695544,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,pog,\cite{pog},Persistent {Owicki-Gries} reasoning: A program logic for reasoning about persistent programs on {Intel}-x86,,,"Raad, Azalea and Lahav, Ori and Vafeiadis, Viktor",2020,nov,https://doi.org/10.1145/3428219,10.1145/3428219,Proc. ACM Program. Lang.
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,pierogi,\cite{pierogi},"View-Based Owicki-Gries Reasoning for Persistent x86-TSO (Extended
  Version)",http://arxiv.org/abs/2201.05860v1,"The rise of persistent memory is disrupting computing to its core. Our work
aims to help programmers navigate this brave new world by providing a program
logic for reasoning about x86 code that uses low-level operations such as
memory accesses and fences, as well as persistency primitives such as flushes.
Our logic, Pierogi, benefits from a simple underlying operational semantics
based on views, is able to handle optimised flush operations, and is mechanised
in the Isabelle/HOL proof assistant. We detail the proof rules of Pierogi and
prove them sound. We also show how Pierogi can be used to reason about a range
of challenging single- and multi-threaded persistent programs.","Bila, Eleni Vafeiadi and Dongol, Brijesh and Lahav, Ori and Raad, Azalea and Wickerson, John",2022,,https://doi.org/10.1007/978-3-030-99336-8_9,10.1007/978-3-030-99336-8_9,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,nv-htm,\cite{nv-htm},{Hardware transactional memory meets memory persistency},,,Daniel Castro and Paolo Romano and Jo{\~a}o Barreto,2018,,,,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,crafty-pldi20,\cite{crafty-pldi20},"Crafty: Efficient, HTM-Compatible Persistent Transactions",http://arxiv.org/abs/2004.00262v3,"Byte-addressable persistent memory, such as Intel/Micron 3D XPoint, is an
emerging technology that bridges the gap between volatile memory and persistent
storage. Data in persistent memory survives crashes and restarts; however, it
is challenging to ensure that this data is consistent after failures. Existing
approaches incur significant performance costs to ensure crash consistency.
This paper introduces Crafty, a new approach for ensuring consistency and
atomicity on persistent memory operations using commodity hardware with
existing hardware transactional memory (HTM) capabilities, while incurring low
overhead. Crafty employs a novel technique called nondestructive undo logging
that leverages commodity HTM to control persist ordering. Our evaluation shows
that Crafty outperforms state-of-the-art prior work under low contention, and
performs competitively under high contention.","Gen\c{c}, Kaan and Bond, Michael D. and Xu, Guoqing Harry",2020,,https://doi.org/10.1145/3385412.3385991,10.1145/3385412.3385991,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,persistent-htm-giles-2017,\cite{persistent-htm-giles-2017},Continuous Checkpointing of {HTM} Transactions in {NVM},,,"Giles, Ellis and Doshi, Kshitij and Varman, Peter",2017,,https://doi.org/10.1145/3092255.3092270,10.1145/3092255.3092270,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,dudetm,\cite{dudetm},{DudeTM}: Building Durable Transactions with Decoupling for Persistent Memory,,,"Liu, Mengxing and Zhang, Mingxing and Chen, Kang and Qian, Xuehai and Wu, Yongwei and Zheng, Weimin and Ren, Jinglei",2017,,https://doi.org/10.1145/3037697.3037714,10.1145/3037697.3037714,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,nvlc,\cite{nvlc},"{NVL-C}: Static Analysis Techniques for Efficient, Correct Programming of Non-Volatile Main Memory Systems",,,"Denny, Joel E. and Lee, Seyong and Vetter, Jeffrey S.",2016,,https://doi.org/10.1145/2907294.2907303,10.1145/2907294.2907303,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,atlas-follow-up,\cite{atlas-follow-up},Persistence Programming Models for Non-Volatile Memory,,,"Boehm, Hans-J. and Chakrabarti, Dhruva R.",2016,,https://doi.org/10.1145/2926697.2926704,10.1145/2926697.2926704,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,atlas,\cite{atlas},Atlas: Leveraging Locks for Non-Volatile Memory Consistency,,,"Chakrabarti, Dhruva R. and Boehm, Hans-J. and Bhandari, Kumud",2014,,https://doi.org/10.1145/2660193.2660224,10.1145/2660193.2660224,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,nvthreads,\cite{nvthreads},{NVthreads}: Practical Persistence for Multi-Threaded Applications,,,"Hsu, Terry Ching-Hsiang and Br\""{u}gner, Helge and Roy, Indrajit and Keeton, Kimberly and Eugster, Patrick",2017,,https://doi.org/10.1145/3064176.3064204,10.1145/3064176.3064204,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,justdo-logging,\cite{justdo-logging},Failure-Atomic Persistent Memory Updates via {JUSTDO} Logging,,,"Izraelevitz, Joseph and Kelly, Terence and Kolli, Aasheesh",2016,,https://doi.org/10.1145/2872362.2872410,10.1145/2872362.2872410,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,ido,\cite{ido},{iDO}: Compiler-Directed Failure Atomicity for Nonvolatile Memory,,,"Liu, Qingrui and Izraelevitz, Joseph and Lee, Se Kwon and Scott, Michael L. and Noh, Sam H. and Jung, Changhee",2018,,https://doi.org/10.1109/MICRO.2018.00029,10.1109/MICRO.2018.00029,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,persistency-sfr,\cite{persistency-sfr},Persistency for Synchronization-Free Regions,,,"Gogte, Vaibhav and Diestelhorst, Stephan and Wang, William and Narayanasamy, Satish and Chen, Peter M. and Wenisch, Thomas F.",2018,,https://doi.org/10.1145/3192366.3192367,10.1145/3192366.3192367,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,memento,\cite{memento},Memento: A Framework for Detectable Recoverability in Persistent Memory,,,"Cho, Kyeongmin and Jeon, Seungmin and Raad, Azalea and Kang, Jeehoon",2023,jun,https://doi.org/10.1145/3591232,10.1145/3591232,Proc. ACM Program. Lang.
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,staticpersist,\cite{staticpersist},StaticPersist: Compiler Support for PMEM Programming,,,"Bansal, Sorav",2023,,,,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,autopersist,\cite{autopersist},AutoPersist: an easy-to-use Java NVM framework based on reachability,,,"Shull, Thomas and Huang, Jian and Torrellas, Josep",2019,,https://doi.org/10.1145/3314221.3314608,10.1145/3314221.3314608,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,hippocrates-asplos21,\cite{hippocrates-asplos21},Hippocrates: Healing Persistent Memory Bugs without Doing Any Harm,,,"Neal, Ian and Quinn, Andrew and Kasikci, Baris",2021,,https://doi.org/10.1145/3445814.3446694,10.1145/3445814.3446694,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,pmbugassist,\cite{pmbugassist},Constraint Based Program Repair for Persistent Memory Bugs,,,"Huang, Zunchen and Wang, Chao",2024,,https://doi.org/10.1145/3597503.3639204,10.1145/3597503.3639204,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,musketeer2017,\cite{musketeer2017},Don’t Sit on the Fence: A Static Analysis Approach to Automatic Fence Insertion,,,"Alglave, Jade and Kroening, Daniel and Nimal, Vincent and Poetzl, Daniel",2017,,https://doi.org/10.1145/2994593,10.1145/2994593,ACM Trans. Program. Lang. Syst.
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,lee2000relaxed,\cite{lee2000relaxed},Hiding relaxed memory consistency with compilers,,,"Jaejin Lee and Padua, D.A.",2000,,,10.1109/PACT.2000.888336,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,fang2003automatic,\cite{fang2003automatic},Automatic fence insertion for shared memory multiprocessing,,,"Fang, Xing and Lee, Jaejin and Midkiff, Samuel P",2003,,,,
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,delayset,\cite{delayset},Efficient and correct execution of parallel programs that share memory,,,"Shasha, Dennis and Snir, Marc",1988,,https://doi.org/10.1145/42190.42277,10.1145/42190.42277,ACM Trans. Program. Lang. Syst.
Automated Insertion of Flushes and Fences for Persistency,http://arxiv.org/abs/2509.19459v1,flit,\cite{flit},FliT: A Library for Simple and Efficient Persistent Algorithms,http://arxiv.org/abs/2108.04202v2,"Non-volatile random access memory (NVRAM) offers byte-addressable persistence
at speeds comparable to DRAM. However, with caches remaining volatile,
automatic cache evictions can reorder updates to memory, potentially leaving
persistent memory in an inconsistent state upon a system crash. Flush and fence
instructions can be used to force ordering among updates, but are expensive.
This has motivated significant work studying how to write correct and efficient
persistent programs for NVRAM.
  In this paper, we present FliT, a C++ library that facilitates writing
efficient persistent code. Using the library's default mode makes any
linearizable data structure durable with minimal changes to the code. FliT
avoids many redundant flush instructions by using a novel algorithm to track
dirty cache lines. The FliT library also allows for extra optimizations, but
achieves good performance even in its default setting.
  To describe the FliT library's capabilities and guarantees, we define a
persistent programming interface, called the P-V Interface, which FliT
implements. The P-V Interface captures the expected behavior of code in which
some instructions' effects are persisted and some are not. We show that the
interface captures the desired semantics of many practical algorithms in the
literature.
  We apply the FliT library to four different persistent data structures, and
show that across several workloads, persistence implementations, and data
structure sizes, the FliT library always improves operation throughput, by at
least $2.1\times$ over a naive implementation in all but one workload.","Wei, Yuanhao and Ben-David, Naama and Friedman, Michal and Blelloch, Guy E. and Petrank, Erez",2022,,https://doi.org/10.1145/3503221.3508436,10.1145/3503221.3508436,
