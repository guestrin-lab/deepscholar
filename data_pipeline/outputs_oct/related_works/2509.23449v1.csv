arxiv_id,arxiv_link,publication_date,title,abstract,raw_latex_related_works,clean_latex_related_works,pdf_related_works
2509.23449v1,http://arxiv.org/abs/2509.23449v1,2025-09-27 18:34:32+00:00,Beyond Embeddings: Interpretable Feature Extraction for Binary Code Similarity,"Binary code similarity detection is a core task in reverse engineering. It
supports malware analysis and vulnerability discovery by identifying
semantically similar code in different contexts. Modern methods have progressed
from manually engineered features to vector representations. Hand-crafted
statistics (e.g., operation ratios) are interpretable, but shallow and fail to
generalize. Embedding-based methods overcome this by learning robust
cross-setting representations, but these representations are opaque vectors
that prevent rapid verification. They also face a scalability-accuracy
trade-off, since high-dimensional nearest-neighbor search requires
approximations that reduce precision. Current approaches thus force a
compromise between interpretability, generalizability, and scalability.
  We bridge these gaps using a language model-based agent to conduct structured
reasoning analysis of assembly code and generate features such as input/output
types, side effects, notable constants, and algorithmic intent. Unlike
hand-crafted features, they are richer and adaptive. Unlike embeddings, they
are human-readable, maintainable, and directly searchable with inverted or
relational indexes. Without any matching training, our method respectively
achieves 42% and 62% for recall@1 in cross-architecture and cross-optimization
tasks, comparable to embedding methods with training (39% and 34%). Combined
with embeddings, it significantly outperforms the state-of-the-art,
demonstrating that accuracy, scalability, and interpretability can coexist.","\label{sec:related}

% \subsection{Other code matching approaches}

\noindent \textbf{Dynamic analysis.} This method family consists of analyzing the features of a binary or code fragment by monitoring its runtime behavior.
This method is compute intensive and requires a cross-platform emulator, but completely sidesteps the syntactic aspects of binary code
and solely analyzes its semantics. ~\cite{BCSD} As such, this method is highly resilient to obfuscations, but requires a sandboxed environment
and is hard to generalize across architectures and application binary interfaces ~\cite{blanket-exec, kam1n0}.

 \textbf{Code Representations.} Our research focuses on methods of binary similarity that use the assembly
code (and possibly the control flow graph) retrieved from the binary to perform similarity detection. However, other
approaches exist that use an alternate representation language, so that binaries compiled for all architectures are
extracted into the same representation language. Some methods turn to the well known LLVM-IR ~\cite{llvmir1, llvmir2, llvmir3}
as representation language, and others prefer the VEX intermediate representation ~\cite{VexIR2Vec, Zeek}.

\textbf{Full Program Similarity.} An alternate approach to binary matching is to compare whole binaries, instead
of their individual functions. This type of method constructs a fingerprint for the whole binary as compared to having one embedding
per function. This approach is primarily used for malware identification \cite{malware-id, malware-id2, malware-id3, malware-id4},
but also for identifying known vulnerabilities \cite{precise-static-vuln, firmware-vuln}.

\textbf{LLM-based software analysis}. Researchers have found many related applications of language models to binary and software analysis.
We give a sparse overview of the progress that has been made in this area of research.
For vulnerability detection, FuncVul ~\cite{funcVul} is a language-model-based method to detect whether a provided
source function is vulnerable. LLM4Decompile ~\cite{llm4decompile} tries to utilize LLMs for decompilation. An open source LLM is fine-tuned to learn the source code
representation of an assembly function, and the model is then evaluated on its decompilation capabilities. Fang et al. ~\cite{source-analysis}
measure the competency of LLMs for source code analysis, with a focus on obfuscated source code.
Their results match our findings, that LLMs are efficient at code analysis, but they
also demonstrate that language models still struggle when faced with cases of advanced obfuscation techniques.
LLM-based fuzzing is another area that has recently gained interest. For instance, Asmita et al. ~\cite{llm-fuzz} use a LLM to
generate the initial seed of a fuzzing pipeline on the BusyBox ~\cite{busybox} executable.","\noindent \textbf{Dynamic analysis.} This method family consists of analyzing the features of a binary or code fragment by monitoring its runtime behavior.
This method is compute intensive and requires a cross-platform emulator, but completely sidesteps the syntactic aspects of binary code
and solely analyzes its semantics. ~\cite{BCSD} As such, this method is highly resilient to obfuscations, but requires a sandboxed environment
and is hard to generalize across architectures and application binary interfaces ~\cite{blanket-exec, kam1n0}.

 \textbf{Code Representations.} Our research focuses on methods of binary similarity that use the assembly
code (and possibly the control flow graph) retrieved from the binary to perform similarity detection. However, other
approaches exist that use an alternate representation language, so that binaries compiled for all architectures are
extracted into the same representation language. Some methods turn to the well known LLVM-IR ~\cite{llvmir1, llvmir2, llvmir3}
as representation language, and others prefer the VEX intermediate representation ~\cite{VexIR2Vec, Zeek}.

\textbf{Full Program Similarity.} An alternate approach to binary matching is to compare whole binaries, instead
of their individual functions. This type of method constructs a fingerprint for the whole binary as compared to having one embedding
per function. This approach is primarily used for malware identification \cite{malware-id, malware-id2, malware-id3, malware-id4},
but also for identifying known vulnerabilities \cite{precise-static-vuln, firmware-vuln}.

\textbf{LLM-based software analysis}. Researchers have found many related applications of language models to binary and software analysis.
We give a sparse overview of the progress that has been made in this area of research.
For vulnerability detection, FuncVul ~\cite{funcVul} is a language-model-based method to detect whether a provided
source function is vulnerable. LLM4Decompile ~\cite{llm4decompile} tries to utilize LLMs for decompilation. An open source LLM is fine-tuned to learn the source code
representation of an assembly function, and the model is then evaluated on its decompilation capabilities. Fang et al. ~\cite{source-analysis}
measure the competency of LLMs for source code analysis, with a focus on obfuscated source code.
Their results match our findings, that LLMs are efficient at code analysis, but they
also demonstrate that language models still struggle when faced with cases of advanced obfuscation techniques.
LLM-based fuzzing is another area that has recently gained interest. For instance, Asmita et al. ~\cite{llm-fuzz} use a LLM to
generate the initial seed of a fuzzing pipeline on the BusyBox ~\cite{busybox} executable.","Dynamic analysis.This method family consists of analyz-
ing the features of a binary or code fragment by monitoring
its runtime behavior. This method is compute intensive and
requires a cross-platform emulator, but completely sidesteps
the syntactic aspects of binary code and solely analyzes its
semantics. [34] As such, this method is highly resilient to
12
obfuscations, but requires a sandboxed environment and is
hard to generalize across architectures and application binary
interfaces [15, 17].
Code Representations.Our research focuses on methods
of binary similarity that use the assembly code (and possibly
the control flow graph) retrieved from the binary to perform
similarity detection. However, other approaches exist that use
an alternate representation language, so that binaries compiled
for all architectures are extracted into the same representation
language. Some methods turn to the well known LLVM-IR
[19, 20, 57] as representation language, and others prefer the
VEX intermediate representation [43, 50].
Full Program Similarity.An alternate approach to binary
matching is to compare whole binaries, instead of their indi-
vidual functions. This type of method constructs a fingerprint
for the whole binary as compared to having one embedding
per function. This approach is primarily used for malware
identification [27, 39, 40, 54], but also for identifying known
vulnerabilities [11, 30].
LLM-based software analysis. Researchers have found
many related applications of language models to binary and
software analysis. We give a sparse overview of the progress
that has been made in this area of research. For vulnerability
detection, FuncVul [21] is a language-model-based method
to detect whether a provided source function is vulnerable.
LLM4Decompile [45] tries to utilize LLMs for decompila-
tion. An open source LLM is fine-tuned to learn the source
code representation of an assembly function, and the model
is then evaluated on its decompilation capabilities. Fang et
al. [18] measure the competency of LLMs for source code
analysis, with a focus on obfuscated source code. Their results
match our findings, that LLMs are efficient at code analysis,
but they also demonstrate that language models still struggle
when faced with cases of advanced obfuscation techniques.
LLM-based fuzzing is another area that has recently gained
interest. For instance, Asmita et al. [4] use a LLM to generate
the initial seed of a fuzzing pipeline on the BusyBox [51]
executable."
