arxiv_id,arxiv_link,publication_date,title,abstract,raw_latex_related_works,clean_latex_related_works,pdf_related_works
2509.17914v1,http://arxiv.org/abs/2509.17914v1,2025-09-22 15:39:33+00:00,XaaS Containers: Performance-Portable Representation With Source and IR Containers,"High-performance computing (HPC) systems and cloud data centers are
converging, and containers are becoming the default method of portable software
deployment. Yet, while containers simplify software management, they face
significant performance challenges in HPC environments as they must sacrifice
hardware-specific optimizations to achieve portability. Although HPC containers
can use runtime hooks to access optimized MPI libraries and GPU devices, they
are limited by application binary interface (ABI) compatibility and cannot
overcome the effects of early-stage compilation decisions. Acceleration as a
Service (XaaS) proposes a vision of performance-portable containers, where a
containerized application should achieve peak performance across all HPC
systems. We present a practical realization of this vision through Source and
Intermediate Representation (IR) containers, where we delay
performance-critical decisions until the target system specification is known.
We analyze specialization mechanisms in HPC software and propose a new
LLM-assisted method for automatic discovery of specializations. By examining
the compilation pipeline, we develop a methodology to build containers
optimized for target architectures at deployment time. Our prototype
demonstrates that new XaaS containers combine the convenience of
containerization with the performance benefits of system-specialized builds.","\textbf{Building:}
%
% SC cut
%
Languages common in HPC, like C++ and Fortran, are notably missing in commonly used package managers.
%
EasyBuild~\cite{6495863} builds HPC applications from source using specific toolchains, supporting hierarchical module creation~\cite{7081225}.
%
Spack~\cite{10.1145/2807591.2807623} is a package manager that parameterizes builds with constraints and versioned dependencies.
%
Resolving dependencies can be reduced with declarative programming~\cite{10046107} or machine learning~\cite{10793143}.
E4S provides curated HPC software stacks, including hardware-specific containers~\cite{10513439,e4s}.
%
Binary distribution is possible: Spack uses binary caches~\cite{spackbinary}, and EESSI distributes EasyBuild stacks via network filesystems~\cite{https://doi.org/10.1002/spe.3075}.
%
\toolname{} complements these tools by addressing the trade-off between container portability and performance.

\textbf{Portable and HPC Containers:}
%
Injecting or replacing container libraries with host counterparts can be achieved with many container runtimes, but it can require expert knowledge of the system.
%
Apptainer~\cite{10.1371/journal.pone.0177459} supports semi-manual mounting of host MPI~\cite{apptainerdocs}.
%
Charliecloud~\cite{10.1145/3126908.3126925} uses heuristics to copy resource-specific files (NVIDIA, libfabric) into images, permanently modifying them.
%
Sarus~\cite{10.1007/978-3-030-34356-9_5, 10029965} and Podman-HPC~\cite{10030014} use OCI hooks to inject host MPI and GPU libraries.
%
\toolname{} can use the same hooks, but source containers can be compiled to use the version of the specialized library compatible with the one available on the system.
%
Vendor container registries offer optimized but platform-specific images~\cite{nvidiangc,amdinfinity}.

Containers can already contain intermediate representation as Python and Java bytecode~\cite{9242268}.
%
Popcorn Linux~\cite{10.1145/3093337.3037738} enables cross-ISA live migration with a custom compiler and kernel that transform LLVM IR into multi-ISA binaries with compatible data layouts~\cite{10.1145/3688351.3689152}.
%
H-Containers~\cite{10.1145/3381052.3381321, 10.1145/3524452} achieve migration by decompiling to LLVM IR and recompiling to different ISAs.
%
To the best of our knowledge, this is the only known use of IR for container deployment.
%
However, it differs fundamentally from \toolname{}: we use IR-based representations to access customized performance features of each system. 

\textbf{Performance Portability:}
%
Performance portability often involves rewriting applications using models like OpenMP, OpenACC, or SYCL~\cite{9484790, 10.1145/3529538.3529980}.
%
Frameworks provide new abstractions for memory access (Kokkos~\cite{CARTEREDWARDS20143202}), loop parallelism (Raja~\cite{8945721}), and data-centric programming (DaCe~\cite{10.1145/3458817.3476176}).
%
Compilers can translate programming idioms to specialized libraries~\cite{10.1145/3173162.3173182} and accelerators~\cite{10.1145/3578360.3580262},
and upgrade applications to use newer and specialized implementations of linear algebra libraries~\cite{8891611}.
%
\toolname{} focuses on portable representations of existing applications without rewriting or requiring single-source code.
%
We do not require applications to be single-source
or use the same set of source files across all systems and devices.

\textbf{Emulation, Translation, and JIT:}
%
Cross-ISA emulation, such as Docker with QEMU~\cite{dockerqemu}, is unsuitable for HPC due to performance overheads.
%
Runtime MPI ABI translation layers like\sloppy~Wi4MPI~\cite{9556086} can incur performance overhead.
%
Other tools include mpixlate~\cite{mpixlatecray} (compatibility with Cray MPI), MPITrampoline~\cite{schnetter_2022_6174409}, Mukautuva~\cite{mukautuva}, and MPI-Adapter2~\cite{10.1145/3636480.3637219}.
%
JIT compilation, used in CUDA PTX, OpenCL, SYCL IR~\cite{alpayOnePassBind2023}, allows for specialization of the final implementation by compiling the code dynamically.","\textbf{Building:}



Languages common in HPC, like C++ and Fortran, are notably missing in commonly used package managers.

EasyBuild~\cite{6495863} builds HPC applications from source using specific toolchains, supporting hierarchical module creation~\cite{7081225}.

Spack~\cite{10.1145/2807591.2807623} is a package manager that parameterizes builds with constraints and versioned dependencies.

Resolving dependencies can be reduced with declarative programming~\cite{10046107} or machine learning~\cite{10793143}.
E4S provides curated HPC software stacks, including hardware-specific containers~\cite{10513439,e4s}.

Binary distribution is possible: Spack uses binary caches~\cite{spackbinary}, and EESSI distributes EasyBuild stacks via network filesystems~\cite{https://doi.org/10.1002/spe.3075}.

\toolname{} complements these tools by addressing the trade-off between container portability and performance.

\textbf{Portable and HPC Containers:}

Injecting or replacing container libraries with host counterparts can be achieved with many container runtimes, but it can require expert knowledge of the system.

Apptainer~\cite{10.1371/journal.pone.0177459} supports semi-manual mounting of host MPI~\cite{apptainerdocs}.

Charliecloud~\cite{10.1145/3126908.3126925} uses heuristics to copy resource-specific files (NVIDIA, libfabric) into images, permanently modifying them.

Sarus~\cite{10.1007/978-3-030-34356-9_5, 10029965} and Podman-HPC~\cite{10030014} use OCI hooks to inject host MPI and GPU libraries.

\toolname{} can use the same hooks, but source containers can be compiled to use the version of the specialized library compatible with the one available on the system.

Vendor container registries offer optimized but platform-specific images~\cite{nvidiangc,amdinfinity}.

Containers can already contain intermediate representation as Python and Java bytecode~\cite{9242268}.

Popcorn Linux~\cite{10.1145/3093337.3037738} enables cross-ISA live migration with a custom compiler and kernel that transform LLVM IR into multi-ISA binaries with compatible data layouts~\cite{10.1145/3688351.3689152}.

H-Containers~\cite{10.1145/3381052.3381321, 10.1145/3524452} achieve migration by decompiling to LLVM IR and recompiling to different ISAs.

To the best of our knowledge, this is the only known use of IR for container deployment.

However, it differs fundamentally from \toolname{}: we use IR-based representations to access customized performance features of each system. 

\textbf{Performance Portability:}

Performance portability often involves rewriting applications using models like OpenMP, OpenACC, or SYCL~\cite{9484790, 10.1145/3529538.3529980}.

Frameworks provide new abstractions for memory access (Kokkos~\cite{CARTEREDWARDS20143202}), loop parallelism (Raja~\cite{8945721}), and data-centric programming (DaCe~\cite{10.1145/3458817.3476176}).

Compilers can translate programming idioms to specialized libraries~\cite{10.1145/3173162.3173182} and accelerators~\cite{10.1145/3578360.3580262},
and upgrade applications to use newer and specialized implementations of linear algebra libraries~\cite{8891611}.

\toolname{} focuses on portable representations of existing applications without rewriting or requiring single-source code.

We do not require applications to be single-source
or use the same set of source files across all systems and devices.

\textbf{Emulation, Translation, and JIT:}

Cross-ISA emulation, such as Docker with QEMU~\cite{dockerqemu}, is unsuitable for HPC due to performance overheads.

Runtime MPI ABI translation layers like\sloppy~Wi4MPI~\cite{9556086} can incur performance overhead.

Other tools include mpixlate~\cite{mpixlatecray} (compatibility with Cray MPI), MPITrampoline~\cite{schnetter_2022_6174409}, Mukautuva~\cite{mukautuva}, and MPI-Adapter2~\cite{10.1145/3636480.3637219}.

JIT compilation, used in CUDA PTX, OpenCL, SYCL IR~\cite{alpayOnePassBind2023}, allows for specialization of the final implementation by compiling the code dynamically.","Building: Languages common in HPC, like C++ and Fortran, are no-
tably missing in commonly used package managers. EasyBuild [ 44]
builds HPC applications from source using specific toolchains, sup-
porting hierarchical module creation [ 32]. Spack [ 31] is a package
manager that parameterizes builds with constraints and versioned
dependencies. Resolving dependencies can be reduced with declar-
ative programming [ 30] or machine learning [ 57]. E4S provides
curated HPC software stacks, including hardware-specific con-
tainers [ 41,78]. Binary distribution is possible: Spack uses binary
caches [ 71], and EESSI distributes EasyBuild stacks via network
filesystems [ 27]. XaaS complements these tools by addressing the
trade-off between container portability and performance.
Portable and HPC Containers: Injecting or replacing con-
tainer libraries with host counterparts can be achieved with many
container runtimes, but it can require expert knowledge of the
system. Apptainer [ 46] supports semi-manual mounting of host
MPI [ 6]. Charliecloud [ 65] uses heuristics to copy resource-specific
files (NVIDIA, libfabric) into images, permanently modifying them.
Sarus [ 13,51] and Podman-HPC [ 73] use OCI hooks to inject host
MPI and GPU libraries. XaaS can use the same hooks, but source con-
tainers can be compiled to use the version of the specialized library
compatible with the one available on the system. Vendor container
registries offer optimized but platform-specific images [5, 60].
Containers can already contain intermediate representation as
Python and Java bytecode [ 83]. Popcorn Linux [ 9] enables cross-ISA
live migration with a custom compiler and kernel that transform
LLVM IR into multi-ISA binaries with compatible data layouts [ 40].
H-Containers [ 8,79] achieve migration by decompiling to LLVM IR
and recompiling to different ISAs. To the best of our knowledge, this
is the only known use of IR for container deployment. However, it
differs fundamentally from XaaS: we use IR-based representations
to access customized performance features of each system.
Performance Portability: Performance portability often in-
volves rewriting applications using models like OpenMP, OpenACC,
or SYCL [ 17,63]. Frameworks provide new abstractions for memory
access (Kokkos [ 18]), loop parallelism (Raja [ 10]), and data-centric
programming (DaCe [ 84]). Compilers can translate programming id-
ioms to specialized libraries [ 36] and accelerators [ 53], and upgrade
applications to use newer and specialized implementations of linear
algebra libraries [22]. XaaS focuses on portable representations of
existing applications without rewriting or requiring single-source
code. We do not require applications to be single-source or use the
same set of source files across all systems and devices.
Emulation, Translation, and JIT: Cross-ISA emulation, such
as Docker with QEMU [ 26], is unsuitable for HPC due to
performance overheads. Runtime MPI ABI translation layers
like Wi4MPI [ 48] can incur performance overhead. Other tools
include mpixlate [23] (compatibility with Cray MPI), MPITrampo-
line [ 68], Mukautuva [ 38], and MPI-Adapter2 [ 74]. JIT compilation,
used in CUDA PTX, OpenCL, SYCL IR [ 4], allows for specialization
of the final implementation by compiling the code dynamically"
