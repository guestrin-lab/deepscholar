\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass[acmsmall,screen,nonacm]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\pdfoutput=1



\setcopyright{none}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}   %




\usepackage{booktabs}   %
\usepackage{subcaption} %
\usepackage[dvipsnames]{xcolor}
\usepackage{bcprules}
\usepackage{collcell}
\usepackage{listings}
\usepackage[scaled=0.8]{beramono}
\usepackage{lipsum}
\usepackage{mathpartir}
\def \TirNameStyle #1{\inflabel{#1}}
\usepackage{mathtools}
\usepackage{mdframed}
\usepackage{amsmath}
\usepackage{varioref}
\usepackage{cleveref}
\usepackage{scalerel}
\usepackage{xspace}
\usepackage{calc}
\usepackage{array,varwidth}
\usepackage{makecell}
\usepackage{diagbox}
\usepackage{float}
\usepackage{xfrac}
\usepackage{enumitem}
\usepackage[skip=2.5pt]{caption}
\usepackage{slashbox}
\usepackage{xifthen}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{arrows}
\usepackage{cancel}
\usepackage{bm}
\usepackage{multicol}
\usepackage[export]{adjustbox}
\usepackage[compact]{titlesec}



\usetikzlibrary{shadows}
\usetikzlibrary{shadows.blur}
\usetikzlibrary{decorations.pathreplacing} %
\tikzcdset{arrow style=tikz,
           diagrams={>=stealth}
         }    %
\tikzcdset{crossing over clearance=.75ex}
\tikzset{hardd/.style={teal,thick}} %
\tikzset{softd/.style={teal, dashed,thick}} %
\tikzset{datad/.style={black,densely dotted}} %
\tikzset{alld/.style={black,thick}} %
\tikzset{expnode/.style={
    asymmetrical rectangle,rounded corners,draw,fill=white,inner sep=2.5pt,
    font=\footnotesize, %
  }} %
\tikzset{blknode/.style={
    asymmetrical rectangle,sharp corners,draw,violet,fill=violet!10,
    font=\footnotesize %
  }} %
\tikzset{dummynode/.style={fill=none,draw=none,asymmetrical rectangle} %
} %
\tikzset{nmute/.style={opacity=.4,blur shadow={shadow opacity=.4}}} %
\tikzset{expn/.style={
    circle,fill=white,draw,minimum size=5pt,inner sep=0pt,outer sep=0pt,
    font=\footnotesize, %
    label={[font=\footnotesize]left:#1}
  }} %
\tikzset{expn/.default={}}
\tikzset{mexpn/.style={opacity=.4,
    circle,fill=white,draw,minimum size=5pt,inner sep=0pt,outer sep=0pt,
    font=\footnotesize, %
    label={[font=\footnotesize,opacity=.4]left:#1}
  }} %
\tikzset{mexpn/.default={}}
\tikzset{rmexpn/.style={opacity=.4,
    circle,fill=white,draw,minimum size=5pt,inner sep=0pt,outer sep=0pt,
    font=\footnotesize, %
    label={[font=\footnotesize,opacity=.4]right:#1}
  }} %
\tikzset{rmexpn/.default={}}
\tikzset{mexpndummy/.style={opacity=.4,
    circle,fill=white,minimum size=5pt,inner sep=0pt,outer sep=0pt,
    label={[font=\footnotesize,opacity=.4]left:#1}
  }} %
\tikzset{mexpndummy/.default={}}


\makeatletter %
\def\arcr{\@arraycr}
\makeatother

\newcommand{\showDOI}[1]{\unskip}

\newcommand{\tikzmark}[1]{\tikz[overlay,remember picture] \node (#1) {};}

\newtheorem{innercustomgeneric}{\customgenericname}
\providecommand{\customgenericname}{}
\newcommand{\newcustomtheorem}[2]{%
  \newenvironment{#1}[1]
  {%
   \renewcommand\customgenericname{#2}%
   \renewcommand\theinnercustomgeneric{##1}%
   \innercustomgeneric
  }
  {\endinnercustomgeneric}
}
\newcustomtheorem{re-definition}{Definition}
\newcustomtheorem{re-lemma}{Lemma}


\newcommand{\figref}[1]{Fig.~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}} %
\newcommand{\thmref}[1]{Theorem~\ref{#1}}
\newcommand{\lemref}[1]{Lemma~\ref{#1}}
\newcommand{\colref}[1]{Corollary~\ref{#1}}
\newcommand{\defref}[1]{Def.~\ref{#1}}
\newcommand{\appref}[1]{Appendix~\ref{#1}}
\newcommand{\tbref}[1]{Table~\ref{#1}}

\newcommand{\deps}{\textit{deps}}
\newcommand{\efsb}{\ensuremath{\mapsto}}
\newcommand{\dvdash}[1]{\ensuremath{\vdash_{#1}}}
\newcommand{\SUBTYPE}{\ensuremath{\leq:}}
\newcommand{\SUBEFF}{\ensuremath{\leq_{e}}}
\newcommand{\fr}{\textbf{\textit{fr}}}
\newcommand{\dyn}{\textit{dyn}}
\newcommand{\bdv}{\textit{bdv}}
\newcommand{\body}{\textit{body}}
\newcommand{\ret}{\textit{ret}}
\newcommand{\fv}{\textit{FV}}
\newcommand{\dv}{\textit{DV}}
\newcommand{\tr}{\textit{TR}}
\newcommand{\dreduces}{\;\iff\;}
\newcommand{\preduces}{\;\implies\;}
\newcommand{\mpreduces}{\ensuremath{\;\implies\!\!\!\!*\;}}
\newcommand{\mreduces}{\ensuremath{\xrightarrow{*}}}
\newcommand{\nf}{\textit{nf}}
\newcommand{\dplus}{\ensuremath{\uplus}}
\newcommand{\vars}{\textit{Vars}}
\newcommand{\first}{\textit{first}}
\newcommand{\rest}{\textit{rest}}
\newcommand{\last}{\textit{last}}
\newcommand{\occ}{\textit{Occ}}
\newcommand{\stdout}{\textit{stdout}}
\newcommand{\erase}{\textit{erase}}
\newcommand{\anno}{\textit{anno}}

\newcommand{\QED}{\rule{0.4em}{0.65em}}

\newcommand{\Specsharp}{%
	{\settoheight{\dimen0}{C}Spec\kern-.05em \resizebox{!}{\dimen0}{\raisebox{\depth}{\#}}}}
\newcommand{\Csharp}{%
	{\settoheight{\dimen0}{C}C\kern-.05em \resizebox{!}{\dimen0}{\raisebox{\depth}{\#}}}}

\newcommand{\nonterm}[1]{\textrm{\textit{#1}}}
\newcommand{\KW}[1]{\texttt{\textbf{#1}}}
\newcommand{\fun}[1]{\operatorname{#1}}
\newcommand{\DOM}{\fun{dom}}
\newcommand{\CODOM}{\fun{codom}}

\newenvironment{nscenter}
 {\parskip=0pt\par\nopagebreak\centering}
 {\par\noindent\ignorespacesafterend}


\definecolor{blue-violet}{rgb}{0.54, 0.17, 0.89}
\definecolor{depmap}{HTML}{00007B}
\definecolor{dark-cyan}{HTML}{135579}
\definecolor{magenta}{HTML}{a8264f}

\lstdefinelanguage{Neutral}%
{morekeywords={abstract,%
  case,catch,char,class,%
  def,else,extends,final,finally,for,%
  if,import,implicit,%
  match,module,%
  new,null,%
  object,override,%
  package,private,protected,public,%
  for,public,return,super,%
  this,trait,try,type,%
  val,var,%
  with,while,%
  yield,%
  let,end,%
	in,fun,alloc,inc%
  },%
  mathescape=true,%
  sensitive,%
  keywordstyle={\color{black}\bf\ttfamily},%
  commentstyle=\color{OliveGreen},%
  escapebegin=\color{OliveGreen},
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morecomment=[s][\color{darkgray}]{@}{\ },%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%

\lstdefinelanguage{OOPSLA21}%
{morekeywords={abstract,%
  case,catch,char,class,%
  def,else,extends,final,finally,for,%
  if,import,implicit,%
  match,module,%
  new,null,%
  object,override,%
  package,private,protected,public,%
  for,public,return,super,%
  this,throw,trait,try,type,%
  val,var,%
  with,while,%
  yield,%
  let,end,%
	in,fun,alloc,inc%
  },%
  mathescape=true,%
  sensitive,%
  keywordstyle={\color{magenta}\bf\ttfamily},%
  commentstyle=\color{magenta},%
  escapebegin=\color{magenta},
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morecomment=[s][\color{magenta}]{@}{\ },%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%
\def\inline{\lstinline[basicstyle=\small]}

\lstdefinelanguage{PolyRT}%
{morekeywords={abstract,fn,%
  case,catch,char,class,%
  def,else,extends,final,finally,for,%
  if,import,implicit,%
  match,module,%
  new,null,%
  object,override,%
  package,private,protected,public,%
  for,public,return,super,%
  this,throw,trait,try,type,%
  val,var,%
  with,while,%
  yield,%
  let,end,%
	in,fun,%
  move,%
  map,%
  },%
  mathescape=true,%
  sensitive,%
  keywordstyle={\color{dark-cyan}\bf\ttfamily},%
  commentstyle=\color{dark-cyan},%
  escapebegin=\color{dark-cyan},%
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morecomment=[s][\color{dark-cyan}]{@}{\ },%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%
\def\inline{\lstinline[basicstyle=\small]}

\lstset{
	language=PolyRT,
	basicstyle=\footnotesize\ttfamily,
	%
	%
	mathescape=true,
	commentstyle=\color{dark-cyan},
  aboveskip=2pt,
  belowskip=2pt,
  literate={≠}{@}1%
  {←}{{$\leftarrow$}\lst@whitespacefalse}2
  {↦}{{$\mapsto$}\lst@whitespacefalse}2
  {ₕ}{{$_h$}}1
  {ₛ}{{$_s$}}1
  {→}{$\rightarrow$\lst@whitespacefalse}2
  {⇒}{$\Rightarrow$\lst@whitespacefalse}2
}
\def\inline{\lstinline[basicstyle=\footnotesize\ttfamily]}

\lstset{escapeinside={<<}{>>}}

\newcommand{\note}[1]{{\color{red}[#1]}}
\newcommand{\red}[1]{{\color{red}#1}}
\newcommand{\todo}[1]{\note{TODO: #1}}
\newcommand{\rev}[1]{\note{Revision: #1}}


\newcommand{\untrack}[0]{^{\bot}}
\newcommand{\trackset}[1]{^{\texttt{\{#1\}}}}
\newcommand{\track}[0]{^{\varnothing}}
\newcommand{\trackvar}[1]{^{\texttt{#1}}}
\newcommand{\trackfresh}{^{\texttt{\ensuremath\vardiamondsuit}}}
\newcommand{\trackapp}[2]{^{\texttt{#1(#2)}}}

\newcommand{\untrackl}[0]{^{\bot}}
\newcommand{\tracksetl}[1]{^{\tt{\{#1\}}}}
\newcommand{\trackvarl}[1]{^{\tt{#1}}}
\newcommand{\trackl}[0]{^{\varnothing}}
\newcommand{\tracksetc}[1]{^{\texttt{\{#1\}}}}
\newcommand{\arrowl}[0]{\longrightarrow}


\newcommand{\popllang}{\ensuremath{\lambda^{\vardiamondsuit}}\xspace}
\newcommand{\maybelang}{\ensuremath{\lambda^{\vardiamondsuit}}_R\xspace}
\newcommand{\polylang}{\ensuremath{\mathsf{F}_{<:}^{\vardiamondsuit}}\xspace}

\newcommand{\Type}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\Var}{\Type{Var}}
\newcommand{\FVar}{\Type{FVar}}
\newcommand{\TRef}{\Type{Ref}}
\newcommand{\TTop}{\Type{Top}}
\newcommand{\tref}{\mathsf{ref}}
\newcommand{\TUnit}{\Type{Unit}}
\newcommand{\tunit}{\mathsf{unit}}
\newcommand{\Loc}{\Type{Loc}}
\newcommand{\tmove}{\mathsf{move}}
\newcommand{\tlet}{\mathsf{let}}
\newcommand{\isVar}{\mathsf{isVar}}

\newcommand{\ty}[2][]{\ensuremath{\ifthenelse{\isempty{#1}}{#2}{#2^{\,#1}}}}

\newcommand{\TAll}[6]{\ensuremath{\forall f(\ty[#2]{#1} <: \ty[#4]{#3}) . \ty[#6]{#5}}}
\newcommand{\TLam}[5]{\ensuremath{\Lambda f(\ty[#2]{#1}) . {#5}}}
\newcommand{\TApp}[3]{\ensuremath{{#1}\ [\ty[#3]{#2}]}}


\newcommand{\ts}[1][]{\ensuremath{\ifthenelse{\isempty{#1}}{\,\vdash\,}{\,\vdash^{\,#1}\,}}}

\newcommand{\flt}{\ensuremath{\varphi}}

\newcommand{\cx}[2][]{\ensuremath{\ifthenelse{\isempty{#1}}{#2}{#2^{\,#1}}}}

\providecommand{\G}{G} %
\renewcommand{\G}[1][]{\cx[#1]{\Gamma}}

\newcommand{\HLBox}[2][teal!12]{\ensuremath{\mathchoice%
  {\setlength{\fboxsep}{.5ex}\colorbox{#1}{$\displaystyle#2$}}%
  {\setlength{\fboxsep}{.5ex}\colorbox{#1}{$\textstyle#2$}}%
  {\setlength{\fboxsep}{.5ex}\colorbox{#1}{$\scriptstyle#2$}}%
  {\setlength{\fboxsep}{.5ex}\colorbox{#1}{$\scriptscriptstyle#2$}}}}%

\newcommand{\GrayBoxSC}[1]{\HLBox[gray!20]{\textsc{#1}}}

\newcommand{\QFresh}{\ensuremath{\vardiamondsuit}}
\newcommand{\qbot}{\ensuremath{\varnothing}}
\newcommand{\qfresh}{\ensuremath{\vardiamondsuit}}
\newcommand{\subq}{\ensuremath{\subseteq}}
\newcommand{\qlub}{\ensuremath{\cup}}
\newcommand{\qglb}{\ensuremath{\cap}}
\newsavebox{\SMALLSTAR}
\savebox{\SMALLSTAR}{\(\raisebox{.25ex}{\(\qfresh\)}\)}
\newcommand{\starred}[1]{\ensuremath{\mathord{\scalerel*{\usebox{\SMALLSTAR}}{*}}#1}}
\newsavebox{\OVRLP}
\savebox{\OVRLP}{$\raisebox{.37ex}[0pt][0pt]{$\mathrlap{\hspace{.415ex}\scaleobj{.5}{\vardiamondsuit}}$}\cap$}
\def\overlap{\ensuremath{\mathbin{\scalerel*{\usebox{\OVRLP}}{\sqcap}}}}
\def\nonoverlap{\ensuremath{\not\mathclap{\overlap}\phantom{n}}}
\newcommand{\qqplus}{\ensuremath{\Cup}}
\newcommand{\qsat}[1]{\ensuremath{#1\mathord{*}}}
\newcommand{\WF}[1]{\ensuremath{#1\ \mathsf{ok}}}
\newcommand{\reaches}{\ensuremath{\mathrel{\leadsto}}}

\newcommand{\BOX}[1]{\fbox{$\strut #1$}}

\newcommand{\FV}{\ensuremath{\operatorname{fv}}}
\newcommand{\FTV}{\ensuremath{\operatorname{ftv}}}

\newcommand{\vgap}{\vspace{7pt}}

\newcommand{\bao}[1]{{\color{magenta}#1}}
\newcommand{\baotype}[2]{{\color{magenta}{\lstinline[language=OOPSLA21,mathescape=true]{#1}\ensuremath{{#2}}}}}
\newcommand{\baoterm}[1]{{\lstinline[language=OOPSLA21]{#1}}}
\newcommand{\polytype}[2]{{\color{dark-cyan}{\lstinline{#1}\ensuremath{{#2}}}}}
\newcommand{\polyterm}[1]{{\color{dark-cyan}{\lstinline{#1}}}}

\newcommand{\hole}[1]{\ensuremath{[\,#1\,]}}
\newcommand{\CX}[3][black]{\ensuremath{{\color{#1}#2\ifthenelse{\isempty{#3}}{}{\hole{{\color{black}#3}}}}}}

\newcommand{\ie}{{\em i.e.}\xspace}

\newcommand{\rulename}[1]{\textsc{\small{(#1)}}} %

\newcommand{\CFsub}{\ensuremath{\mathsf{CF}_{<:}}\xspace}
\newcommand{\CFsubbox}{\ensuremath{\mathsf{CF}_{<:\square}}\xspace}
\newcommand{\Fsub}{\ensuremath{\mathsf{F}_{<:}}\xspace}

\makeatletter
\newcommand{\artifacturl}[1]{
  \if@ACM@anonymous
    Link to repository removed for double-blind review.
  \else
    \url{#1}
  \fi
}
\makeatother
\newcommand{\artifact}{\artifacturl{https://github.com/tiarkrompf/reachability}\xspace}

\newcommand\scalemath[2]{\scalebox{#1}{\mbox{\ensuremath{\displaystyle #2}}}}

\newcommand{\fontsmall}{\fontsize{7pt}{8pt}\selectfont}

\newcommand{\sfparagraph}[1]{\paragraph{\textsf{\textbf{\upshape #1}}}}
\newcommand{\bfparagraph}[1]{\paragraph{\textbf{#1}}}

\colorlet{eff}{dark-cyan}
\newcommand{\FX}[1]{\ensuremath{{\color{eff}#1}}}
\newcommand{\EPS}[1][]{\ifthenelse{\isempty{#1}}{\FX{\bm{\varepsilon}}}{\FX{\bm{\varepsilon_{#1}}}}}
\newcommand{\EPSS}[1][]{\ifthenelse{\isempty{#1}}{\FX{\qsat{\bm{\varepsilon}}}}{\FX{\qsat{\bm{\varepsilon_{#1}}}}}}
\newcommand{\EPSPR}[1][]{\ifthenelse{\isempty{#1}}{\FX{\bm{\varepsilon'}}}{\FX{\bm{\varepsilon'_{#1}}}}}
\newcommand{\EPSSPR}[1][]{\ifthenelse{\isempty{#1}}{\FX{\qsat{\bm{\varepsilon'}}}}{\FX{\qsat{\bm{\varepsilon'_{#1}}}}}}
\newcommand{\PURE}{\FX{\boldsymbol{\varnothing}}}
\newcommand{\EFFSEQ}{\ensuremath{\!\mathbin{\FX{\boldsymbol{,}}}}}

\newcommand{\rd}{\textsf{rd}}
\renewcommand{\wr}{\textsf{wr}}

\colorlet{meff}{Gray}
\newcommand{\M}{\mathnormal{m}}
\newcommand{\MFX}[1]{\ensuremath{{\color{meff}#1}}}
\newcommand{\MV}[1][]{\ifthenelse{\isempty{#1}}{\MFX{\bm{\M}}}{\MFX{\bm{\M_{#1}}}}}
\newcommand{\MVSEQ}{\ensuremath{\!\mathbin{\MFX{\boldsymbol{,}}}}}

\newcommand{\synth}{\ensuremath{\Rightarrow}}
\newcommand{\chek}{\ensuremath{\Leftarrow}}
\newcommand{\ccup}[1]{\ensuremath{\cup_{{#1}}}}
\newcommand{\sep}{\ensuremath{\nonoverlap}}

\newcommand{\has}{\ensuremath{\mathbin{\bullet}}}
\colorlet{mute}{teal}
\newcommand{\mute}[1]{{\color{mute}#1}}

\newcommand*{\algout}[1]{{\color{purple}{#1}}}

\newcommand{\newcontent}[1]{\colorbox{pink}{\ensuremath{#1}}}
\newcommand{\extendedlang}{\ensuremath{\lambda^{\vardiamondsuit}}_E\xspace}
\newcommand{\occur}[2]{\ensuremath{\text{\textit{@}}^{#1} ~ #2}}

\newcommand{\ttrue}{\texttt{true}}
\newcommand{\tfalse}{\texttt{false}}
\newcommand{\tvar}[1]{#1}
\renewcommand{\tref}[1]{\texttt{ref}\ #1}
\newcommand{\tget}[1]{\texttt{!}#1}
\newcommand{\tput}[2]{#1\ \texttt{:=}\ #2}
\newcommand{\tapp}[2]{#1\ #2}
\newcommand{\tabs}[1]{\lambda x.\ #1}

\renewcommand{\tlet}[3]{\texttt{let}\ #1 = #2\ \texttt{in}\ #3}
\newcommand{\tseq}[2]{#1; #2}
\newcommand{\tseqb}[2]{#1 \otimes #2}

\newcommand{\qempty}{\emptyset}
\newcommand{\qone}[1]{\{#1\}}
\newcommand{\qor}[2]{#1 \cup #2}
\newcommand{\qdiff}[2]{#1 \setminus #2}

\newcommand{\bfalse}{\bot}
\newcommand{\btrue}{\top}


\newcommand{\extends}{\ensuremath{\ensuremath{;}}}
\newcommand{\config}[3]{\ensuremath{{#1},\ {#2},\ {#3}}}
\newcommand{\pconfig}[2]{\ensuremath{{#1},\ {#2}}}
\newcommand{\cll}[2]{\ensuremath{\langle {#1}, \ {#2} \rangle }}
\newcommand{\eval}{\Downarrow}

\newcommand{\TE}{T^{e}}
\newcommand{\TEP}{T^{e'}}
\newcommand{\GE}{\Gamma^{e}}
\newcommand{\GEP}{\Gamma^{e'}}

\newcommand{\bfalseE}{\textcolor{red}{\bot}}
\newcommand{\btrueE}{\textcolor{red}{\top}}
\newcommand{\EF}[1]{\textcolor{red}{#1}}
\newcommand{\EFC}{\ensuremath{\textcolor{red}{\rhd}}}

\newcommand{\hasTypeE}[4]{#1 \vdash_e #2 : #3\ \EF{#4}}
\newcommand{\indexrTypeE}[3]{#1(#2) = #3}

\newcommand{\TFunE}[3]{#1 \stackrel{\textcolor{red}{#3}}{\to} #2}
\newcommand{\TBoolE}{\texttt{Bool}}
\newcommand{\TRefE}{\texttt{Ref}}
\newcommand{\subtypeTE}[2]{#1\ <: #2}
\newcommand{\subtypeEE}[2]{\textcolor{red}{#1\ <: #2}}

\newcommand{\semTypeE}[5]{#1 \models_e #2 \equivlog_{\EF{e}} #3 : #4\ \textcolor{red}{#5}}
\newcommand{\ETE}[2]{\ensuremath{\mathcal{E}\synbracket{#1\ \textcolor{red}{#2}}}}
\newcommand{\ctxEquivE}[5]{#1 \models_e #2 \equiva_{\EF{e}} #3 : #4\ \textcolor{red}{#5}}




\newcommand{\TA}{T^{a}}
\newcommand{\TAP}{T^{a'}}
\newcommand{\GA}{\Gamma^{a}}
\newcommand{\GAP}{\Gamma^{a'}}

\newcommand{\bfalseA}{\textcolor{blue}{\bot}}
\newcommand{\btrueA}{\textcolor{blue}{\top}}
\newcommand{\AB}[1]{\textcolor{blue}{#1}}

\newcommand{\hasTypeA}[4]{#1 \vdash_a #2 : #3\ \textcolor{blue}{#4}}
\newcommand{\indexrTypeA}[4]{#1(#2) = #3\ #4}
\renewcommand{\fv}[1]{\mathrm{fv}(#1)}
\newcommand{\envCapA}[3]{\textcolor{blue}{#1(#2) <: #3}}
\newcommand{\envCapFalseA}[2]{#1(#2) = \bfalse}
\newcommand{\envCapTrueA}[2]{#1(#2) \ne \bfalse}
\newcommand{\hasTypePhiA}[5]{#1\ \textcolor{blue}{#2} \vdash_a #3 : #4\ \textcolor{blue}{#5}}


\newcommand{\TFunA}[4]{#1\ \textcolor{blue}{#2} \to #3\ \textcolor{blue}{#4}}
\newcommand{\TBoolA}{\texttt{Bool}}
\newcommand{\TRefA}{\texttt{Ref}}

\newcommand{\subtypeTA}[2]{#1 <: #2}
\newcommand{\subtypeAA}[2]{\textcolor{blue}{#1 <: #2}}

\newcommand{\semTypeA}[5]{#1 \models_a #2 \equivlog_{\AB{a}} #3 : #4\ \textcolor{blue}{#5}}
\newcommand{\ETA}[2]{\ensuremath{\mathcal{E}\synbracket{#1\ \textcolor{blue}{#2}}}}
\newcommand{\ctxEquivA}[5]{#1 \models_a #2 \equiva_{\AB{a}} #3 : #4\ \textcolor{blue}{#5}}


\newcommand{\hasTypeAE}[5]{#1 \vdash #2 : #3\ \ #4\ #5}
\newcommand{\hasTypeAEC}[5]{#1 \vdash #2 : #3\ \ \textcolor{blue}{#4}\ \textcolor{red}{#5}}
\newcommand{\TBoolAE}{\texttt{Bool}}
\newcommand{\TRefAE}{\texttt{Ref}}
\newcommand{\TFunAE}[5]{#1\ \textcolor{blue}{#2} \stackrel{\textcolor{red}{#5}}{\to} #3\ \textcolor{blue}{#4}}

\newcommand{\av}[2]{\langle #1, #2 \rangle}
\newcommand{\avc}[2]{\textcolor{blue}{\langle\ #1,\ #2\ \rangle}}
\newcommand{\avbot}{\textcolor{blue}{\langle \bot \rangle}}
\newcommand{\avtop}{\textcolor{blue}{\langle \top \rangle}}

\newcommand{\trTA}[1]{\synbracket{#1}^a_{ae}}
\newcommand{\trTE}[1]{\synbracket{#1}^e_{ae}}

\newcommand{\DEF}{\stackrel{{\rm def}}{=}}
\newcommand{\restricts}[2]{{#1}\!\downharpoonright\!{#2}}
\newcommand{\st}[5]{\ensuremath{\scalebox{0.9}{\boxed{\!(#1, #2): #3\!}}}^{~ \scriptstyle #4}_{~ \scriptstyle #5}}

\newcommand{\VE}{\ensuremath{\hat{H}}}
\newcommand{\R}{\ensuremath{\hat{R}}}
\newcommand{\W}{\texttt{W}}
\newcommand{\stcp}[4]{\ensuremath{#1}\equiv_{({#3}{#4})}{#2}}
\renewcommand{\fr}[2]{\ensuremath\texttt{fr}({#1}, {#2})}
\newcommand{\stw}[3]{\ensuremath{{#1}{\rightarrow{\!\scalebox{0.7}[0.7]{{$#3$}}}}}{~#2}}

\newcommand{\lsv}[1]{\ensuremath{\texttt{L}_{#1}}}


\newcommand{\synbracket}[1]{[\![{#1}]\!]}
\newcommand{\VT}[1]{\ensuremath{\mathcal{V}\synbracket{#1}}}
\newcommand{\ETAE}[3]{\ensuremath{\mathcal{E}\synbracket{#1\ \textcolor{blue}{#2}\ \textcolor{red}{#3}}}}
\newcommand{\VG}[1]{G\synbracket{{#1}}}

\newcommand{\carrow}{\Rrightarrow}
\newcommand{\equiva}{\ensuremath{\cong}}
\newcommand{\equivlog}{\ensuremath{\mathrel{\approx_{\text{log}}}}}
\newcommand{\semTypeAE}[6]{#1 \models #2 \equivlog #3 : #4\ \textcolor{blue}{#5}\ \textcolor{red}{#6}}
\newcommand{\ctxEquivAE}[6]{#1 \models #2 \equiva #3 : #4\ \textcolor{blue}{#5}\ \textcolor{red}{#6}}

\newcommand{\vallocs}[1]{\ensuremath{\mathnormal{L}({#1})}}
\newcommand{\varslocs}[2]{\mathnormal{L}_{#2}{(#1)}}
\newcommand{\explocs}[2]{\ensuremath{\mathnormal{L}_{#2}{(\fv{#1})}}}


\newcommand*\recdx[1]{\protect\tikz[baseline=(char.base)]{
            \protect \node[shape=rectangle,draw,inner sep=1.5pt,color=teal, font=\small] (char) {#1};}}
\newcommand{\NUM}[2]{\ensuremath{{\recdx{#1}}}~{#2}}

\newcommand{\ab}[1]{\ensuremath\textcolor{blue}{#1}}
\newcommand{\ef}[1]{\ensuremath\textcolor{red}{#1}}


\lstdefinelanguage{DOT}%
{morekeywords={val,new},%
  sensitive,%
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%

\newcommand{\figurebox}[1]
        {\fbox{\begin{minipage}{\textwidth} #1 \medskip\end{minipage}}}
\newcommand{\twofig}[3]
        {\begin{figure*}[t]#3\ \hrulefill\
        \caption{\label{#1}#2}\end{figure*}}
\newcommand{\boxfig}[3]
        {\begin{figure*}\figurebox{#3\caption{\label{#1}#2}}\end{figure*}}

\newcommand{\ttag}[1]{\mbox{\textsc{\small(#1)}}}
\newlength{\trulemargin}
\newlength{\trulewidth}
\newlength{\srulewidth}
\setlength{\trulemargin}{1.75cm}
\setlength{\trulewidth}{83.7mm}
\setlength{\srulewidth}{6.0cm}
\newenvironment{trules}{$\vspace{0.5em}\ba{p{\trulemargin}@{~}p{\trulewidth}@{~}p{\trulemargin}}}{\ea$}
\newenvironment{srules}{$\vspace{0.5em}\ba{p{\trulemargin}@{~}p{\srulewidth}}}{\ea$}
\newcommand{\laxiom}[2]{\ttag{#1} & $ #2 \hfill\ }
\newcommand{\raxiom}[2]{\hfill #2 $& \hfill \ttag{#1}}
\newcommand{\caxiom}[2]{\ttag{#1} & $\hfill #2 \hfill $& \ }
\newcommand{\lrule}[3]{\laxiom{#1}{\irule{#2}{#3}}}
\newcommand{\rrule}[3]{\raxiom{#1}{\irule{#2}{#3}}}
\newcommand{\crule}[3]{\caxiom{#1}{\irule{#2}{#3}}}
\newcommand{\lsrule}[3]{\lsaxiom{#1}{\irule{#2}{#3}}}
\newcommand{\rsrule}[3]{\rsaxiom{#1}{\irule{#2}{#3}}}
\newcommand{\nl}{\end{trules}\\[0.5em] \begin{trules}}
\newcommand{\snl}{\end{srules}\\[0.5em] \begin{srules}}

\newcommand{\comma}{,\,}
\newcommand{\commadots}{\comma \ldots \comma}
\newcommand{\semi}{;\mbox{;};}
\newcommand{\semidots}{\semi \ldots \semi}

\newcommand{\gap}{\quad\quad}
\newcommand{\biggap}{\quad\quad\quad}
\newcommand{\nextline}{\\ \\}
\newcommand{\htabwidth}{0.5cm}
\newcommand{\tabwidth}{1cm}
\newcommand{\htab}{\hspace{\htabwidth}}
\newcommand{\tab}{\hspace{\tabwidth}}
\newcommand{\linesep}{\ \hrulefill \ \smallskip}

\newenvironment{myproof}{{\em Proof:}}{$\Box$}
\newenvironment{proofsketch}{{\em Proof Sketch:}}{$\Box$}
\newcommand{\Case}{{\em Case\ }}


\newcommand{\mathem}{\bf}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\sbs}[1]{\lquote #1 \rquote}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\bda}{\[\ba}
\newcommand{\eda}{\ea\]}
\newcommand{\ei}{\end{array}}
\newcommand{\bcases}{\left\{\begin{array}{ll}}
\newcommand{\ecases}{\end{array}\right.}

\renewcommand{\AA}{{\cal A}}
\newcommand{\BB}{{\cal B}}
\newcommand{\CC}{{\cal C}}
\newcommand{\DD}{{\cal D}}
\newcommand{\EE}{{\cal E}}
\newcommand{\FF}{{\cal F}}
\newcommand{\GG}{{\cal G}}
\newcommand{\HH}{{\cal H}}
\newcommand{\II}{{\cal I}}
\newcommand{\JJ}{{\cal J}}
\newcommand{\KK}{{\cal K}}
\newcommand{\LL}{{\cal L}}
\newcommand{\MM}{{\cal M}}
\newcommand{\NN}{{\cal N}}
\newcommand{\OO}{{\cal O}}
\newcommand{\PP}{{\cal P}}
\newcommand{\QQ}{{\cal Q}}
\newcommand{\RR}{{\cal R}}
\newcommand{\TT}{{\cal T}}
\newcommand{\UU}{{\cal U}}
\newcommand{\VV}{{\cal V}}
\newcommand{\WW}{{\cal W}}
\newcommand{\XX}{{\cal X}}
\newcommand{\YY}{{\cal Y}}
\newcommand{\ZZ}{{\cal Z}}

\newcommand{\dhd}{\!\!\!\!\!\rightarrow}
\newcommand{\Dhd}{\!\!\!\!\!\Rightarrow}
\newcommand{\tS}{\,\vDash\,}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\eg}{{\em e.g.}\xspace}

\newcommand{\dom}{\mbox{\sl dom}}
\newcommand{\fn}{\mbox{\sl fn}}
\newcommand{\bn}{\mbox{\sl bn}}
\newcommand{\sig}{\mbox{\sl sig}}
\newcommand{\IF}{\mbox{\mathem if}}
\newcommand{\OTHERWISE}{\mbox{\mathem otherwise}}
\newcommand{\expand}{\prec}
\newcommand{\weakexpand}{\prec^W}
\newcommand{\spcomma}{~,~}
\newcommand{\spsep}{~;~}

\newcommand{\trans}[1]{\la\!\la#1\ra\!\ra}

\newcommand{\Scala}{\mbox{\textsc{Scala}}}
\newcommand{\Java}{\mbox{\textsc{Java}}}



\newcommand{\sub}{<:}
\newcommand{\typ}{:}
\newcommand{\approxtyp}{:_{<:}}
\newcommand{\reduces}{\;\rightarrow\;}
\newcommand{\wf}{\;\mbox{\textbf{wf}}}
\newcommand{\wfe}{\;\mbox{\textbf{wfe}}}

\newcommand{\tsel}{\#}
\newcommand{\tfun}{\rightarrow}
\newcommand{\dfun}[3]{(#1\!:\!#2) \Rightarrow #3}
\newcommand{\tand}{\wedge}
\newcommand{\tor}{\vee}
\newcommand{\sing}{.\textbf{type}}

\newcommand{\judgement}[2]{{\textsf{\textbf{#1}}} \hfill #2}
\newcommand{\refine}[2]{\left\{#1 \Rightarrow #2 \right\}}
\newcommand{\ldefs}[1]{\left\{#1\right\}}
\newcommand{\seqforall}[2]{\overbrace{#1}^{\forall #2}}
\newcommand{\seq}[1]{\colorlet{default}{.}\color{gray}\overline{\color{default}#1}\color{default}}
\newcommand{\dabs}[3]{(#1\!:\!#2)\Rightarrow #3}
\newcommand{\abs}[3]{\lambda #1\!:\!#2.#3}
\newcommand{\app}[2]{#1\;#2}
\newcommand{\mapp}[3]{#1.#2(#3)}
\newcommand{\subst}[3]{[#1/#2]#3}
\newcommand{\new}[3]{\textbf{val }#1 = \textbf{new }#2 ;\; #3}
\newcommand{\anfmapp}[5]{\textbf{val }#1 = {#2.#3(#4)} ;\; #5}
\newcommand{\anfmexe}[5]{\textbf{val }#1 = {#2.#3\ldots\;#4} ;\; #5}
\newcommand{\Ldecl}[3]{#1 : #2..#3}%
\newcommand{\ldecl}[2]{#1 : #2}
\newcommand{\mdecl}[3]{#1 : #2 \tfun #3}
\newcommand{\envplus}[1]{, #1}
\newcommand{\reduction}[4]{#1 \operatorname{|} #2 \reduces #3 \operatorname{|} #4}

\newcommand{\col}{\!:\!}
\newcommand{\clos}[1]{\left<#1\right>}
\newcommand{\diffb}[1]{\colorbox{lightgray}{#1}}
\newcommand{\diff}[1]{\diffb{$#1$}}
\newcommand{\rdiffb}[1]{\fcolorbox{red}{lightgray}{#1}}
\newcommand{\rdiff}[1]{\rdiffb{$#1$}}
 
\makeatletter%
\begin{document}









\title[Type, Ability, and Effect Systems: Perspectives on Purity, Semantics, and Expressiveness]
{Type, Ability, and Effect Systems: Perspectives on \\Purity, Semantics, and Expressiveness}





\author{Yuyan Bao}
\orcid{0000-0002-3832-3134}             %
\affiliation{
  \institution{Augusta University}            %
  \city{Augusta}
  \state{GA}
  \country{USA}                    %
}
\email{yubao@augusta.edu}          %

\author{Tiark Rompf}
\orcid{0000-0002-2068-3238}             %
\affiliation{
  \institution{Purdue University}            %
  \city{West Lafayette}
  \state{IN}
  \country{USA}                    %
}
\email{tiark@purdue.edu}          %



\begin{abstract}
Programming benefits from a clear separation between
pure, mathematical computation and impure, effectful interaction
with the world. Existing approaches to enforce this separation
include monads, type-and-effect systems, and capability systems.
All share a tension between precision and usability, and
each one has non-obvious strengths and weaknesses.

This paper aims to raise the bar in assessing such systems. %
First, we propose a semantic definition of purity,
inspired by contextual equivalence, as a baseline 
independent of any specific typing discipline.
Second, we propose that expressiveness should be measured by
the degree of completeness, i.e., how many semantically pure terms 
can be typed as pure. 
Using this measure, we focus on minimal meaningful effect and 
capability systems and show that they are incomparable, i.e., 
neither subsumes the other in terms of expressiveness.

Based on this result, we
propose a synthesis and show that \emph{type, ability, and effect systems}
combine their respective strengths while
avoiding their weaknesses.
As part of our formal model, we provide a logical relation 
to facilitate proofs of purity and other
properties for a variety of effect typing disciplines.
 \end{abstract}



\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011006.10011039.10011311</concept_id>
       <concept_desc>Software and its engineering~Semantics</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
       <concept_desc>Software and its engineering~Functional languages</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011008</concept_id>
       <concept_desc>Software and its engineering~General programming languages</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Software and its engineering~Semantics}
\ccsdesc[500]{Software and its engineering~Functional languages}
\ccsdesc[500]{Software and its engineering~General programming languages}




\maketitle

\lstMakeShortInline[keywordstyle=,%
                    flexiblecolumns=false,%
                    language=PolyRT,
                    basewidth={0.56em, 0.52em},%
                    mathescape=true,%
                    basicstyle=\footnotesize\ttfamily]@

\section{Introduction}\label{sec:intro}


Computer programs bridge two worlds: the ``pure'' world
of mathematical computation and the ``impure'' world
of stateful physical reality.
Some programs are dominantly computational in nature,
with the goal of producing a discrete result upon
termination. The nature of other programs is dominantly
interactive, with the goal of observing and affecting 
state changes in the real world, be it to control
machinery or to interact with users.\footnote{
	While the term ``microcomputer'' has fallen out of fashion,
	the term ``microcontroller'' remains in active use.
}
Many programs combine both aspects, and ultimately,
all programs \footnote{
	Not all programs are ``run'': some are only written
	to illustrate an idea, or to serve as a Curry-Howard proof witness.
} 
are executed on stateful physical hardware.
This creates tensions.

\bfparagraph{Maximizing Mathematical Reasoning}




From the perspective of computation,
we often wish to view program terms as mathematical formulas.
The essence of a term behaving in a ``mathematical'' way is
that we can reason about it equationally rather than
operationally, using intuitive techniques from middle-school 
algebra. These rest on the 
principles of extensionality and compositionality: 
it should be possible to
identify a term with the result it computes, 
treating terms with indistinguishable results as equivalent,
and to replace a subterm with an equivalent one without 
changing the overall result. 
This form of reasoning crucially depends on a term having 
a single, fixed result, which does not change depending on 
when or how often the term is evaluated. 
In other words, we want to view a program term as a 
mathematical function of its free variables,
consistently producing equivalent outputs on equivalent 
inputs. We can only meaningfully say that $2+3=5$ 
because $2+x$ depends only on the value of $x$ but does 
not depend, \eg, on the phase of the moon. 


\bfparagraph{Stateful Physical Reality}

But in the real world, programs often behave ``unmathematically'',
for two different reasons.
The first reason is intentional: often the very purpose of a program
is control, more than computation, \eg, to drive machinery based
on sensor inputs, or to perform tasks based on user interaction.
Observing or affecting a state change in the
physical world is the primary purpose. 
The second reason is accidental: 
even purely computational parts of a program are ultimately executed 
as a stream of machine instructions 
on a stateful microprocessor, which presents the abstraction of ``bits'' 
changing states in ``memory'' on top of some electrical circuitry.
The tower of abstractions on top of the physical reality is colossal,
spanning not only superscalar processors with out-of-order execution, 
but also virtual machines and optimizing compilers, 
various storage technologies, %
not to mention unreliable network connections to data centers on 
the other side of the planet.

It takes great care to orchestrate this stack in a way that preserves any 
mathematical illusion. At any level of granularity, a component may present
a pure external interface based on an internal stateful implementation.
Thus, what is pure or impure, and external or internal, always depends 
on \emph{which aspects one is able to observe}.


\bfparagraph{Monads, Effects, Capabilities}


Given the desire to maximize mathematical reasoning and the potential
consequences of accidental impurity where purity is assumed,
programming languages have long sought to enforce purity in parts 
of a program, and to isolate pure from impure parts.



At the far end of the spectrum, proof assistants such as 
Coq, Agda, or Lean enforce total purity (including termination
for logical consistency) but sacrifice 
general-purpose programming. At the other end, languages 
like C embrace impurity and provide little support for reasoning.
Between these extremes, Monads~\cite{DBLP:journals/iandc/Moggi91,
DBLP:conf/popl/Wadler92}, as in Haskell, 
can either encode effects using pure code or isolate 
them at the boundary with the runtime (the IO Monad). 
Effect type systems~\cite{gifford1986integrating,DBLP:journals/iandc/TalpinJ94} 
instead enrich types with annotations that 
track the occurrence of impure operations. 
A more recent proposal is 
capability-based control of effects, though based
on earlier ideas~\cite{DBLP:journals/cacm/DennisH66,RobustComposition},
where a type system tracks the flow of values that
grant access to impure operations, without tracking
the occurrence of impure operations directly~\cite{osvald2016gentrification,
DBLP:journals/pacmpl/BrachthauserSO20,DBLP:conf/icfem/CraigPGA18,
DBLP:journals/toplas/BoruchGruszeckiOLLB23,
DBLP:conf/ecoop/Gordon19}.
\bfparagraph{Challenges and Limitations}

Like with any form of typing discipline, all these approaches 
suffer from a tension between precision and usability. 
Monadic encodings add an indirection compared to direct-style
code that can be awkward to deal with. Thus, for pragmatic
reasons, even Haskell supports nontermination and exceptions 
in the ``pure'' fragment of the language (a Haskell function 
of type $\mathbb{N} \to \mathbb{N}$ is not guaranteed to be a 
mathematical function on the natural numbers).
And while there is an abundance of sophisticated effect systems in 
the literature, very few are used outside of experimental 
settings. 
Those that do exist in widely used languages, such as 
checked exceptions in Java, 
are regarded by many as a failed experiment because the amount of
type parameters required %
seems to outweigh
the benefits of static checking~\cite{DBLP:conf/scala/OderskyBBLL21}.
Capabilities have shown great promise for enabling 
effect-polymorphic behavior~\cite{DBLP:conf/popl/LucassenG88} without explicit parameterization,
so there are high hopes that they may become a viable
solution for modeling effects in mainstream languages
\cite{osvald2016gentrification,DBLP:journals/pacmpl/BrachthauserSO20,
DBLP:journals/toplas/BoruchGruszeckiOLLB23}, but
there are also trade-offs to consider with respect
to effect systems, specifially when it comes to distinguishing
actually \emph{using} a capability to cause an effect from just
\emph{mentioning} a capability~\cite{DBLP:conf/ecoop/Gordon19},
\eg, to pass it somewhere else.




\subsection{Contributions}

How should we compare and evaluate such diverse typing disciplines?
While there are well-known results connecting monads and 
effects~\cite{DBLP:journals/tocl/WadlerT03,DBLP:conf/popl/Filinski10}, 
less is known about the relationships between different effect and capability systems. 
The key goal of this paper is to raise the level of rigor in this area and establish a framework for comparing such diverse typing disciplines. To achieve this, we must first establish a common semantic foundation. Rather than relying solely on syntactic criteria or language-specific features, we advocate for a semantic approach based on a contextual notion of purity, inspired by contextual equivalence. 

Using this framework, we can then compare the expressiveness of different typing disciplines by measuring their degree of completeness in characterizing semantically pure terms. This allows us to assess how well each system captures the intended notion of purity and to identify their respective strengths and weaknesses. We illustrate this approach by formalizing and comparing canonical binary effect and capability systems, demonstrating their incomparability in terms of expressiveness.
To address the identified weaknesses, we propose a synthesis of effect and capability systems that combines their respective strengths. This hybrid approach aims to leverage the advantages of both paradigms while mitigating their individual limitations.

To facilitate further research and practical reasoning about purity, we present a logical relation that enables formal proofs of purity across different typing disciplines. This relation is designed to be adaptable, supporting a variety of language features and type system designs.

\medskip\noindent
In summary, the main contributions of this paper are:
\begin{itemize}[left=2ex]
	\item A framework for measuring the expressiveness of effect typing disciplines based on their ability to characterize semantically pure terms as pure (\secref{sec:semantics}).
	\item A semantic definition of purity, independent of any particular type system, inspired by contextual equivalence (\secref{sec:purity}).
	\item Formalization and comparison of canonical binary effect and capability systems, demonstrating their incomparability with respect to expressiveness (\Cref{sec:effects,sec:ability}).
	\item A synthesis of effect and capability systems, combining their respective strengths to address identified weaknesses (\secref{sec:tae}).
	\item A general logical relation suitable for proving purity, applicable to a range of typing disciplines and language designs (\secref{sec:lr}).
\end{itemize}
We discuss related work in Section~\ref{sec:related}, and offer concluding
remarks in Section~\ref{sec:conc}. Mechanized proofs and accompanying
developments are available online.\footnote{\url{https://github.com/tiarkrompf/reachability}}








\section{Semantics of Effects and Purity}
\label{sec:semantics}

We begin by establishing some intuition behind our framework for reasoning about effects and purity in programming languages. This framework will allow us to compare different effect typing disciplines and their expressiveness.

\subsection{Expressiveness of Effect Typing Disciplines}
\label{sec:expressiveness}


While the term ``expressiveness'' is still frequently used informally, Felleisen's notion of macro-expressibility~\cite{DBLP:journals/scp/Felleisen91} provides a formal foundation for understanding the expressive power of programming languages. However, when it comes to type systems, the meaning of expressiveness is less well established.

One reasonable and, we believe, common interpretation is that a more expressive type system can type more programs, such as in the case of System F versus simply-typed  $\lambda$-calculus~\cite{samthExpressiveness11}. This of course assumes that we consider only type systems that are sound, as unsound type systems can trivially type all programs. Thus, expressiveness can be understood as the degree of completeness of a type system, \ie, the proportion of all semantically well-typed programs (in the sense of ``well-typed programs don't go wrong') that are well-typed syntactically.

But can we apply the same measure to effect typing disciplines? If we only consider the number of typable terms, the metric becomes trivial: since effects refine an existing type system, we could simply type all terms as impure. Clearly, this does not capture the essence of expressiveness for effect systems. The key realization, of course, is that for an effect systems to be sound, it should reflect stronger semantic properties than just ``well-typed programs don't go wrong''. These semantic properties depend on the specific effect system so they are hard to capture with any generality. More disturbingly, they are often not precisely defined, especially when effects are modeled purely syntactically: unlike with simple type systems, there is no notion of effects being preserved under reduction from terms to values, and there is no canonical equivalent to ``getting stuck'' for effect typing violations. Any attempt at artificially forcing stuckness in a reduction semantics is prone to overlooking some possible error cases, so we believe that a more semantic approach is 
indispensable for a rigorous treatment.

Irrespective of the precise semantic effect soundness properties of any specific effect system, we propose that any meaningful effect system should at least satisfy the property that syntactically pure terms are also semantically pure.
Thus, a natural way to measure the expressiveness of different effect systems is by asking: how many semantically pure terms can the system type as pure? This leads to the next question: what exactly does it mean for a term to be semantically pure?




\subsection{Intuitive Definitions of Purity}



Perhaps surprisingly, there does not seem to be a universally agreed-upon definition of what it means for a term to be pure. However, there are several common intuitions that we can build upon. We propose that the following three intuitions are equivalent and capture the essence of purity: 

\begin{enumerate}
\item\textbf{Pure terms are those that support mathematical reasoning.}
Perhaps more precisely, \emph{algebraic} reasoning and manipulation.

\item\textbf{Pure terms are mathematical functions of their free variables.}
This stresses the principles of extensionality and compositionality.

\item\textbf{Pure terms terminate, have deterministic results, and evaluate without effects.}
Effects include (1) primary effects, \ie, external state changes such as IO; 
(2) observable side effects, \ie, internal state changes that impact the result of evaluating any \textit{other term}.

\end{enumerate}


Among the possible effects of a term, externally observable effects, \eg, IO (file/network read and write), are the easiest to capture with a type system, hence we will mostly disregard them. The more interesting case is that of observable side effects, \ie, internal state changes that impact the result of evaluating other terms.
Figure~\ref{fig:intuitionExamples} shows examples of pure and impure terms,
including cases of effect polymorphism, effect masking, and use vs.\ mention
situations. 




\begin{figure}\small
\begin{mdframed}
$$\begin{array}{p{2cm}p{3cm}p{3cm}p{2cm}}
\textsc{(Abs:Any)} & 
$\tabs t$ & 
\text{Function value} & \text{Pure} \\
\textsc{(Diverge)} & 
$(\lambda x. \tapp x x)\ (\lambda x. \tapp x x)$ & 
\text{Nontermination} & \text{Impure} \\
\textsc{(Alloc)} &
$\tref t$ &
\text{Resource allocation} & \text{Impure} \\
\textsc{(Use:Read)} &
$\tget a$ &
\text{Resource use} & \text{Impure} \\
\textsc{(Use:Write)} &
$\tput a t$ &
\text{Resource use} & \text{Impure} \\
\textsc{(Mention)} &
$\tlet x a t$ &
\text{Resource mention} & \text{Pure iff $t$ pure} \\
\textsc{(Mask:Read)} &
$\tlet x {\tref t} {\tget x}$ &
\text{Masked resource use} & \text{Pure iff $t$ pure} \\
\textsc{(Mask:Write)} &
$\tlet x {\tref t} {\tput x t'}$ &
\text{Masked resource use} & \text{Pure iff $t,t'$ pure} \\
\end{array}$$
\end{mdframed}
\caption{Examples illustrating intuitively pure and impure terms
($a$ refers to a mutable reference).
}
\label{fig:intuitionExamples}
\vspace{-3ex}
\end{figure}


\begin{figure}\small
\begin{mdframed}
$$\begin{array}{p{2cm}p{3cm}p{3cm}p{2cm}}
\textsc{(Abs:Id)} & 
$\tabs x$ & 
\text{Pure function} & \text{Pure ability} \\
\textsc{(Abs:Diverge)} & 
$\tabs \omega$ & 
\text{Impure function} & \text{Impure ability} \\
\textsc{(Abs:Alloc)} & 
$\tabs {\tref x}$ & 
\text{Impure function} & \text{Impure ability} \\
\textsc{(Abs:Leak)} & 
$\tabs a$ & 
\text{Pure function} & \text{Impure ability} \\
\textsc{(Abs:Use)} & 
$\tabs {\tget a}$ & 
\text{Impure function} & \text{Impure ability} \\
\textsc{(Abs:UseArg)} & 
$\tabs {\tget x}$ & 
\text{Impure function} & \text{Pure ability} \\
\textsc{(Abs:Mention)} & 
$\tabs {\tlet x a \ttrue}$ & 
\text{Pure function} & \text{Pure ability} \\
\textsc{(Abs:Capture)} & 
$\tabs {\lambda y.\ {\tget a}}$ & 
\text{Pure function} & \text{Impure ability} \\
\textsc{(Abs:Poly)} & 
$\lambda f.\ \lambda x.\ {\tapp f x}$ & 
\text{Impure function} & \text{Pure ability} \\
\end{array}$$
\end{mdframed}
\caption{Examples illustrating intuitively pure and impure 
functions (which are all pure terms here, but could be
the result of an impure computation), and the concept 
of \emph{ability} or \emph{potential} of a value: namely, 
to be the source of impure behavior when put in a 
specific context. Values with impure ability are
what we intuitively understand as \emph{capabilities}.}
\label{fig:intuitionExamples2}
\vspace{-3ex}
\end{figure}




\subsection{Pure Functions, Pure Ability}


To state whether a function application is pure, we also need
the concept of a \emph{pure function}. We provide the following
intuitive definition, based on a function's extensional behavior:

\begin{definition}[Pure Function -- Informal]
A term $f$ is a pure function iff,
when $f$ is applied to an argument $t$, 
then the overall application term $\tapp f t$ is pure,
modulo any impurity caused by evaluating either $f$ or $t$ directly.
\end{definition}

Figure~\ref{fig:intuitionExamples2} shows examples of pure and 
impure functions.
To think about effects in terms of using capabilities, we
introduce the notion of a term's \emph{ability}
(following terminology introduced by \citet{DBLP:conf/popl/LindleyMM17}).
An impure function may still have pure ability
in the sense that it can't perform an effect on its own, but
it needs another object, a \emph{capability}, to cause this effect.

\begin{definition}[Pure-Ability Function -- Informal]
A term $f$ is a pure-ability function iff,
when $f$ is applied to a pure-ability argument $t$, 
then the overall application term $\tapp f t$ is pure
(modulo impurity caused by evaluating $f$ or $t$),
and the result is also a pure-ability value. 
In addition to pure-ability functions, primitives
also count as pure-ability values.
\end{definition}


Intensionally, ability describes whether a term's result has 
captured any effect-inducing capabilities, such as mutable references.
Extensionally, ability describes whether a term is part of 
the pure fragment of a language or not.
For example, $\tabs {\tget x}$ is not a pure function because it
dereferences its argument $x$, but we say it has pure ability
because the reference needs to be provided externally, it
has not been captured by the function.
On the other hand, $\lambda f.\ \tabs {\tapp f x}$ is not a pure 
function because when applied to the argument $\tabs {\tget a}$,
a pure term, the application is impure. 
Likewise, a pure function may also have impure ability:
$\tabs {a}$ is a pure function, but it returns a 
reference it has captured. We thus say it has impure ability.
Finally, $\tabs {\tref x}$ is an impure function, and it
also has impure ability. It does not capture the ref it
returns, but it still returns a value capable of inducing
an effect elsewhere.


\section{A Semantic Definition of Purity}
\label{sec:purity}

In the following, we propose a semantic notion of purity that matches the intuition outlined above. The definition is so simple and straightforward that we are almost certainly not the first to operate with this definition in mind, at least informally. However, we have not found it spelled out explicitly in the literature.

\subsection{Formalizing A Notion of Observational Purity}

\subsubsection{Syntax and Semantics}
To ground this discussion, we fix some minimal requirements on the
program syntax and semantics.
We consider the syntax consisting of terms $t$, values $v$, and states $\sigma$, along with 
value environments $H$, which map variables to values. 
$$
\ba{rcll}
b &:=& \ttrue\ \mid\ \tfalse\ \mid\ ... & \text{Constants} \\
t &:=& b\ \mid\ \tvar x\ \mid\ \tlet x t t\ \mid\ ... \qquad & \text{Terms} \\
v &:=& b\ \mid\ ... & \text{Values} \\
\sigma &:=& ... & \text{State} \\
H &:=& \varnothing \mid H \extends (x, v)  & \text{Value Environments} \\
\ea
$$
We intentionally leave the precise structure of terms, values, and state underspecified at this stage. 
However, we do assume that the term language supports sequencing via let-bindings.
Note here the connection with Moggi's computational $\lambda$-calculus~\cite{DBLP:journals/iandc/Moggi91}, 
which introduced monads as a model of effectful computation. 
Among the set of values, we assume a distinguished subset of atomic primitives (\eg, integers and booleans), 
which serve as effect-free observables.

The operational semantics defines evaluation as a relation of the 
form:
$$\config{H}{\sigma}{t} \eval \pconfig{\sigma'}{v}$$ 
This means that the evaluation 
of term $t$ with value environment $H$ and pre-state $\sigma$ 
terminates with result value $v$ and post-state $\sigma'$.
We assume that the evaluation relation itself is deterministic, i.e., 
there exists no more than a single $v$ and $\sigma'$ for any given $t$, $H$, and $\sigma$.
If evaluation is undefined in the case of an error or divergence, and 
thus no $v$ and $\sigma'$ exists for a given $t$, $H$, and $\sigma$, we also write:
$$\config{H}{\sigma}{t} \Uparrow$$

Constants evaluate to themselves, and the evaluation of $\texttt{let}$
expressions is strict. This is important to guarantee proper sequencing.
Later, we will formally extend the language with $\lambda$-abstractions 
and mutable references (see \secref{sec:concreteSemantics}). Extensions with IO, exceptions, etc., are also
possible, but we prefer to keep our core definitions independent of 
any such specific features.

In the following, we will largely keep the environment $H$ and 
state $\sigma$ implicit. So when clear from the context, we will
just write ${t} \Uparrow$ and ${t} \Downarrow v$ to mean that
$t$ evaluates in its associated $H$ and $\sigma$.


\subsubsection{Observational Equivalence}

Our notion of \emph{observational} (or \emph{behavioral}) purity is inspired crucially by the notion of observational (or behavioral) \emph{equivalence}, typically attributed to Morris' 1969 PhD thesis (there called \emph{extensional equivalence})~\cite{morris1968lambda}. 
This turned out to be a key milestone in the ability to reason about programs equationally, 
as the straightforward identification of terms that evaluate to \emph{identical} values is too restrictive.
One could consider equivalence of result values modulo some conversion rules, such as those defined in Morris' thesis~\cite{morris1968lambda}.
However, in a programming language with references, two allocation terms, \eg, $\tref 0$ and $\tref 0$ can never be reduced to the same store location
due to the nondeterminism of store allocation in most semantic models.

Instead, one sets up a weaker form of auxiliary equivalence first
that only considers termination behavior and atomic result values
such as integers and Booleans\footnote{There are different names for this auxiliary equivalence in the literature. Often the requirement to agree on atomic result values is dropped (\ie, requiring just the same termination behavor) but we prefer to include this condition, as it is necessary for terminating languages.}
(for all the definitions below, we assume that evaluation takes place
in two equivalent pre-states $\sigma_1$ and $\sigma_2$, for a suitable notion of state equivalence).



\begin{definition}[Operational Equivalence]\label{def:opEquiv}
    Two terms $t_1$ and $t_2$ are operationally equivalent $t_1 \simeq t_2$ iff both have the same termination behavior and they agree on
    any atomic result values $b$:
\[
{t_1} \Uparrow\ \  \Leftrightarrow \ {t_2} \Uparrow \qquad \wedge \qquad 
{t_1} \Downarrow {b} \ \Leftrightarrow \   {t_2} \Downarrow {b}
\]
\end{definition}



Then, the key idea is to treat all those terms as equivalent for which the \emph{program itself} cannot observe any difference. So, no possible context should exist that would expose any difference in behavior:


\begin{definition}[Observational Equivalence] Two terms $t_1$ and $t_2$ are observationally equivalent $t_1 \cong t_2$ iff for all contexts $C$:
\[
C[t_1] \simeq C[t_2] 
\]
\end{definition}

\subsubsection{Observational Purity}

In analogy, we want to express that pure expressions are those that do nothing else (observably) than computing their results. So, no possible context should exist that would expose any difference in behavior between the term itself, possible evaluated an arbitrary numbers of times (including zero) by the context, and evaluating the term once outside the context and then reusing its result bound to a variable (with strict binding semantics):

\begin{definition}[Observational Purity]\label{def:opure} A term $t$ is observationally pure iff for all contexts $C$ and fresh variables $x$:
\[
\tlet {x} {t}{C[x]} \simeq C[t]
\]
\end{definition}

In a language that includes the call-by-value $\lambda$ calculus, the left-hand side $\tlet {x} {t}{C[x]}$ can be encoded as $\lambda$ application $\tapp {(\lambda x. C[x])} t$. This suggests a nice symmetric interpretation of pure terms as (a) invariant under $\eta$-expansion of any context $C$ into a $\lambda$ abstraction, and (b) invariant under $\beta$-reduction in any application position. 
The latter interpretation is consistent with Sabry's definition of purity~\cite{DBLP:journals/jfp/Sabry98}, modulo
our additional requirement for termination.



In terms of terminology, we consider a term observationally impure if it is not observationally pure. When clear from the context, we will drop the ``observationally''.







\subsection{Discussion}
\label{sec:concreteSemantics}

\begin{figure}[t]\small
    \begin{mdframed}
    \typicallabel{T-False-E}
    \judgement{Syntax}{$\BOX{t ::= ...}$}\\
    \begin{minipage}[t]{\linewidth}
        \[\begin{array}{l@{\quad}l@{\quad}l@{\quad}l}
                b       & :=  & \ttrue \mid \tfalse                                                           & \text{Constants}       \\
                t       & ::= & b \mid x \mid \tabs{t} \mid \tapp{t_1}{t_2} \mid \tref{t} \mid\ \tget{t}  \mid \tput{t_1}{t_2} \mid \tseqb{t_1}{t_2}  & \text{Terms}         \\
                \otimes  & ::= & \vee \mid \wedge                                                                         & \text{Boolean Operator} \\
                v       & ::= & b \mid \ell \mid \cll{H}{\tabs{t}}                      & \text{Values}              \\
                H       & ::= & \varnothing \mid H \extends (x, v)                                                           & \text{Value Environment}   \\
                \sigma  & :=  & \varnothing \mid \sigma \extends (\ell, v)                                                             & \text{Store} \\
            \end{array}\]\\
        \end{minipage}%
    \vspace{-3ex}\\
    \judgement{Operational Semantics}{$\BOX{\config{H}{\sigma}{t} \eval \pconfig{\sigma'}{v}}$}\vspace{-3ex}
    \begin{multicols}{2}
    
        \infax[e-cst]{
            \config{H}{\sigma}{b} \, \eval \, \pconfig{\sigma}{b}
        }

        \infrule[e-bin]
        {\config{H}{\sigma}{t_1} \, \eval \, \pconfig{\sigma'}{b_1} \\
            \config{H}{\sigma'}{t_2} \, \eval \, \pconfig{\sigma''}{b_2}}
        {\config{H}{\sigma}{\tseqb{t_1}{t_2}} \, \eval \, \pconfig{\sigma''}{b_1 \synbracket{\otimes} b_2}}

       
        \infrule[e-ref]{
            \config{H}{\sigma}{t} \, \eval \, \pconfig{\sigma'}{v}  \\  \ell \not\in \DOM(\sigma')
        }{
            \config{H}{\sigma}{\tref{t}}\, \eval \, \pconfig{\sigma'\extends(\ell, v)}{\ell}
        }
 
        \infrule[e-get]{
            \config{H}{\sigma}{t} \, \eval \, \pconfig{\sigma'}{\ell}  \quad \sigma'(\ell) = v
        }{
            \config{H}{\sigma}{\tget{t}} \, \eval \, \pconfig{\sigma'}{v}
        }


        \columnbreak
       
        \infrule[e-var]{
            H(x)  =  v
        }{
            \config{H}{\sigma}{x} \, \eval \, \pconfig{\sigma}{v}
        }

        \infax[e-abs]{
            \config{H}{\sigma}{\tabs{t}} \, \eval \, \pconfig{\sigma}{\cll{H}{\tabs{t}}}
        }   
        
         \infrule[e-app]{
            \config{H}{\sigma}{t_1} \, \eval \, \pconfig{\sigma'} {\cll{H'}{\tabs{t}}}\\
            \config{H}{\sigma'}{t_2} \, \eval \, \pconfig{\sigma''}{v} \\
            \config{H' \extends(x, v)}{\sigma''}{t} \, \eval \, \pconfig{\sigma'''}{v}
        }{
            \config{H}{\sigma}{\tapp{t_1}{t_2}} \, \eval \, \pconfig{\sigma'''}{v}
        }


        \infrule[e-put]{
        \config{H}{\sigma}{t_1} \, \eval \, \pconfig{\sigma'}{\ell} \\  \config{H}{\sigma'}{t_2} \eval \pconfig{\sigma''}{v}
        }{
        \config{H}{\sigma}{\tput{t_1}{t_2}} \, \eval \, \pconfig{\sigma''[\ell \mapsto v]}{\ttrue}
        }   

 
    \end{multicols}

    \end{mdframed}
    
    \caption{Syntax and Semantics.}
    \label{fig:syntax}
    \vspace{-3ex}
\end{figure}
     
We now fix a concrete language, 
with which we examine our definition of purity with a few examples.
\figref{fig:syntax} defines the language syntax and semantics, 
which extends STLC with mutable references and Boolean expressions. 
The definition is standard, and can be found in the textbook~\cite{DBLP:books/daglib/0005958}.
We use a big step semantics with a value environment $H$ and a store $\sigma$,
where 
$\sigma$ is a partial function that maps from locations to values.
As before, we write $\config{H}{\sigma}{t} \eval \pconfig{\sigma'}{v}$ to mean that 
term $t$ evaluates to value $v$, resulting in a store transition from $\sigma$ to $\sigma'$.
In the semantics, we write $\synbracket{\otimes}$ to denote the interpretation of 
a syntactic Boolean operator as its corresponding meta-level operator.
Other definitions of the semantics are standard.

Following~\cite{Jeremy,DBLP:conf/popl/ErnstOC06,DBLP:conf/popl/AminR17,DBLP:conf/ecoop/WangR17}, 
we extend the big-step semantics $\eval$ to a total evaluation function by adding a numeric fuel value and explicit \text{timeout} and \text{Error} results. 
This semantic definition leads to strong soundness results in \secref{sec:lr}.



\bfparagraph{Nontermination}

A nonterminating expression is \emph{impure}, as expected. 
Consider an example: $\omega = (\lambda x. \tapp x x)\ (\lambda x. \tapp x x)$. 
The constant context $C[.] = \ttrue$ distinguishes between the term and its result bound to a variable: $\tlet x \omega \ttrue$ diverges, but $C[\omega] = \ttrue$ does not.
With a level of abstraction, however, we obtain a \emph{pure} expression: $\tabs \omega$ behaves the same in all contexts for both $\tlet x {\tabs \omega} C[x]$ and $C[\tabs \omega]$. 
However, this expression is not a \emph{pure function}, because there are impure applications, and in fact any application will be impure (e.g., $\tapp \omega \ttrue$).
Thus, it is also not a \emph{pure-ability function}.

\bfparagraph{Resource Allocation}

An allocation is \emph{impure}.
Consider the expression $\tlet x {\tref t} C[x]$. 
This means that only a single location is allocated and then reused through the variable $x$; 
whereas $C[\tref t]$ means that potentially many locations (or none) are allocated. 
It is easy to craft a context to observe this difference.
For example, $\tlet x {\tref 0} \tput{x}{{\tget x}+1}; \tget{x}$ yields value 1, 
reflecting the single reference being updated.
In contrast, $\tput{(\tref 0)}{{\tget {(\tref 0)}} + 1}; \tget(\tref 0)$ repeatedly allocates fresh locations and thus yields value 0.


\bfparagraph{Resource Mentioning and Usage}
Merely referencing a variable bound in the environment is pure, but dereferencing it is not.
Consider the expression $\tlet x a C[x]$, where $a$ is a mutable reference in the environment.
Since both $x$ and $a$ are variables, $\tlet x a C[x]$ and $C[a]$ must behave the same. However, if we consider $\tlet x {\tget a} C[x]$, then the two expressions may behave differently. Thus, we achieve a proper distinction between \emph{mentioning} a resource and \emph{using} it. This distinction also extends to from pure terms to pure functions. 



\bfparagraph{Effect Masking}
The expression $\tlet x {\tref t} {\tget x}$ is \emph{pure}, 
despite the internal use of a mutable reference. 
It remains pure if we insert a ``proper'' side effect, such as a write operation on $x$,
\eg, $\tlet x {\tref t} \tput{x} {\tget x}$.
This demonstrates the strength of the notion of observational purity: if store changes or other side effects cannot be observed, it is as if they did not exist.

\section{Effect Type Systems ($\lambda_e$)}
\label{sec:effects}


\begin{figure}[t]\small
    \begin{mdframed}
    \typicallabel{T-False-E}
    \judgement{Type \& Effects}{$\BOX{\TE::=...}\ \BOX{e::=...}$} \\
  \[
    \begin{array}{l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l}
      \TE & ::= & \TBoolE \mid  \TRefE \mid \TFunE{\TE_1} {\TE_2} {e_2}  & & \textcolor{red}{e} & := & \textcolor{red}{\bfalse} \mid \textcolor{red}{\btrue}  & & \textcolor{red}{e \rhd e'} & := & \textcolor{red}{e \vee e'}  
    \end{array}
  \]  
    \judgement{Term Typing}{$\BOX{\hasTypeE \GE t \TE e}$}\vspace{-2ex}
    
    \begin{multicols}{2}
    
    \infax[T-Cst-E]{
      \hasTypeE \GE {b} \TBoolE \bfalse
    }
    
    \infrule[T-Bin-E]{
      \hasTypeE \GE {t_1} \TBoolE {e_1} \\
      \hasTypeE \GE {t_2} \TBoolE {e_2}
    }{
      \hasTypeE \GE {t_1 {\otimes} t_2} \TBoolE {e_1 \rhd e_2}
    }
    
    
    \infrule[T-Ref-E]{
      \hasTypeE \GE t \TBoolE e
    }{
      \hasTypeE \GE {\tref t} \TRefE \btrue
    }
    
    \infrule[T-Get-E]{
      \hasTypeE \GE t \TRefE e
    }{
      \hasTypeE \GE {\tget t} \TBoolE \btrue
    }
    
    \infrule[T-Put-E]{
      \hasTypeE \GE {t_1} \TRefE {e_1} \\
      \hasTypeE \GE {t_2} \TBoolE {e_2}
    }{
      \hasTypeE \GE {\tput {t_1} {t_2}} \TBoolE \btrueE
    }
    
    \columnbreak
    
    \infrule[T-Var-E]{
      \indexrTypeE \GE x \TE
    }{
      \hasTypeE \GE {\tvar x} \TE \bfalse
    }
    
    \infrule[T-Abs-E]{
      \hasTypeE {\GE, x : \TE_1} t {\TE_2} {e_2}
    }{
      \hasTypeE \GE {\tabs t} {(\TFunE {\TE_1} {\TE_2} {e_2})} \bfalse
    }
    
    \infrule[T-App-E]{
      \hasTypeE \GE {t_1} {(\TFunE {\TE_1} {\TE_2} {e_2})} {e_f} \\
      \hasTypeE \GE {t_2} {\TE_1} {e_1}
    }{
      \hasTypeE \GE {\tapp {t_1} {t_2}} {\TE_2} {e_f \rhd e_1 \rhd e_2}
    }
    
    \infrule[T-Sub-E]{
      \hasTypeE \GE t {\TE_1} {e_1} \andalso
      \subtypeTE{\TE_1}{\TE_2} \\ 
      \subtypeEE{e_1}{e_2}
    }{
      \hasTypeE \GE t {\TE_2} {e_2}
    }
    
    \end{multicols}
    
    \judgement{Subtyping}{$\BOX{\subtypeTE{\TE_1}{\TE_2}}\ \BOX{\subtypeEE{e_1}{e_2}}$}\vspace{-2ex}
    \begin{multicols}{2}
      \infax[S-Cst-E] { 
        \subtypeTE{\TBoolE}{\TBoolE}
      }

      \infax[S-Tref-E]{ 
        \subtypeTE{\TRefE}{\TRefE} 
      }

    
      \columnbreak

      \infrule[S-Abs-E]{
         \subtypeTE{\TE_3}{\TE_1} \andalso
         \subtypeTE{\TE_2}{\TE_4} \\
         \subtypeEE{e_1}{e_2} 
      }{
        \subtypeTE{\TFunE{\TE_1}{\TE_2}{e_1}}{\TFunE{\TE_3}{\TE_4}{e_2}}
      }
      
    \end{multicols}
    \begin{multicols}{3}
    \infax[S-E] {
      \subtypeEE{\bfalse}{\btrue}
    }

    \infax[S-$\bfalse$-E]{
      \subtypeEE{\bfalse}{\bfalse}
    }

    \infax[S-$\btrue$-E]{
      \subtypeEE{\btrue}{\btrue}
    }

    \end{multicols}
   
    
    \end{mdframed}
    
    \caption{Effect Type System $\lambda_e$.}
    \label{fig:has-type-e}
    \vspace{-3ex}
    \end{figure} 
We now consider our semantic notion of purity in the context of type systems that distinguish pure and impure terms. 
The classic approach to do so is via a type and effect system.
As basis, we consider a version of simply-typed $\lambda$ calculus with
first-order mutable references, restricted to hold Boolean values.

In \figref{fig:has-type-e}, we recap a canonical binary effect system, distinguishing pure ($\bfalseE$) and impure ($\btrueE$) expressions.
The effect ordering is defined as $\subtypeEE{\bfalseE}{\btrueE}$.
We use the operator $\rhd$ for flow-insensitive sequential effect composition, 
\ie, $e_1 \rhd e_2$ computes the least upper bound of the effects $e_1$ and $e_2$.


\subsection{Formalization}

The effect typing rules are shown in \figref{fig:has-type-e}.
The effect typing judgment is in the form of $\hasTypeE{\GE}{t}{\TE}{e}$, where $\textcolor{red}{e}$ is a binary effect.
It means that under the assumption $\GE$, the term $t$ has type $\TE$ and its evaluation may induce the observable effect $\EF{e}$. 
Function types carry an effect annotation $\textcolor{red}{e}$ for its latent effect.

Rules for mutable references (\textsc{T-Ref-E}, \textsc{T-Get-E} and \textsc{T-Put-E}) are impure expressions, 
each assigned the effect $\btrueE$.
Constant terms (\textsc{T-Cst-E}), variables (\textsc{T-Var-E}) and function abstractions (\textsc{T-Abs-E}) 
are pure, each assigned the effect $\bfalseE$.
For compound terms (\ie, \textsc{T-App-E} and \textsc{T-Bin-E}), the final effect is computed by 
composing the effects of their sub-terms.
Effect composition $\textcolor{red}{e_1 \rhd e_2}$ computes the least upper bound of $\textcolor{red}{e_1}$ and $\textcolor{red}{e_2}$.

The subtyping rules are standard. 
In particular, the rule for function types (\textsc{S-Abs-E}) demands contravariance in the argument type and covariance in the result type.

\subsection{Metatheory}
\begin{figure}[t]\small
\begin{mdframed}
    \judgement{Free Variables}{$\BOX{\FV(t)}$}
    \[
      \begin{array}{l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l}
         \FV(b) & = &  \emptyset && 
         \FV(x) & = & \{ x\} \\
         \FV(\tabs{t}) & = & \FV(t) \setminus \{ x \} && 
         \FV(\tapp{t_1}{t_2}) & = & \FV(t_1) \cup \FV(t_2) \\
         \FV(\tref{t}) & = & \FV(t) &&
         \FV(\tget{t}) & = & \FV(t) \\
         \FV(\tput{t_1}{t_2}) & = & \FV(t) \cup \FV(t_2) &&
         \FV(\tseqb{t_1}{t_2}) & = & \FV(t_1) \cup \FV(t_2)
      \end{array}    
    \]
\end{mdframed}    
\caption{Computing free variables of a given term (standard).} 
\label{fig:fv}   
\vspace{-3ex}
\end{figure} The core metatheoretic development is fairly standard. 
In this work, we define program equivalence in terms of contextual equivalence,
and establish it via binary logical relations (details in \secref{sec:lr}).
 
In particular, we say terms $t_1$ and $t_2$ are contextually equivalent, written as 
$\ctxEquivE{\GE}{t_1}{t_2}{\TE}{e}$, if they have the same observable behavior when placed in any program context $C$.
To achieve that, we use the semantic typing judgment, which is defined as 
$\semTypeE{\GE}{t_1}{t_2}{\TE}{e} \DEF \forall (\VE,\W) \in \VG{\GE\ \fv{t_1} \cup \fv{t_2}}, (\VE, \W, t_1, t_2) \in \ETE{\TE}{\textcolor{red}{e}}$,
where $\VE$ is a pair of related value environments, $\W$ is a world, 
$\VG{\GE\ \fv{t_1} \cup \fv{t_2}}$ is the logical interpretation of typing environment, 
and $\ETE{\TE}{e}$ is the value interpretation of terms, which entails semantic type soundness and termination.
We define $\fv{t}$ to compute the free variables of term $t$, which is standard, shown in \figref{fig:fv}. 
The detailed definitions and results will be presented in~\secref{sec:lr}.
The main results are summarized below.



\begin{theorem}[Fundamental Property] If $\hasTypeE{\GE}{t}{\TE}{e}$, 
  then  $\semTypeE{\GE}{t}{t}{\TE}{e}$.
\end{theorem}

The following theorem shows the soundness of our binary logical relations with respect to contextual equivalence.
\begin{theorem} [Contextual Equivalence]
  if $\hasTypeE{\GE}{t_1}{\TE}{e}$ and $\hasTypeE{\GE}{t_2}{\TE}{e}$, 
  then $\semTypeE{\GE}{t_1}{t_2}{\TE}{e}$ implies $\ctxEquivE{\GE}{t_1}{t_2}{\TE}{e}$.
\end{theorem}  

In the following theorem, 
we write $C: (\GE; \TE\ \EF{e}) \carrow (\GEP; \TEP\ \EF{e'})$ to 
mean that the context $C$ is a program of type 
$\TEP\ \EF{e'}$ (closed under $\GEP$) with a hole that can be filled 
with any program of type $\TE\ \EF{e}$ (closed under $\GE$). 
The typing rules for well-typed contexts can be found in~\secref{sec:lr}.

\begin{theorem}[Effect Safety of Effect Type System] A syntactically pure expression is semantically (observationally) pure:
\[
  \hasTypeE \GE t \TE \bfalse 
  \quad\Rightarrow\quad
  \forall C:(\GE; \TE\ \bfalseE) \carrow (\GEP; \TEP\ \EF{e}).\ \ctxEquivE{\GEP}{\tapp {(\tabs {C[x]})} t}{C[t]}{\TEP}{e}
\]
\end{theorem}

We demonstrate that pure terms have expected algebraic properties in mathematical formulas, \eg, they allow reordering of operand expressions.

\begin{theorem}[Reordering] Pure terms can be evaluated in any order, \ie, swapping arguments of commutative operations is legal:
\[
  \hasTypeE \GE {\tseqb{t_1}{t_2}} \TBoolE \bfalse
  \quad\Rightarrow\quad
  \semTypeE{\GE}{\tseqb{t_1}{t_2}}{\tseqb{t_2}{t_1}}{\TBoolE}{\bfalse}
\]
\end{theorem}


\subsection{Discussion}

\bfparagraph{Effects are Properties of Evaluating an Expression (Positive)}

Effects classify properties of computations rather than values.
The system is terminating, so we cannot type $\omega$. But with a slight extension to allow functions to call themselves recursively this becomes possible, and we can treat recursive calls as effectful. A more refined scheme could detect structurally recursive calls and treat them as pure. This, as one would expect, leads to $\omega$ being syntactically impure and $\tabs \omega$ syntactically pure.

To not complicate the presentation and formalism with multiple kinds of effects, we do not further consider nontermination in this paper -- we rather focus on store effects, and the exact same considerations can be made with $\tref \ttrue$ instead of $\omega$.


\bfparagraph{Possibility for Flow-Sensitive Reasoning (Positive)}
We can achieve flow-sensitive reasoning, \eg,
by considering an alternative system with a single global boolean state and two operations: 
\texttt{tic} and \texttt{toc}.
Each operation expects the state value to be set one way and change it to the other, 
or fail if it has the wrong value. 
Thus, legal sequences are \texttt{tic},\texttt{toc},\texttt{tic},... etc.

Such operational behavior can be modeled with a more specialized effect composition operation $e \rhd e'$, 
which captures the legal sequences. 
That is, both $\texttt{tic} \rhd \texttt{toc}$ and $\texttt{toc} \rhd \texttt{tic}$ are well-defined, 
but invalid compositions, \eg, $\texttt{tic} \rhd \texttt{tic}$, are undefined.


\bfparagraph{Allocations are Impure: Hence, they have Effects (Neutral, light negative)}


We discussed earlier that allocations are impure semantically, as they interact with the store, 
and yield nondeterministic store locations.
In our binary effect system, impurity is expressed via the effect annotation $\btrue$.
Thus, allocations are treated the same as read and write effects.

We could refine the effect hierarchy with a more fine-grained hierarchy, 
\ie, distinguishing read, write and allocation effects.
Fundamentally, the refinement still treats allocation as an effect, \ie, as a property of evaluting an expression.
However, from a semantic perspective, what we often want to characterize is not merely that an allocation occurred, 
but rather that \emph{the resulting value is a fresh  location}, 
\ie, a property of the result value with respect to the context, instead.
We will come back to this later.


\bfparagraph{Incompleteness, no Effect Masking (Negative)}

There are many terms that are semantically pure but cannot be assigned a syntactically pure type. 
By necessity, any approximation of nontermination cannot be precise. 
And we also do not obtain effect masking: since every allocation has to be effectful, 
an expression such as $\tlet x {\tref t} {\tget x}$ cannot be assigned a pure type syntactically.

Of course, if we are willing to enrich the effect lattice with extra information, 
it becomes possible to model effect masking and other features. 
Benton et al.'s work~\cite{DBLP:conf/popl/Benton0N14}, \eg, achieves this by considering effects relative to store regions, and masking out effects on regions that are no longer observable, \ie, are no longer referenced anywhere in the term or the environment.


\bfparagraph{No Effect Polymorphism (Negative)}



Our simple effect system shows its limitations in the presence of 
higher-order functions or 
objects in an object-oriented programming language, 
where every method is a higher-order function (parametric in the receiver).
Consider a function such as @map(f)@, 
whose effect depends on the effect of the function argument @f@.
Clearly, our binary effect system lacks the expressiveness to abstract over effects.
One natural extension is to adopt a polymorphic effect system~\cite{DBLP:conf/popl/LucassenG88, DBLP:journals/iandc/TalpinJ94},
introducing abstract effect parameters to our system.
However, such systems come at a much greater expense in complexity:
essentially every higher-order function needs additional effect parameters to abstract over the effect of the function arguments, 
leading to significant annotation overhead or code duplication~\cite{DBLP:journals/toplas/BoruchGruszeckiOLLB23}. 

The problem becomes even more pronounced in the presence of deeply higher-order 
or dynamically dispatched code. 
A function's effect must include all the effects of all functions it may transitively invoke,
preventing effect systems from practical adoption~\cite{DBLP:phd/ch/Rytz14,DBLP:journals/toplas/BoruchGruszeckiOLLB23}.



\section{Ability Type Systems ($\lambda_a$)}\label{sec:ability}

As an alternative to effect type systems, systems that track the flow of capabilities have received renewed interest in recent times. 
Rather than treating effects as a property of how a term evaluates, these systems track the flow of \emph{capabilities} or \emph{resources} (such as mutable references).

This, most importantly, has the promise of dealing more gracefully with effect polymorphism: capabilities can be passed down the callgraph through the environment without polluting the types of higher-order functions with additional quantifiers.

While a number of concrete type systems with these goals in mind have been proposed, 
\eg, the work of~\citet{DBLP:conf/ecoop/XhebrajB0R22} and~\citet{osvald2016gentrification}, Scala Capturing Types~\cite{DBLP:journals/toplas/BoruchGruszeckiOLLB23}, 
and Reachability Types~\cite{DBLP:journals/pacmpl/BaoWBJHR21,DBLP:journals/pacmpl/WeiBJBR24}. 
However, a fundamental study of their effect semantics has not been conducted.

In the following, we present and analyze a canonical binary ($\AB{a} := \bfalseA \mid \btrueA$) ``ability'' type system from our perspective of observational purity.


\subsection{Formalization}

\begin{figure}[t]\small
    \begin{mdframed}
    \typicallabel{T-False-A}
    \judgement{Types \& Ability}{$\BOX{\TA::=...}\ \BOX{\textcolor{blue}{a}::=...}$} \\
    \[
      \begin{array}{l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l}
        \TA & := & \TBoolA \mid \TRefA \mid \TFunA {\TA_1} {a_1} {\TA_2} {a_2} & & & \textcolor{blue}{a} & := & \bfalseA \mid \btrueA   
      \end{array}  
    \]
    \judgement{Term Typing}{$\BOX{\hasTypeA \GA t \TA a}$}
    
    \begin{multicols}{2}
    
    \infax[T-Cst-A]{
      \hasTypeA \GA {b} \TBoolA \bfalseA
    }
    
    \infrule[T-Bin-A]{
      \hasTypeA \GA {t_1} \TBoolA {a_1} \\
      \hasTypeA \GA {t_2} \TBoolA {a_2}
    }{
      \hasTypeA \GA {t_1 {\otimes} t_2} \TBoolA \bfalseA
    }
    
    \infrule[T-Ref-A]{
      \hasTypeA \GA t \TBoolA a
    }{
      \hasTypeA \GA {\tref t} \TRefA \btrueA
    }
    
    \infrule[T-Get-A]{
      \hasTypeA \GA t \TRefA a
    }{
      \hasTypeA \GA {\tget t} \TBoolA \bfalseA
    }
    
    \infrule[T-Put-A]{
      \hasTypeA \GA {t_1} \TRefA {a_1} \\
      \hasTypeA \GA {t_2} \TBoolA {a_2}
    }{
      \hasTypeA \GA {\tput {t_1} {t_2}} \TBoolA \bfalseA
    }
    
    \columnbreak
    
    \infrule[T-Var-A]{
      \indexrTypeA \GA x \TA \AB{a}
    }{
      \hasTypeA \GA {\tvar x} \TA a
    }
    
    \infrule[T-Abs-A]{
      \hasTypeA {\GA, x : \TA_1\ \AB{a_1}} t {\TA_2} {\AB{a_2}} \\
      \envCapA \GA {\fv t \setminus x} {a_f}
    }{
      \hasTypeA \GA {\tabs t} {(\TFunA {\TA_1} {a_1} {\TA_2} {a_2})} {a_f}
    }
    
    \infrule[T-App-A]{
      \hasTypeA \GA {t_1} {(\TFunA {\TA_1} {a_1} {\TA_2} {a_2})} {a_f} \\
      \hasTypeA \GA {t_2} {\TA_1} {a_1}
    }{
      \hasTypeA \GA {\tapp {t_1} {t_2}} {\TA_2} {a_2}
    }
    
    \infrule[T-Sub-A]{
      \hasTypeA \GA t {\TA_1} {a_1} \andalso
      \subtypeTA{\TA_1}{\TA_2} \\ 
      \subtypeAA{a_1}{a_2}
    }{
      \hasTypeA \GA t {\TA_2} {a_2}
    }
    
    \end{multicols}
    
    \judgement{Augmented Term Typing with Ambient Ability}{$\BOX{\hasTypePhiA \GA {a'} t \TA a}$}\vspace{-2ex}
    
    \infrule{
      \hasTypeA \GA t \TA a \andalso
      \envCapA \GA {\fv t} {a'}
    }{
      \hasTypePhiA \GA {a'} t \TA a
    }
    
    \vspace{-2ex}
    \judgement{Subtyping}{$\BOX{\subtypeTA{\TA_1}{\TA_2}}\ \BOX{\subtypeAA{a_1}{a_2}}$}\vspace{-2ex}
    \begin{multicols}{2}
       \infax[S-Cst-A]{
         \subtypeTA{\TBoolA}{\TBoolA}
       }

       \infax[S-Tref-A]{ 
        \subtypeTA{\TRefA}{\TRefA}
       }
       
   \end{multicols}

   \infrule[S-Abs-A]{
        \subtypeTA{\TA_3}{\TA_1} \andalso
        \subtypeTA{\TA_2}{\TA_4} \andalso
        \subtypeAA{a_3}{a_1} \andalso
        \subtypeAA{a_2}{a_4} 
     }{
        \subtypeTA{(\TFunA{\TA_1}{a_1}{\TA_2}{a_2})}{(\TFunA{\TA_3}{a_3}{\TA_4}{a_4})}
     }

     \begin{multicols}{3}
      \infax[S-A]{
        \subtypeAA{\bfalse}{\btrue}
       }

     \infax[S-$\bfalse$-A]{
      \subtypeAA{\bfalse}{\bfalse}
     }

     \infax[S-$\btrue$-A]{
      \subtypeAA{\btrue}{\btrue}
     }

     \end{multicols}
   
    \end{mdframed}
    
    
    \caption{Ability Type System $\lambda_a$. }
    \label{fig:has-type-a}
    \vspace{-3ex}
    \end{figure} 
The ability typing rules are shown in \figref{fig:has-type-a}.
The ability typing judgment is in the form of $\hasTypeA \GA t \TA a$, where $\AB{a}$ is a binary ability annotation.

\bfparagraph{Ability Qualifier}
The \emph{ability qualifier} $a$ in a type judgment $\hasTypeA \GA t \TA a$ describes 
if the result of evaluating term $t$ is a \emph{resource} -- 
that is, either a reference or a value that may transitively reach other resources. 
The typing rules ensure that resources are typed with ability qualifier $\btrueA$ wherever they flow.


\bfparagraph{Ambient Ability} 
The \emph{ambient ability} $a$ of a term $t$ is based on the set of resources from the environment needed to evaluate $t$. Specifically, it is an upper bound on the ability qualifiers of $t$'s free variables:
\[
  \envCapA \GA {\fv t} {a}
\]
\noindent The definition of computing free variables from a given term is standard, and can be found in \figref{fig:fv}.
In the typing rules, the key to tie these two notions together is in rule \textsc{(T-Abs-A)}: 
the hypothesis $\envCapA \GA {\fv t \setminus x} {a_f}$  computes the ability qualifer $a_f$ assigned to the function from the ambient ability of the body expression, \ie, the function becomes itself a resource if it captures any resources (ability qualifier $\ne \bfalseA$) from the environment. 

For economy of notation, we often use an augmented term typing judgment that includes the ambient ability $a'$ in the form of
$\hasTypePhiA \GA {a'} t \TA a$.

\bfparagraph{Syntactic Purity}

Which expressions are syntactically pure? Returning a resource is not per se impure, but returning a freshly allocated one is (because returning any freshly allocated value is impure), and since there is no distinction in the types, we have to treat any expression with type $\TA\ \btrueA$ as impure.

To determine potential uses of resources as part of evaluation, we have to consider the ambient ability through the free variables of an expression. An expression $t$ with ambient ability $\btrueA$, 
\ie, $\envCapTrueA \GA {\fv t}$, is also impure. 

Thus, pure expressions are characterized by the augmented typing $\hasTypePhiA \GA \bfalseA t \TA \bfalseA$.


\subsection{Metatheory}

Similar to $\lambda_e$, the core metatheory for $\lambda_a$ is also standard.
We define program equivalence in terms of contextual equivalence and establish it via the binary logical relations for $\lambda_a$ (details in \secref{sec:lr}).

In particular, we say terms $t_1$ and $t_2$ are contextually equivalent, written as 
$\ctxEquivA{\GA}{t_1}{t_2}{\TA}{a}$, if they have the same observable behavior when placed in any program context $C$.
To achieve that, we use the semantic typing judgment, which is defined as 
$\semTypeA{\GA}{t_1}{t_2}{\TA}{a} \DEF \forall (\VE,\W) \in \VG{\GA \ \fv{t_1} \cup \fv{t_2}}, (\VE, \W, t_1, t_2) \in \ETA{\TA}{a}$,
where $\VE$ is a pair of related value environments, $\W$ is a world, 
$\VG{\GA \ \fv{t_1} \cup \fv{t_2}}$ is the logical interpretation of typing environment, 
and $\ETA{\TA}{a}$ is the value interpretation of terms, which entails semantic  soundness and termination.
The detailed definitions and results will be presented in~\secref{sec:lr}.
The main results are summarized below.

\begin{theorem}[Fundamental Property] If $\hasTypeA{\GA}{t}{\TA}{a}$, 
  then  $\semTypeA{\GA}{t}{t}{\TA}{a}$.
\end{theorem}


The following theorem shows the soundness of our binary logical relations with respect to contextual equivalence.
\begin{theorem} [Contextual Equivalence]
  if $\hasTypeA{\GA}{t_1}{\TA}{a}$ and $\hasTypeA{\GA}{t_2}{\TA}{a}$, 
  then $\semTypeA{\GA}{t_1}{t_2}{\TA}{a}$ implies $\ctxEquivA{\GA}{t_1}{t_2}{\TA}{a}$.
\end{theorem} 


In the following theorem, 
we write $C: (\GA; \TA\ \AB{a}) \carrow (\GAP; \TAP\ \AB{a'})$ to 
mean that the context $C$ is a program of type 
$\TAP\ \AB{a'}$ (closed under $\GAP$) with a hole that can be filled 
with any program of type $\TAP\ \AB{a}$ (closed under $\GAP$). 
The typing rules for well-typed contexts can be found in~\secref{sec:lr}.

\begin{theorem}[Effect Safety of Ability Type System] A syntactically pure expression is semantically (observationally) pure:
\[
  \hasTypePhiA \GA \bfalseA t \TA \bfalseA 
  \quad\Rightarrow\quad
  \forall C:(\GA; \TA\ \bfalseA) \carrow (\GAP; \TAP\ \AB{a}).\ \ctxEquivA{\GAP}{\tapp {(\tabs {C[x]})} t}{C[t]}{\TAP}{a}
\]
\end{theorem}



We demonstrate that pure terms have expected algebraic properties in mathematical formulas, \eg, they allow reordering of operand expressions.

\begin{theorem}[Reordering] Pure terms can be evaluated in any order, \ie, swapping arguments of commutative operations is legal:
\[
  \hasTypePhiA \GA \bfalseA {{t_1} {\otimes} {t_2}} \TBoolA \bfalseA
  \quad\Rightarrow\quad
  \semTypeA{\GA}{\tseqb{t_1}{t_2}}{\tseqb{t_2}{t_1}}{\TBoolA}{\bfalseA}
\]
\end{theorem}


\subsection{Discussion}

\bfparagraph{No Use/Mention Distinction (Negative)}

We track the flow of resources, but not precisely when they are used. So typing-wise (in a suitable extension with recursive functions), the terms $\omega$ and $\tabs \omega$ are both resources and hence syntactically impure. 
This may seem like a weakness compared to effect systems, but it is also what enables seamless effect polymorphism.

\bfparagraph{Effect Polymorphism I (Positive)}


A notable advantage of capability-based systems is that 
they provide effect polymorphism without requiring explicit effect quantification. 
Consider the function @map(f)@ again. 
In our ability type system, the function argument @f@ implicitly allows only the effects permitted 
by the capabilities available to that argument at the call site. 
As a result, capability systems avoid the annotation burden and complexity typically associated with polymorphic effect systems. 



\bfparagraph{Effect Polymorphism II (Neutral)}

The preceding discussion concerns passing resources \emph{down} the call chain.
In contrast, passing resources \emph{up} the call chain presents different challenges.
As mentioned above, we cannot treat a function that may return a resource as pure (because it might return a fresh resource).
If we want to return any capability up the chain (even pre-existing), the expression must be treated as impure.




\bfparagraph{Effect Masking (Positive)}
The ability system $\lambda_a$ masks effects that cannot be observed outside of a given expression.
For example, the expression $\tlet x {\tref t} {\tget x}$ is syntactically pure in $\lambda_a$,
as it does not return a resource, and its ambient ability is $\bfalseA$.


\bfparagraph{Beyond Boolean Refs (Positive)}

We can generalize mutable references from $\TBoolA$ to other non-resource types (\eg, values of closed $\lambda$-terms),  
and still maintain termination and other properties of the system. 
This would be harder to achieve in an effect system.





\section{Type, Ability, and Effect Systems ($\lambda_{ae}$)}
\label{sec:tae}

We present $\lambda_{ae}$, which integrates ability and effects in a unified system. 
Then we show that $\lambda_{ae}$ can encode the effect system $\lambda_e$ and the ability system $\lambda_a$.
The meta-theory of $\lambda_{ae}$ will be presented in \secref{sec:lr} in the form of binary logical relations.

\subsection{Formalization}
\begin{figure}[t]\small
    \begin{mdframed}
    \typicallabel{T-False-A}
    \judgement{Types, Ability and Effects}{$\BOX{T::=...}\ \BOX{\textcolor{blue}{a}::=...}\ \BOX{\textcolor{red}{e}::=...}$} \\
    \[
      \begin{array}{l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l}
        T & := & \multicolumn{6}{l}{\!\!\!\TBoolA \mid \TRefA \mid \TFunAE {T_1} {a_1} {T_2} {a_2}{e}} \\
        \textcolor{blue}{a} & := & \avc{f}{s} & & 
        \textcolor{blue}{f},\textcolor{blue}{s} & := & \bfalseA \mid \btrueA & &
        \avbot & := & \av \bfalseA \bfalseA \\
        \textcolor{red}{e} & := & \bfalseE \mid \btrueE &&
        \textcolor{red}{e \rhd e'} & := & \textcolor{red}{e \vee e'} \\
      \end{array}  
    \]
    \judgement{Term Typing}{$\BOX{\hasTypeAEC \Gamma t T {a} e}$}\vspace{-3ex}
    
    \begin{multicols}{2}
    
    \infax[T-Cst-AE]{
      \hasTypeAEC\Gamma {b} \TBoolA \avbot \bfalseE
    }
    
    \infrule[T-Bin-AE]{
      \hasTypeAEC \Gamma {t_1} \TBoolA {a_1} {e_1} \\
      \hasTypeAEC \Gamma {t_2} \TBoolA {a_2} {e_2} 
    }{
      \hasTypeAEC \Gamma {t_1 {\otimes} t_2} \TBoolA \avbot {e_1 \rhd e_2}
    }
    
    \infrule[T-Ref-AE]{
      \hasTypeAEC \Gamma t \TBoolA {a} {e}
    }{
      \hasTypeAEC \Gamma {\tref t} \TRefA {\av \btrue \bfalse} {e}
    }
    
    \infrule[T-Get-AE]{
      \hasTypeAEC \Gamma t \TRefA {a} {e}
    }{
      \hasTypeAEC \Gamma {\tget t} \TBoolA \avbot {e \rhd a.s}
    }
    

    \infrule[T-Put-AE]{
      \hasTypeAEC \Gamma {t_1} \TRefA {a_1} {e_1}\\
      \hasTypeAEC \Gamma {t_2} \TBoolA {a_2} {e_2}
    }{
      \hasTypeAEC \Gamma {\tput {t_1} {t_2}} \TBoolA \avbot {e_1 \rhd e_2 \rhd {a_1.s}}
    }
    
    \columnbreak
    
    \infrule[T-Var-AE]{
      \indexrTypeA \Gamma x T \textcolor{blue}{a}
    }{
      \hasTypeAEC \Gamma {\tvar x} T {\avc \bfalse {(a.f \vee a.s)}} \bfalse
    }
    
    \infrule[T-Abs-AE]{
      \hasTypeAEC {\Gamma, x : T_1\ \textcolor{blue}{a_1}} t {T_2} {a_2} {e_2} \\
      \envCapA \Gamma {\fv t \setminus x} {a_f} \\
      \textcolor{blue}{a_f' = }\ \avc {\bfalse}{(a_f.f \vee a_f.s)\land (a_2.s \vee e_2)}
    }{
      \hasTypeAEC \Gamma {\tabs t} {(\TFunAE {T_1} {a_1} {T_2} {a_2} {e_2})} {a_f'} {\bfalse}
    }
    
    
    \infrule[T-Sub-AE]{
      \hasTypeAEC \Gamma t {T_1} {a_1} {e_1} \andalso
      \subtypeTA{T_1}{T_2} \\ 
      \subtypeAA{a_1}{a_2} \andalso
      \subtypeEE{e_1}{e_2}
    }{
      \hasTypeAEC \Gamma t {T_2} {a_2} {e_2}
    }
    
    \end{multicols}

    \infrule[T-App-AE]{
      \hasTypeAEC \Gamma {t_1} {(\TFunAE {T_1} {a_1} {T_2} {a_2} {e_2})} {a_f} {e_f} \andalso
      \hasTypeAEC \Gamma {t_2} {T_1} {a_1} {e_1} 
    }{
      \hasTypeAE \Gamma {\tapp {t_1} {t_2}} {T_2} 
        {\avc 
          {a_2.f \vee a_2.s \wedge (a_f.f \vee a_1.f)}
          {a_2.s \wedge (a_f.s \vee a_1.s)}}
        {\\ \ab{e_f}\ \ab{\vee}\ \ab{e_1}\ \ab{\vee}\ (\ab{e_2} \wedge (\AB{a_f.s} \vee \AB{a_1.s})) }
    }

    
    
      
     \end{mdframed}
    \caption{Ability and Effect Type System $\lambda_{ae}$. 
    We write $a.f$, and $a.s$ to refer to the fresh and stored components in ability qualifier $a$, respectively. 
    }
    \label{fig:has-type-ae}
    \vspace{-3ex}
    \end{figure} 
The typing rules are shown in \figref{fig:has-type-ae}.
The typing judgment is in the form of $\hasTypeAEC \Gamma t T a e$, where \textcolor{blue}{$a$} is 
an ability and \textcolor{red}{$e$} is an effect. 

Contrary to $\lambda_a$ presented in \secref{sec:ability}, ability qualifers $\textcolor{blue}{a}$ now are in the
form of $\textcolor{blue}{\av f s}$, denoting whether the underlying characterized locations may be
 \emph{fresh} or \emph{stored}.
These characterizations have the following meaning:
\begin{itemize}[noitemsep,leftmargin=*, wide]
\item \emph{Fresh} means whether an evaluation result may reach new locations allocated during execution.
   If the value may reach those locations, they must be tracked as they may be accessed by the evaluation context;
   in this case, the \emph{fresh} component is assigned $\btrueA$. 
   If no allocation occurs during evaluation, or 
   any freshly allocated locations are not reachable from the result (and thus unobservable), 
   the component is assigned $\bfalseA$, and these locations can be safely ignored by the reasoning.
   See formulas $\recdx{F1}$ and $\recdx{F2}$ in the definition of binary logical relations in \secref{sec:lr_def}.
\item \emph{Stored} means whether an evaluation result may reach some pre-existing locations. 
In this case, effects on those locations are externally observable, and thus must be tracked as effect qualifier.
\end{itemize}

Let $\ab{a=\avc{f} {s}}$ be an ability qualifier. 
From now on, when the context is clear,
we write $\ab{a.f}$ and $\ab{a.s}$ to refer to its fresh and components, respectively.

This mechanism is exemplified in rules \textsc{(T-Get-AE)} and \textsc{(T-Put-AE)}, 
where effects on fresh cells are ignored, while effects on stored cells are tracked.

The rule \textsc{(T-Var-AE)} assigns ability qualifier ${\textcolor{blue}{\av \bfalse {(f \vee s)}}}$,
since variables references are by definition to a pre-existing value, thus they cannot be fresh.
Freshness is reserved for allocations during evaluation of a term, but during
evaluation of a variable reference no allocation happens.

The function application rule \textsc{(T-App-AE)} ensures that if a function has
a latent effect $\textcolor{red}{e_2}$, then either the function itself or the argument carries capabilities. 
These are the only values the function has access to, thus any
locations it may touch as part of its effect must be reachable through those
values.

The function abstraction rule \textsc{(t-tbs-ae)} specifies that a function is treated as a resource only if 
its value carries either existing or fresh capabilities, and either has latent effect or returns a value that carries capabilities from the environment.


\begin{figure}[t]\small
    \begin{mdframed}
    \typicallabel{T-False-A}
    \judgement{Subtyping}{$\BOX{\subtypeTA{T}{T'}}\ \BOX{\subtypeAA{a}{a'}}$}
    \begin{multicols}{2}
       \infax[S-Cst-AE]{
         \subtypeTA{\TBoolA}{\TBoolA}
       }
       \columnbreak
      \infax[S-Tref-AE]{ 
       \subtypeTA{\TRefA}{\TRefA}
      }
    \end{multicols}%
    \infrule[S-Abs-AE]{
        \subtypeTA{T_3}{T_1} \andalso
        \subtypeTA{T_2}{T_4} \andalso
        \subtypeAA{a_3}{a_1} \andalso
        \subtypeAA{a_2}{a_4} \andalso
        \subtypeEE{e_1}{e_2}
     }{
        \subtypeAA{(\TFunAE{T_1}{a_1}{T_2}{a_2}{e_1})}{(\TFunAE{T_3}{a_3}{T_4}{a_4}{e_2})}
     }%

     \begin{multicols}{3}
        \infax[S-E-AE] {
          \subtypeEE{\bfalse}{\btrue}
        }
    
        \infax[S-E$\bfalse$-AE]{
          \subtypeEE{\bfalse}{\bfalse}
        }
    
        \infax[S-E$\btrue$-AE]{
          \subtypeEE{\btrue}{\btrue}
        }
    
     \end{multicols}%

    \begin{multicols}{3}
      \infax[S-A-AE]{
       \subtypeTA{\bfalseA}{\btrueA}
      }
      
    \infax[S-A$\bfalse$-AE]{
     \subtypeAA{\bfalseA}{\bfalseA}
    }

    \infax[S-A$\btrue$-AE]{
     \subtypeAA{\btrueA}{\btrueA}
    }
  \end{multicols}
  \infrule[S-Sub-AE]{
     \subtypeAA{f_1}{f_2} \andalso 
     \subtypeAA{a_1}{a_2} \
    }{
     \subtypeAA{\avc{f_1}{a_1}} {\av{f_2}{a_2}}
    }
  
    \end{mdframed}
    \caption{Ability and Effect Subtyping System $\lambda_{ae}$.} 
    \label{fig:sub-type-ae}
    \vspace{-3ex}
\end{figure} \figref{fig:sub-type-ae} shows the subtyping rules for $\lambda_{ae}$. 
The rule \textsc{s-sub-ae} defines the general sub-typing relation for ability qualifiers, 
where subtyping is applied componentwise to each of the qualifier's components.
For each component, the subtyping relations are defined by the rules \textsc{s-a-ae}, \textsc{s-a$\bfalse$-ae} and \textsc{s-a$\btrue$-ae}.
The rule for function types (\textsc{S-Abs-AE}) demand contravariance in the argument type and the effects, and covariance in the result type.

\bfparagraph{Syntactic Purity}

Which expressions are syntactically pure? In our $\lambda_{ae}$ system, 
a term assigned ability and effect qualifier $\textcolor{blue}{\av f s}$ $\btrueE$ is impure, as the effect qualifier $\btrueE$ means 
evaluating the term may induce observable effects.
In the case of a function application $\tapp{t_1}{t_2}$,  
if the reduction of $t_1$ yields a function value whose ambient ability is $\avbot$, 
then the effect of executing the function body may be refined to $\bfalseE$, 
despite the body carrying a latent effect $\btrueE$, as in rule \textsc{t-app-ae} of \figref{fig:has-type-ae} specifies.
A term assigned qualifier \textcolor{blue}{$\av \btrue s$} $\bfalseE$ is also impure.
The reason is that while evaluating the term does not induce observable effects on pre-existing store locations (\ie, $\bfalseE$), 
it yields a freshly allocated location, which may be observed by the execution context (\ie, $\btrueA$).
A term assigned qualifier \textcolor{blue}{$\av \bfalse \btrue$} $\bfalseE$ means that 
its evaluating result carries abilities, %
as the qualifier means that
evaluating the term does not yield freshly allocation locations (\ie, $\bfalseA$), or induces observable effects ($\bfalseE$),
but it is granted the ability to access pre-existing locations (\ie, $\btrueA$). 
The term is pure if its ambient ability is $\avbot$. 







\subsection{Encoding of Pure Effect and Pure Ability System}

\begin{figure}[t]\small
    \begin{mdframed}
        \typicallabel{TR-A-AE}
        \judgement{Type Encoding of $\lambda_e$}{$\BOX{\trTE{\TE}}$}\\
        \[
            \begin{array}{l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l}
            \trTE{\TBoolE} & = & \TBoolAE & & &
            \trTE{\TRefE} & = & \TRefAE \\ 
            \trTE{\TFunE{\TE_1}{\TE_2}{e}} & = & \multicolumn{6}{l}{\!\!\!\!\TFunAE{\trTE{\TE_1}}{{\av{\btrueA}{\btrueA}}}{\trTE{\TE_2}}{{\av{\btrueA}{\btrueA}}}{e}}
        \end{array}%
        \]
        \\
        \judgement{Type Encoding of $\lambda_a$}{$\BOX{\trTA{\TA}}$}\\
        \[
            \begin{array}{l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}l}
            \trTA{\TBoolA} & = & \TBoolAE & & &
            \trTA{\TRefA} & = & \TRefAE \\ 
            \trTA{\TFunA{\TA_1}{a_1}{\TA_2}{a_2}} & = & \multicolumn{6}{l}{\!\!\!\!\TFunAE{\trTA{\TA_1}}{{\av{a_1}{a_1}}}{\trTA{\TA_2}}{{\av{a_2}{a_2}}}{\btrueE}}
        \end{array}%
        \]
    \end{mdframed}   
    \caption{Type translation from $\lambda_e$ and  $\lambda_a$ to $\lambda_{ae}$ respectively.}
    \label{fig:tr} 
    \vspace{-3ex}
\end{figure} Now we show that $\lambda_{ae}$ can encode the effect system $\lambda_e$ and the ability system $\lambda_{a}$.

\figref{fig:tr} (top) shows the type encoding of $\lambda_e$.
The base types are encoded directly. 
For function types, as the argument and return types in $\lambda_e$ do not have any information about ability, 
the encoding conservatively assumes the $\btrueA$ for the fresh and stored components
in their translated types.

\figref{fig:tr} (bottom) shows the type encoding of $\lambda_a$.
The base types are encoded directly. 
For function types, we directly translate the ability qualifier for arguments and return values in $\lambda_a$ into the target type. 
As the capability system does not have information on effects, the encoding conservatively assumes the $\btrueE$.


We define $\trTE{\GE}$ and $\trTA{\GA}$ that translate the source typing environments, $\GE$ and $\GA$, 
to the target ones by mapping each type according to the transition rules defined in \figref{fig:tr}.

The following two lemmas show the encodings are sound, \ie, if a term is well-typed in the source system, 
then its translation is well-typed in the target system under the translated environments. 

\begin{theorem}
  If $\hasTypeE{\GE}{t}{\TE}{e}$
  then $\hasTypeAEC{\trTE{\GE}}{t}{\trTE{T}}{\av{\btrueA}{\btrueA}}{e}$.
  \end{theorem}



\begin{theorem}
If $\hasTypeA{\GA}{t}{\TA}{a}$
then $\hasTypeAEC{\trTA{\GA}}{t}{\trTA{T}}{\av{a}{a}}{\btrueE}$.
\end{theorem}



\subsection{Discussion}
\begin{figure}[t]\small
\begin{mdframed}
 \centering
 \begin{lstlisting}
 let y = true in                  // : Bool $\avbot$      in context [ y: Bool $\avbot$ ]   
 let a = new Ref(false) in        // : Ref $\av{\bfalseA}{\btrueA}$  in context [ a: Ref $\av{\btrueA}{\bfalseA}$, x: Bool $\avbot$ ]
 def id (x: Bool) = { x }         // : (Bool $\avbot$      =>$^{\bfalseE}$ Bool $\avbot$) $\avbot$  
 def idr (x: Ref) = { x }         // : (Ref $\av{\btrueA}{\bfalseA}$   =>$^{\bfalseE}$ Ref $\av{\bfalseA}{\btrueA}$) $\avbot$ 
 def alloc (x: Bool) = { ref x }  // : (Bool $\avbot$      =>$^{\bfalseE}$ Ref $\av{\btrueA}{\bfalseA}$) $\avbot$ 
 def leak: (x: Bool) = { a }      // : (Bool $\avbot$      =>$^{\bfalseE}$ Ref $\av{\bfalseA}{\btrueA}$) $\av{\bfalseA}{\btrueA}$ 
 def use (x: Ref) = { !a }        // : (Ref $\av{\btrueA}{\bfalseA}$    =>$^{\btrueE}$ Bool $\avbot$) $\av{\bfalseA}{\btrueA}$ 
 def usearg (x: Ref) = { !x }     // : (Ref $\av{\bfalseA}{\btrueA}$       =>$^{\btrueE}$ Bool $\avbot$) $\avbot$ 
 def mention (x: Ref) = { true }  // : (Ref $\av{\bfalseA}{\btrueA}$  =>$^{\bfalseE}$ Bool $\avbot$) $\avbot$ 
 def capture (x: Ref) = { $\lambda$ y:Ref. !a } 
                                  // : (Ref $\av{\btrueA}{\bfalseA}$  =>$^{\bfalseE}$ ((Ref $\av{\btrueA}{\bfalseA}$  =>$^{\btrueE}$ Bool $\avbot$) $\av{\bfalseA}{\btrueA}$)) $\av{\bfalseA}{\btrueA}$  
 id(y)                            // : Bool $\avbot$ $\bfalseE$
 idr(a)                           // : Ref $\av{\bfalseA}{\btrueA}$ $\bfalseE$
 use(y)                           // : Bool $\avbot$ $\btrueE$
 usearg(a)                        // : Bool $\avbot$ $\btrueE$
 mention(a)                       // : Ref $\av{\bfalseA}{\btrueA}$ $\bfalseE$
 \end{lstlisting}    
\end{mdframed} 
\caption{Selected examples in \figref{fig:intuitionExamples2} that are annotated with abilities and effects.}
\label{fig:purity_with_types}
\vspace{-3ex}
\end{figure}    

\figref{fig:purity_with_types} shows selected examples in \figref{fig:intuitionExamples2} that are annotated with abilities and effects in $\lambda_{ae}$.
In the absence of type abstraction, we introduce two separate functions for the identity function: @id@ for Boolean arguments and @idr@ for Boolean reference arguments.
Invoking them, \ie, @id(y)@ and @idr(a)@ yields proper abilities and effects.
The function @alloc@ creates a new reference initialized with the given Boolean argument. 
The allocation does not induce observable effects, but the resulting reference carries an ability $\av{\bfalseA}{\btrueA}$,
meaning that the return value is fresh.
In contrast, the function @leak@ returns the reference captured from the environment, which is not fresh. Thus, its ability $\av{\btrueA}{\bfalseA}$.
The functions @use@ and @usearg@ induce effects on the captured reference from the environment and its argument respectively.
Thus, their effects are $\btrueE$.
Note that the ability of @use@'s argument can be $\avbot$, as the function itself does not use its argument.
However, @use(a)@ becomes untypable.
In contrast, the function @mention@ does not use its argument's ability or capture anything from the environment; 
hence, its effect is $\bfalseE$. 
In addition, the functions @leak@ and @use@ capture the ability carried by the reference @a@ from the environment, thus their abilities are $\av{\bfalseA}{\btrueA}$; 
others are just $\avbot$.





\section{Contextual Equivalence and Purity via Binary Logical Relations for $\lambda_{ae}$}\label{sec:lr}

In this section, we present the details of the earlier theorems,
which are proved using binary logical relations that show semantically equivalent values and terms are logically related. 

\subsection{Contextual Equivalence}
\begin{figure}[t]\small
    \begin{mdframed}
        \judgement{Context for Contextual Equivalence}{}
         \[\begin{array}{l@{\ \ }c@{\ \ }l@{\qquad\qquad\ }l@{\ \ }c@{\ \ }l}
				{C} & ::= & \square \mid \tapp{C}{t} \mid  \tapp{t}{C} \mid  \tabs{C} \mid \tref{C} \mid\ \tget{C} \mid \tput{C}{t} \mid \tput{t}{C} \mid \tseqb{t_1}{C} \mid \tseqb{C}{t_2} &  &  & \\
			\end{array}\]
            \judgement{Context Typing Rules}{
                \BOX{C : (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; T'\ \ab{a'}\ \ef{e'}\ \flt')}
            }
            
            \infax[c-$\square$]{
                \square: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma; T\ \ab{a}\ \ef{e}\ \flt)
            }

            \infrule[c-$\lambda$]{
               C: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow ((\G', x: T_1\ \ab{a_1}); T_2\ \ab{a_2}\ \ef{e_2}\ \flt') \andalso
               \envCapA{\Gamma'}{\flt' \setminus x}{a_f} \\
               \textcolor{blue}{a_f'} = \avc{\bfalse}{(a_f.s \vee a_f.f) \wedge (a_2.s \vee e_2)}
            }{
              \tabs{C}:(\Gamma; T\ \ab{a}\ \ef{e} \ \flt) \carrow {\Gamma'; (\TFunAE{T_1}{a_1}{T_2}{a_2}{e_2})\ \ab{a_f'}\ \bfalseE \ (\flt' \setminus x)}
            }

            \infrule[c-app-1]{
              C: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; (\TFunAE{T_1}{a_1}{T_2}{a_2}{e})\ \ab{a_f}\ \ef{e_f}\ \flt') \andalso
              \hasTypeAE{\Gamma'}{t}{T_1}{\ab{a_1}}{\ef{e_1}} 
            }{
              \tapp{C}{t}: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; T_2\ \\
               {\avc 
              {a_2.f \vee a_2.s \wedge (a_f.f \vee a_1.f)}
              {a_2.s \wedge (a_f.s \vee a_1.s)}}\
              \ef{e_f \rhd e_1 \rhd (e \wedge (a_f.s \vee a_1.s))}\ \flt')
            }

            \infrule[c-app-2]{
             \hasTypeAE{\Gamma'}{t}{\TFunAE{T_1}{a_1}{T_2}{a_2}{e}}{\ab{a_f}}{\ef{e_f}} \andalso 
             C: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; T_1\ \ab{a_1}\ \ef{e_1}\ \flt_1) 
            }{
              \tapp{t}{C}: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; T_2\ \\
               {\avc 
              {a_2.f \vee a_2.s \wedge (a_f.f \vee a_1.f)}
              {a_2.s \wedge (a_f.s \vee a_1.s)}}\
              \ef{e_f \rhd e_1 \rhd (e \wedge (a_f.s \vee a_1.s))}\ \fv{t})
            }


            \infrule[c-ref]{                 
               C: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TBoolA\ \ab{a'}\ \ef{e'}\ \flt')
            }{
              \tref{C}:(\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TRefA\ {\avc \btrue \bfalse}\ \ef{e'}\ \flt')   
            }

            \infrule[c-get]{
                C:(\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TRefA\ \ab{a'}\ \ef{e'}\ \flt')
            }{
                \tget{C}: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TBoolA; \avbot \ \ef{e' \rhd a'.s}\ \flt')
            }

            \infrule[c-put-1]{
               C: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TRefA\ \ab{a_1}\ \ef{e_1} \ \flt_1) \andalso 
               \hasTypeAE {\Gamma}{t}{\TBoolA}{\ab{a_2}}{\ef{e_2}}
            }{
                \tput{C}{t}: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TBoolA\ \avbot \ \ef{e_1 \rhd e_2 \rhd a_1.s}\ \flt_1)
            }

            \infrule[c-put-2]{
               \hasTypeAE {\Gamma}{t}{\TRefA}{\ab{a_1}}{\ef{e_1}} \andalso
               C: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TBoolA\ \ab{a_2}\ \ef{e_2}\ \flt_2) 
            }{
                \tput{t}{C}: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TBoolA\ \avbot \ \ef{e_1 \rhd e_2 \rhd a_1.s} \ \flt_2)
            }

           \infrule[c-bin-1]{
              \hasTypeAE{\Gamma}{t}{\TBoolA}{\ab{a_1}}{\ef{e_1}} \andalso
              C; (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TBoolA\ \ab{a_2}\ \ef{e_2}\ \flt_2)
            }{
             \tseqb{t}{C}: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TBoolA\ \avbot \ \ef{e_1 \rhd e_2} \ \flt_2)
            }

            \infrule[c-bin-2]{
                C; (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TBoolA\ \ab{a_1}\ \ef{e_1}\ \flt_1) \andalso
                \hasTypeAE{\Gamma}{t}{\TBoolA}{\ab{a_2}}{\ef{e_2}}
              }{
               \tseqb{C}{t}: (\Gamma; T\ \ab{a}\ \ef{e}\ \flt) \carrow (\Gamma'; \TBoolA\ \avbot \ \ef{e_1\rhd e_2}\ \flt_1)
              } 
            

    \end{mdframed}
    \caption{Selected Context Typing Rules.}
    \label{fig:context}
    \vspace{-3ex}
\end{figure}
 We write $\ctxEquivAE{\G} {t_1} {t_2} {T} {a} {e}$ to mean that 
programs $t_1$ and $t_2$ are \emph{contextually equivalent} at type $T\ \ab{a}\ \ef{e}$, 
meaning that they exhibit indistinguishable behavior in all program contexts $C$ with a hole of type $T\ \ab{a}\ \ef{e}$.
That is to say if $C[t_1]$ exhibits some observable behavior, then so does $C[t_2]$.

Following the approach of \citet{logical-approach} and related prior work
\cite{DBLP:conf/popl/AhmedDR09,bao2025logrel}, we define
a judgement for logical equivalence using binary logical relations,
written as $\semTypeAE{\G} {t_1} {t_2} {T} {a} {e}$.

Differing from reduction contexts, contexts $C$ for reasoning about equivalence allow a ``hole'' to appear in any place.
We write $C: (\G; T\ \textcolor{blue}{a}\ \textcolor{red}{e}\ \flt) \carrow (\G'; T'\ \textcolor{blue}{a'} \textcolor{red}{e'} \ \flt')$ to 
mean that the context $C$ is a program of type 
$T'\ \textcolor{blue}{a'}\ \textcolor{red}{e'}\ \flt'$ (closed under $\G$) with a hole that can be filled 
with any program of type $T\ \textcolor{blue}{a}\ \textcolor{red}{e}\ \flt$ (closed under $\G$).
The type rules for well-typed contexts imply that if
$\hasTypeAEC{\G}{t}{T}{a}{e}$,
$\flt = \fv{t}$,
$\flt' = \fv{C[t]}$
and $C:  (\G; T\ \textcolor{blue}{a}\ \textcolor{red}{e}\ \flt)\carrow (\G'; T'\ \textcolor{blue}{a'}\ \textcolor{red}{e'}\ \flt')$ hold, 
then $\hasTypeAEC{\G'} {C[t]} {T'} {a'} {e'}$.
Selected typing rules for well-typed contexts can be found in \figref{fig:context}.

We adopt the standard definition of contextual equivalence~\cite{DBLP:conf/popl/AhmedDR09}, as follows:
\begin{definition}[Contextual Equivalence]\label{def:standard_equiv} Term $t_1$ is \emph{contextually equivalent} to $t_2$,
  written $\ctxEquivAE{\G}{t_1}{t_2}{T}{a}{e}$, 
  if $\hasTypeAEC{\G} {t_1} {T} {a} {e}$, and 
  $\hasTypeAEC{\G} {t_2} {T} {a} {e}$, and 
  $\flt = \fv{t}$, and 
 $\forall \, C: (\G; T\ \textcolor{blue}{a}\ \textcolor{red}{e}\ \flt) \carrow (\emptyset; \TBoolA\ \avbot\ \bfalseE\ \qempty). \
        C[t_1]\downarrow \ \Longleftrightarrow \ C[t_2] \downarrow$.
\end{definition}
\noindent We write $t\downarrow$ to mean term $t$ terminates, if
$\config{\emptyset}{\emptyset}{t} \, \eval \, \pconfig{\sigma}{v}$,
for some value $v$ and final store $\sigma$.
This standard definition characterizes partial program equivalence, where program termination serves as the observable behavior.
However, since we focus on a total fragment of the systems here, termination alone is insufficient as an observer for program equivalence.
We thus rely on a refined definition of contextual equivalence using
Boolean contexts. %
\begin{align*}
    \small
    \setlength{\abovedisplayskip}{0pt}
    \setlength{\belowdisplayskip}{0pt}
     & \forall \, C: (\G;  T\ \ab{a}\ \ef{e}\ \flt) \carrow ( \emptyset; \TBoolA\ \avbot\ \bfalseE\ \emptyset). \, \exists \ \sigma, \sigma', v. \,\config{\emptyset}{\emptyset}{C[t_1]}\, \eval \, \pconfig{v}{\sigma} \; \wedge\; \config{\emptyset}{\emptyset}{C[t_2]} \, \eval \, \pconfig{v}{\sigma'}.
\end{align*}
That is to say, we consider two terms contextually equivalent if they yield the same answer value in all Boolean contexts.

\subsection{The World Model}
\begin{figure}[t]\small
  \begin{mdframed}
  \judgement{Store Typing, Relational Worlds, Well-Defined Stores}{$\BOX{\lambda_{ae}}$}\vspace{-2ex}
  \begin{mathpar}
    \begin{array}{@{\hspace{-2ex}}r@{\hspace{1ex}}l@{\hspace{1ex}} l}
        \Sigma &:= &\qbot \mid \Sigma, \ell: \{ \ttrue, \tfalse \} \\

        \stcp{\W}{\W'}{\lsv{1}}{\lsv{2}} & = & (\forall \, \ell_1 \in \lsv{1}, \ell_2 \in \lsv{2}. \, \W_f(\ell_1, \ell_2) \Rightarrow \W'_f(\ell_1, \ell_2)) \\ 
        \st{\sigma_1}{\sigma_2}{\W}{\lsv{1}}{\lsv{2}}  & \DEF & \sigma_1: \W_1 \, \land \, \sigma_2: \W_2 \, \land \, (\forall (\ell_1, \ell_2) \in \W. \, \ell_1 \in \lsv{1} \, \land \, \ell_2 \in \lsv{2} \, \Rightarrow  \, (\exists \, b.\, \sigma_1(\ell_1) = \sigma_2(\ell_2) = b )) \\
    \end{array}
\end{mathpar}    
\end{mdframed}
\caption{Definitions of store typing, relational words and well-defined stores with respect to a world.}
\label{fig:world}
\vspace{-3ex}
\end{figure} 
\begin{definition}[World]\label{def:world} A world $\W$ is a triple of $(\Sigma_1, \Sigma_2, f)$, where
    \begin{itemize}
        \item $\Sigma_1$ and $\Sigma_2$ are store typings defined in \figref{fig:world},

        \item $ f \subseteq (\DOM(\Sigma_1) \times \DOM(\Sigma_2))$ is a partial bijection.
    \end{itemize}
\end{definition}
A world defines relational stores.
The partial bijection captures the fact that a relation holds under permutation of store locations.

If $\W = (\Sigma_1, \Sigma_2, f)$ is a world, we refer to its components as follows: \vspace{-5pt}
\[\small
\begin{array}{@{}r@{\hspace{1ex}}l@{\hspace{1ex}} l}
    \W(\ell_1, \ell_2) & = & \begin{cases}
                                 (\ell_1, \ell_2) \in f & \ell_1 \in \DOM(\Sigma_1) \text{ and } \ell_2 \in \DOM(\Sigma_2) \text{ and when defined} \\
                                 \bot              & \text{otherwise}
                             \end{cases} 
\end{array}%
\]
We write $\DOM_1(\W)$ and $\DOM_2(\W)$ to refer the first and second components in the world $\W$, 
\ie, $\DOM_1(\W) = \DOM(\Sigma_1)$ and $\DOM_2(\W) = \DOM(\Sigma_2)$. 
Let $\W$ and $\W$ be two worlds. We write $\DOM(\W) \subseteq \DOM(\W')$ to mean 
$\DOM_1(\W) \subseteq \DOM_1(\W') \, \land \, \DOM_2(\W) \subseteq \DOM_2(\W')$.
We write $\W_f$ to mean the third component in the world $\W$.

If $\W$ and $\W'$ are worlds, such that
$
    \DOM_1(\W) \cap \DOM_1(\W') = \DOM_2(\W) \cap \DOM_2(\W') = \emptyset
$,
then $\W$ and $\W'$ are called disjoint, and we write $\W \extends \W'$ to mean extending $\W$ with a disjoint world $\W'$. 
Let $\sigma_1$ and $\sigma_2$ be two stores. 
We write $\st{\sigma_1}{\sigma_2}{\W}{L_1}{L_2}$ to mean the stores are well-defined with respect to the world $\W$ at a pair of locations $(L_1, L_2)$, 
which is formally defined in \figref{fig:world}.

\bfparagraph{Reachable Locations}
\begin{figure}[t]\small
    \begin{mdframed}[innertopmargin=2pt, innerbottommargin=3pt, leftmargin=2pt, rightmargin=2pt]
        \judgement{\textsf{\textbf{Reachable Locations}}\phantom{lifiers}}{\BOX{\lambda_{ae}}}\vspace{-1ex}\\
    $
      \begin{array}{l@{\ \,}c@{\ \,}l@{\qquad\qquad\qquad\qquad\ \ }r}
        \vallocs{b} = \qbot    \qquad
        \vallocs{\ell} = \{\ell\}   \qquad
        \vallocs{\cll{H}{\lambda x.t}} = \explocs{\lambda x.t}{H} \qquad
        \varslocs{q}{H} = \bigcup_{x \in q} L(H(x))
      \end{array}
    $
    \end{mdframed}
    \caption{Computing reachable locations from a given value.}
    \label{fig:reach}
    \vspace{-3ex}  
\end{figure} Following \citet{bao2025logrel}'s work,
the definition of logical relations needs to know the reachable locations from a given value $v$, 
which is computed by the function $\vallocs{v}$, as shown in \figref{fig:reach}.
Boolean values, $b$, reach the empty set of locations.
A location $\ell$ can only reach itself. 
Thus, its reachable set is the singleton set $\{ \ell \}$. 
The set of locations that are reachable from a function value $\tabs{t}$ 
are the set of the locations reachable from the values retrieved from its free variables in the value environment $H$,
\ie, $\explocs{\tabs{t}}{H}$.

\bfparagraph{Relational Worlds} 
Instead of using the standard definition of world extension,
we adapt the relational worlds from \citet{bao2025logrel}'s work, 
which leverages reachable locations to achieve a degree of localization.
In \figref{fig:world}, relational worlds,
written as $\stcp{\W}{\W'}{\lsv{1}}{\lsv{2}}$,
parameterize the definition of world extension with related reachable locations $\lsv{1}$ and $\lsv{2}$.
The definition is symmetric, allowing $\W'$ to be defined from $\W$, such that they agree on $\lsv{1}$ and $\lsv{2}$, 
leaving the remainder unspecified.
The standard definition of store typing extension $\W \sqsubseteq \W'$ can be defined as $\stcp{\W}{\W'}{\DOM_1(\W)}{\DOM_2(\W)}$.
The relational worlds are used in reasoning about functions. See detailed explanation in \secref{sec:valt}.


\subsection{Use vs Mention Aware Binary Logical Relations}\label{sec:lr_def}
We first introduce the interpretation of typing context, which establishes the assumption of the reasoning.
\begin{definition}[Semantic Typing Context]\label{def:sem_ctx} The definition of typing context interpretation is defined as follows:
\[
\begin{array}{@{\hspace{-2ex}}r@{\hspace{1ex}}l@{\hspace{1ex}} l}
       \VG{\G \ \flt\ u}  & = &  \{(\W, \VE, \R) \mid \DOM(\VE_i) =  \DOM(\R_i) = \DOM(\G) \, \wedge \\
                       &   &  ~~~~(\forall x, T, \ab{a}. \, \G (x) = T \ \ab{a} \Rightarrow\ \exists\ ux, L_1, L_2.\, ux = (\ab{\neg a} \vee u)\, \wedge\\
                       &   & \qquad\qquad\!\! (x \in \flt \Rightarrow (\W, \VE_1(x), \VE_2(x), ux, L_1, L_2) \in \VT{T}) \, \land \, \\
                       &   & \qquad\qquad\!\! ((\ab{\neg a} \vee u) \Rightarrow \R_1(x) = L_1 \wedge \R_2(x) = L_2)\ \wedge \\
                       &   & \qquad\qquad\!\! ((\ab{\neg a} \vee \neg u) \Rightarrow (L_1 = \emptyset \, \wedge \, L_2 = \emptyset)))\}. 
\end{array}
\]
\end{definition}
\noindent Semantic typing context is defined as a set of tuples of the form $(\W, \VE, \R)$, where $\W$ is a world defined in \defref{def:world}.
The component $\VE$ ranges over a pair of relational value environments that are finite maps from variables $x$ to pairs of values $(v_1, v_2)$.
If $\VE(x) = (v_1, v_2)$, then $\VE_1(x)$ denotes $v_1$ and $\VE_2(x)$ denotes $v_2$.
We write $\DOM(\VE_1)$ and $\DOM(\VE_2)$ to mean the domain of the first and second value environment respectively. 
The component $\R$ ranges over a pair of relational reachability environments 
that are finite maps from variables $x$ to pairs of locations $(L_1, L_2)$, which are reachable from their respectively referred values, \ie, $\VE_1(x)$ and $\VE_2(x)$.
The domains of $\R_1$ and $\R_2$ are defined similarly to those of $\VE$.


The reachability information defined in $\R$ 
are refined with respect to a reasoning mode, which allows reasoning to 
distinguish whether external resource is actually used or only mentioned in two pairs of terms, 
with respect to the effect qualifier. 
The reasoning mode is determined by 
the binary semantic typing judgement.

\begin{definition}[Semantic Typing Judgment]\label{def:sem_type} The semantic typing judgement is defined as:
\[
\begin{array}{@{\hspace{2ex}}r@{\hspace{1ex}}l@{\hspace{1ex}} l}
\semTypeAE{\G}{t_1}{t_2}{T}{a}{e} \DEF & \forall\, u. (\ef{e} \Rightarrow u) \Rightarrow \, (\forall\, \W, \VE, \R.  \\
 & (\W, \VE, \R)\in \VG{\G \ (\fv{t_1} \cup \fv{t_2})\ u}. \ (\W, \VE, t_1, t_2, u) \in \ETAE{T}{a}{e}).
\end{array}
\]
\end{definition}
\noindent 
In the above, the boolean parameter $u$ means that the current reasoning is in a use mode if it is \texttt{true}; 
otherwise it is in a mention mode, meaning that the current reasoning does not require the knowledge about any external resource.
Here, we write $\ef{e} \Rightarrow u$ to mean $\ef{e} = \btrueE \Rightarrow u = \texttt{true}$.
The condition dictates that the reasoning must be in a use mode (\ie, $u = \texttt{true}$) whenever the computation induces observable effects (\ie, $\ef{e = }\btrueE$).
\bfparagraph{Example} \figref{fig:purity_with_types} shows the examples annotated with abilities and effects. 
The programs @id(y)@ and @mention(a)@ can be reasoned in either mode, (\ie, $u = \texttt{true}$ or $u = \texttt{false}$),
as they don't have observable effects (\ie, $\ef{e = \bfalseE}$).
In contrast, the programs @use(y)@ and @usearg(a)@ can only be reasoned in the use mode (\ie, $u = \texttt{true}$), 
as they induce observable effect (\ie, $\ef{e = \btrueE}$), 
and require access to the reference @y@. However, the function @usearg@ can be reasoned in the mention mode by using \lemref{envt_strengthenW1} (shown below).

\bfparagraph{Properties} The following lemma allows reasoning about a sub-term in the mention mode, if the overall reasoning is in a use mode.
\begin{lemma}\label{envt_strengthenW1}
    If $(\W, \VE, \R) \in \VG{\G \ \flt \ u}$
    and $u'$ implies $u$,
    then $(\W, \VE, \R) \in \VG{\G \ \flt \ u'}$.
\end{lemma}

The following lemma allows the established equivalent terms in the mention mode to remain equivalent in the use mode,
provided they induce no observable effects and carry no abilities.
\begin{lemma}\label{exp_mentionable1}
    If $(\W, \VE, t_1, t_2, \texttt{false}) \in \ETAE{T}{a}{e}$, and 
    $e = \bfalseE$, and 
    $a = \avbot \vee u = \texttt{false}$,
    then $(\W, \VE, t_1, t_2, u) \in \ETAE{T}{a}{e}$.
\end{lemma}

\subsection{Value Interpretation of Types}\label{sec:valt}
\begin{figure*}[t] \small
    \begin{mdframed}%
 \judgement{Binary Value Interpretation of Types and Terms}{$\BOX{\lambda_{ae}}$} \vspace{-2ex} 
 \begin{mathpar}
    \begin{array}{@{\hspace{-2ex}}r@{\hspace{1ex}}l@{\hspace{1ex}} l}
        \stw{\sigma}{\sigma'}{L}  & = & \forall \ell \in \DOM(\sigma). \ \ell \not\in L \Rightarrow \sigma(\ell) = \sigma'(\ell)  \\
        \fr{\sigma'}{\sigma} & = & \DOM(\sigma') - \DOM(\sigma) \\
        \\
        \VT{\TBoolAE}  & = & \{(\W, b, b, u, \lsv{1}, \lsv{2}) \} \\ 
        \VT{\TRefAE} & = & \{(\W, \ell_1, \ell_2, u, \lsv{1}, \lsv{2}) \mid  u \Rightarrow (\W(\ell_1, \ell_2) \ \land \ \ell_1 \in \lsv{1} \, \land \, \ell_2 \in \lsv{2}) \}  \\   
        \\
        \VT{\TFunAE{T_1}{a_1}{T_2}{a_2}{e}} & = & \{(\W, \cll{H_1}{\tabs{t_1}}, \cll{H_2}{\tabs{t_2}}, u, \lsv{\lambda_1}, \lsv{\lambda_2}) \mid  \forall \sigma_1', \sigma_2', \W', \lsv{1}, \lsv{2}, v_1, v_2, \lsv{v_1}, \lsv{v_2}. \\[\medskipamount]
                            & & \;\; \forall\, ux, ubdy, ur. \, \NUM{L1}{((\ef{e} \vee ur \wedge \ab{a_2.s}) \Rightarrow  \stcp{\W}{\W'}{\lsv{\lambda_1}}{\lsv{\lambda_2}})} \, \land \, \\[\medskipamount]
                            & & \qquad ((\ef{e}  \vee ur \wedge \ab{a_2.s}) \Rightarrow (ux \wedge u)) \, \land  \, (\ef{e} \Rightarrow ubdy) \, \land \, (ur = \neg a_1.s \vee ubdy) \, \land \\[\medskipamount]
                            & & \qquad  (\ab{\neg a_1} \Rightarrow ux ) \, \land \, \DOM(\W) \subseteq \DOM(\W') \, \land \, \NUM{S1}{\st{\sigma_1'}{\sigma_2'}{\W'}{\lsv{1}}{\lsv{2}}} \, \land \, \\[\medskipamount]  
                            & & \qquad \NUM{R1}{(e = \Rightarrow \lsv{v_i} \cup \lsv{\lambda_i} \subseteq \lsv{i})} \, \land  \, \NUM{R2}{((\neg a_1 \vee \neg ux) \Rightarrow (\lsv{v_i} = \emptyset))} \, \land \\[\medskipamount]
                            & & \qquad (\W', v_1, v_2, ux, \lsv{v_1}, \lsv{v_2}) \in \VT{T_1} \, \Rightarrow \\[\medskipamount]
                            & & \qquad (\exists \sigma_1'', \sigma_2'', \W'', r_1, r_2, \lsv{r_1}, \lsv{r_2}. \, \W' \sqsubseteq \W'' \, \land \, 
                                 \config{H_1\extends(x, v_1)}{\sigma_1'}{t_1} \eval \pconfig{\sigma_1''}{r_1} \, \land \\[\medskipamount]
                            & & \qquad \qquad \config{H_2\extends(x, v_2)}{\sigma_2'}{t_2} \eval \pconfig{\sigma_2''}{r_2} \, \land \, \DOM(\sigma_i') \subseteq \DOM(\sigma_i'') \, \land \, \\[\medskipamount]
                            & & \qquad \qquad \NUM{S2}{\st{\sigma_1''}{\sigma_2''}{\W''}{\lsv{1} \cup \fr{\sigma_1''}{\sigma_1'}}{\lsv{2} \cup \fr{\sigma_2''}{\sigma_2'}}} \, \land \, (\neg ur \Rightarrow L_{r_i} = \emptyset) \, \land \\[\medskipamount]
                            & & \qquad \qquad (\W'', r_1, r_2, u_r, \lsv{r_1}, \lsv{r_2}) \in \VT{T_2} \, \land \, \\[\medskipamount]
                            & & \qquad \qquad \NUM{R3}{\lsv{r_i} \subseteq \emptyset \ccup{\ab{a_2.s}} (\lsv{v_i} \cup \lsv{\lambda_i}) \ccup{\ab{a_2.f}} \fr{\sigma_i''}{\sigma_i'}} \, \land \, \\[\medskipamount]
                            & & \qquad \qquad \NUM{E1}{\stw{\sigma_i'}{\sigma_i''}{\emptyset \ccup{\textcolor{red}{e}} (\lsv{\lambda_i} \cup \lsv{v_i})}} \, \land \, 
                                           \NUM{F1}{(\neg \ab{a_2.f} \Rightarrow \W''_f = \W'_f)})    
                            \}  \\
        \\
        \ETAE{T}{a}{e} & = & \{(\W, \VE, t_1, t_2, u) \| \forall \sigma_1, \sigma_2, \lsv{1}, \lsv{2}, \, \st{\sigma_1}{\sigma_2}{\W}{\lsv{1}}{\lsv{2}} \, \land \, \emptyset \ccup{\ef{e}} \explocs{t_i}{\VE_i} \subseteq \lsv{i} \, \land \, \\[\medskipamount]
                           &   & \;\; \exists \sigma_1', \sigma_2', \W', u', v_1, v_2, \lsv{v_1}, \lsv{v_2}. \, \config{\VE_1}{\sigma_1}{t_1} \eval \pconfig{\sigma_1'}{v_1} \,\land \,
                                 \config{\VE_2}{\sigma_2}{t_2} \eval \pconfig{\sigma_2'}{v_2} \, \land \, \\[\medskipamount]
                           &   & \;\; \qquad  \W \sqsubseteq \W' \, \land \,\DOM(\sigma_i') \subseteq \DOM(\sigma_i)\, \land \, \st{\sigma_1'}{\sigma_2'}{\W'}{\lsv{1} \cup \fr{\sigma_1'}{\sigma_1}}{\lsv{2} \cup \fr{\sigma_2'}{\sigma_2}} \, \land \, \\[\medskipamount]
                           &   & \;\; \qquad (\W', v_1, v_2, u', \lsv{1}, \lsv{2}) \in \VT{T} \, \land \, u' = (\neg \ab{a} \vee u) \, \land \, (\neg u \Rightarrow L_{v_i} = \emptyset) \, \land \\[\medskipamount]
                           &   & \;\; \qquad \vallocs{v_i} \subseteq \emptyset \ccup{\ab{a.s}} \explocs{t_i}{\VE_i} \ccup{\ab{a.f}} \fr{\sigma_i'}{\sigma_i} \, \land \, \\[\medskipamount]
                           &   & \;\; \qquad \NUM{E2}{\stw{\sigma_i}{\sigma_i'}{\emptyset \ccup{\textcolor{red}{e}} \explocs{t_i}{\VE_i}}} \, \land \, \NUM{F2}{(\neg \ab{a.f} \Rightarrow \W'_f = \W_f)}
                           \} 
    \end{array}
\end{mathpar}       
\end{mdframed}
\caption{The binary interpretation of types and terms, and semantic context interpretation. The notation $\neg a$ is a shorthand for $\neg (a.f \vee a.s)$, meaning that a value does not reach any resource.}
\label{fig:binary}
\vspace{-3ex}
\end{figure*} The value interpretation of types are defined in \figref{fig:binary}.
In the figure, we use the subscript $i$ in formulas to refer to both terms when the context is clear,
where $i = 1$ or $2$. For example, in the value interpretation of function types, 
we write $\lsv{v_i} = \emptyset$ to mean $\lsv{v_1} = \emptyset \, \land \, \lsv{v_2} = \emptyset$.

To simplify notation and improve readability, we conflate the values of $\btrueA$/$\btrueE$ and $\bfalseA$/$\bfalseE$ with 
logical truth and falsehood, respectively.
For example, we write $e \Rightarrow P$ (for some effect $e$ and predicate $P$) to mean $e = \btrueE \Rightarrow P$.
In addition, we use the shorthand $\neg a$ to express $\neg (a.f \vee a.s)$,
meaning that a value does not reach any resource.


In \figref{fig:binary}, We use the notation $\ccup{b}$ to denote the conditional set union operator, \ie, if the predicate $b$ is true, 
the operator performs a union of the left- and right-hand operands;
otherwise, the result defaults to the left-hand operand only.



The value interpretation of types, written as $\VT{T}$, 
is a set of tuples of form $(\W, v_1, v_2, u, \lsv{1}, \lsv{2})$,
where $v_1$ and $v_2$ are values, and $\W$ is a world, 
$u$ denotes whether the pair of values can be used,
and $\lsv{1}$ and $\lsv{2}$ are some uppper bound of the locations that the reasoning cares.

\bfparagraph{Boolean Type.} A pair of boolean values are related if they are both $\ttrue$ or $\tfalse$.
Since operations on boolean values do not need any resources, they can be used if the associated $u$ component allows.

\bfparagraph{Reference Type.} A pair of locations $(\ell_1, \ell_2)$ are related with respect to the world $\W$ if they are used by the reasoning (\ie, $u$ holds).
In this case, their relation must be defined in the world $\W$, and their reachable locations have to be bounded by $\lsv{1}$ and $\lsv{2}$ respectively.
Otherwise (\ie, $u$ does not hold), the reasoning does not have any knowledge about the pair. 



\bfparagraph{Function Types.} 
The set of values of function type $\TFunAE{T_1}{a_1}{T_2}{a_2}{e}$ with respect to the world $\W$ is defined based on its computational behavior.
Note that we inline the term interpretation to characterize the function body's computational behavior.

\bfparagraph{Safe Execution.} 
As mentioned earlier, we adopt relational worlds from \citet{bao2025logrel}'s work to characterize localization.
For example, 
if a function either has a latent effect, 
or the result carries stored ability (\ie, $\ef{e} \vee ur \wedge \ab{a_2.s}$),
then a safe execution of the function body needs to access locations reachable from the function (formulas $\recdx{L1}$ and $\recdx{S1}$).
Here, the formula $\stcp{\W}{\W'}{L_{\lambda_1}}{L_{\lambda_2}}$ means that types are only preserved with respect to 
reachable locations from function values.

Thus, the reasoning must need the locations reachable from the function.
In another word, if the function has no latent effect, 
or its return value does not reach any pre-existing locations (\ie, $\textcolor{blue}{a_2.s=\bfalseA}$), 
then the function can be safely executed in any future world extending from the current one $\W$ where the argument values are valid.

\bfparagraph{From Abilities and Effects to Reachable Locations.} 
Formulas $\recdx{R1}$, $\recdx{R2}$ and $\recdx{R3}$ capture properties of reachable locations enabled by 
the ability and effect qualifiers.
Formula $\recdx{R1}$ states that 
if the function has a latent effect, 
then the reachable locations from the function and its argument are bounded by the locations that the reasoning cares (\ie, $\lsv{i}$).
Formula $\recdx{R2}$ states that the argument cannot reach any locations 
if the fresh and stored component of the argument's ability qualifier are both $\bfalseA$ or the argument is not used.
Formula $\recdx{R3}$ states that if the return value's stored component (in its ability qualifier) is $\btrueA$, 
then it may reach locations from the function or its argument.
In addition, if its fresh component is $\btrueA$, it may reach freshly allocated locations. 


\bfparagraph{From Effects to Value Preservation.}
Formulas $\recdx{E1}$ and $\recdx{E2}$ capture the value preservation over a potentially effectful computation,
\ie, values stored in pre-existing locations that are not covered by the effects remain unchanged. 

\bfparagraph{Terms.}
In addition to the properties about reachable locations, safe execution and value preservation,
which are similar to those for function bodies, 
two terms are related if their reduction results are related at given types.

\subsection{The Compatibility Lemmas, Fundamental Theorem and Soundness}
\figref{fig:binary} defines the interpretation of typing context. 
In the definition, $\VE$ ranges over a pair of relational value environments
that are finite maps from variables $x$ to pairs of values $(v_1, v_2)$.
If $\VE(x) = (v_1, v_2)$, then $\VE_1(x)$ denotes $v_1$ and $\VE_2(x)$ denotes $v_2$.
We write $\DOM_1(\VE)$ and $\DOM_2(\VE)$ to mean the domain of the first and second value environment respectively.

The semantic typing rules have the same shape as the corresponding syntactic ones, 
but turning the symbol $\ts$ in \figref{fig:has-type-ae} into $\models$. 
Each of the semantic typing rules is a compatibility lemma and has been proved in Coq.

\begin{theorem}[Fundamental Property] If $\hasTypeAEC{\G} {t} {T} {a} {e}$, then $\semTypeAE{\G}{t}{t}{T}{a}{e}$.
\end{theorem}


\begin{theorem}[Soundness with respect to Contextual Equivalence] The binary logical relation is sound with respect to contextual equivalence, \ie,
    if $\hasTypeAEC{\G}{t_1}{T}{a}{e}$, and $\hasTypeAEC{\G}{t_2}{T}{a}{e}$, 
    then $\semTypeAE{\G}{t_1}{t_2}{T}{a}{e}$ implies $\ctxEquivAE{\G}{t_1}{t_2}{T}{a}{e}$.
\end{theorem}

\begin{theorem}[Effect Safety of Ability and Effect Type Systems]
    A syntactically pure expression is semantically (observationally) pure:
    $$ 
      \hasTypeAEC{\G}{t}{T}{a}{\bfalseE} \Rightarrow 
        \forall C: (\G; T\ \ab{a}\ \bfalseE\ \flt) \carrow (\G'; T'\ \ab{a'}\ \ef{e'}\ \flt').\
        \G' \models (\lambda x. C[x])\ t \equiva C[t]: T'\ \ab{a'}\ \ef{e'},
    $$
    where $a.f = \bfalseA$, and $\G'(\flt'\setminus x) <: a_f$.
\end{theorem}

\begin{theorem}[$\beta$-Equivalence]\label{thm:beta}
    If $\hasTypeAEC{\G, x: T_1\ a_1}{t_2}{T_2}{a}{e}$, 
    and $\hasTypeAEC{\G}{t_1}{T_1}{a_1}{\bfalseE}$,
    and $a_1.f = \bfalseA$,
    and $\envCapA \Gamma {\fv {t_2} \setminus x} {a_f}$,
    then $\semTypeAE{\G}{(\tabs t_2)(t_1)}{t_2[t_1/x]}{T_2}{a}{e}$.
\end{theorem}

\begin{theorem}[Reordering]\label{thm:reorder}
    If $\hasTypeAEC{\G}{t_1}{\TBoolAE}{a_1}{e_1}$, and 
       $\hasTypeAEC{\G}{t_2}{\TBoolAE}{a_2}{e_2}$, and 
       $\ef{e_1 \wedge e_2 = \texttt{false}}$, 
    then $\semTypeAE{\G}{\tseqb{t_1}{t_2}}{\tseqb{t_2}{t_1}}{\TBoolAE}{\avbot}{e_1 \EFC e_2}$
\end{theorem}
\section{Related Work} \label{sec:related}









\bfparagraph{Purity} 
In object-oriented programming languages, 
various definitions of purity have been proposed~\cite{stewart2014csse}, 
among which the definition of \citet{DBLP:journals/sigsoft/LeavensBR06} has been widely adopted in Java.
Under this definition, a location is modified when it exists in both the pre-state and post-state of an execution,
but stores different values in these two states.
This notion of observable purity has been adopted by Java analysis tools, including JPPA~\cite{DBLP:conf/vmcai/SalcianuR05}, ReIm and ReImInfer~\cite{DBLP:conf/oopsla/HuangMDE12,DBLP:conf/sigsoft/HuangM12},
JPure~\cite{DBLP:conf/cc/Pearce11}, as well as by Scala purity checking, \eg, \cite{DBLP:conf/ecoop/RytzAO13}.

Different from the above systems, Joe-E~\cite{DBLP:conf/ndss/MettlerWC10} defines pure methods as being side effect free and deterministic, 
\ie, their outputs should depend only on their inputs. %
This notation of purity is closer to the functional programming notion of purity.

In this paper, we use the definition of a pure function aligning with the mathematical definition of a function. 
That is, a pure function's behavior is entirely determined by its input argument, 
and its output does not depend on an external runtime environment that may change.
This definition is suitable for our purpose of equational reasoning. 

\citet{DBLP:journals/jfp/Sabry98} proposes to define purity for the Haskell language based on parameter-passing independence, 
\ie, different evaluation strategies (call-by-value, call-by-need, or call-by-name)
lead to equivalent values modulo divergence and runtime errors.
Our treatment of termination behavior differs from Sabry's approach. 
His equivalence is defined modulo termination, so his definition of pure
language describes Haskell more than Coq. 
In the age of Coq, Agda~\cite{DBLP:conf/tphol/BoveDN09}, Lean~\cite{DBLP:conf/cade/Moura021}, and especially also Liquid Haskell~\cite{DBLP:phd/basesearch/Vazou16}, 
we take the position that it is useful to tighten the definition and
recognize nontermination as impurity in closer correspondence with
logical consistency. 
In the presence of possibly-infinite codata, 
a syntactic guardedness checker is used to ensure productivity, \ie, even if a program generates an infinite amount of data, 
each piece will be generated in finite time~\cite{DBLP:journals/jucs/ATurner04}.



\bfparagraph{Type-and-Effect Systems} 
Effect systems are introduced to integrate imperative operations into functional languages~\cite{gifford1986integrating,DBLP:conf/popl/LucassenG88},
to track read and write effects on the heap~\cite{nielson1999type}, 
to check purity~\cite{DBLP:conf/cc/Pearce11,DBLP:conf/ecoop/RytzAO13,DBLP:conf/icfp/RompfMO09} and exceptions~\cite{DBLP:conf/popl/PessauxL99,DBLP:journals/toplas/LeroyP00,java},
and others. 
\cite{DBLP:conf/tldi/MarinoM09} introduce a generic type-and-effect system that allow programmers to easily define new effects systems. 
\citet{DBLP:journals/toplas/Gordon21} introduce a generic effect quantale framework
that  can model the effects of a range of sequential effect systems. 
In this work, we adopt a canonical binary effect system that distinguishes between computations that may induce observable effects and those that do not,
serving the purpose of reasoning about purity.

\bfparagraph{Algebraic Effects and Handlers} 
Algebraic effects~\cite{DBLP:journals/acs/PlotkinP03} and handlers~\cite{DBLP:journals/corr/PlotkinP13} are a purely functional composable approaches to modeling effects,
and inherit similar challenges in supporting effect polymorphism as those encountered in traditional effect systems.
These challenges are evident in languages that support algebraic effects, 
\eg, Koka~\cite{DBLP:conf/popl/Leijen17}, Helium~\cite{DBLP:journals/pacmpl/BiernackiPPS20}, the language in \citet{DBLP:conf/rta/HillerstromLAS17}'s work,
and the system developed by \citet{DBLP:journals/pacmpl/ZhangM19}'s work.
Frank~\cite{DBLP:conf/popl/LindleyMM17,DBLP:journals/jfp/ConventLMM20} reduces the annotation burden by leveraging ambient effects provided by the context, 
but relies on desugaring them to traditional effect polymorphism. This mechanism is fragile, and may result in unclear error messages.
\citet{DBLP:journals/pacmpl/TangWDHLL25,tang2025rowscapabilitiesmodaleffects} extend Frank's approach with multimodal type theory~\cite{DBLP:journals/lmcs/GratzerKNB21,694f77d247d34986bb82129b8d96206e} 
in tracking modes for types and terms.

\bfparagraph{Capabilities} 
Capability systems~\cite{DBLP:conf/ecoop/CastegrenW16,DBLP:conf/ecoop/BoylandNR01} have been used to reason about program resources
and external calls~\cite{drossopoulou2025reasoning},
and to ensure unique access with borrowing~\cite{haller2010capabilities},
Reference capabilities in Pony~\cite{DBLP:phd/ethos/Clebsch17} distinguish read and write capabilities.
\citet{DBLP:conf/ecoop/Gordon19} articulates the use-mention distinction when designing capabilities and effect systems. 
Our $\lambda_{ae}$-calculus uses ability to track ``mention'', and effects to track ``use''. 
\citet{DBLP:conf/icfem/CraigPGA18} use capabilities to bound the effects that an expression can induce for a language with 
a fixed set of global resources. Our systems can reason about dynamically allocated resources. 

\citet{osvald2016gentrification} distinguish 1st- and 2nd-class values via privilege qualifiers,
which can mediate access to different kinds of capabilities (\eg, read and write) with a fine-grained privilege lattice.
Effekt~\cite{DBLP:journals/pacmpl/BrachthauserSO20} treats effects as capabilities and treat all functions as second-class values,
which providing a lightweight of effect polymorphism, but impeding reasoning about purity.
Our systems track resource via abilities in a coarse-grained way and can recognize pure computation, 
which was not a goal of those prior systems.




\bfparagraph{Tracking Variables in Types} 
\citet{DBLP:journals/pacmpl/BaoWBJHR21} introduce reachability types to track aliasing and separation through reachability qualifiers.
Their work has been extended to support polymorphism~\cite{DBLP:journals/pacmpl/WeiBJBR24},
cyclic references~\cite{deng2025completecyclereachabilitytypes} and bidirectional typing~\cite{jia2024escape}.
Our semantic model is adapted from \citet{bao2025logrel}'s work, but we focus on a simplified setting restricted to Boolean references. 
In addition, \citet{bunting2025a} study contextual equivalence for \citet{DBLP:journals/pacmpl/BaoWBJHR21}'s system  
using operational game semantics and present a full abstraction model based on a labelled transition system.
In the future, we plan to extend our work to support fine-grained ability and effect tracking 
for programs with higher-order stores by leveraging reachability qualifiers as in \citet{bao2025logrel}'s work.

Capturing types~\cite{DBLP:journals/toplas/BoruchGruszeckiOLLB23,DBLP:journals/pacmpl/XuBO24} 
integrate capability tracking and escape checking into Scala 3.
Treating effects as capabilities provides a lightweight way to achieve effect polymorphism~\cite{DBLP:journals/pacmpl/BrachthauserSO20}.
\citet{DBLP:conf/programming/XuO24} introduce reach capabilities to address the challenges when capture checking and mutable variables interact.
Integrating mechanisms from our approach could potentially enable more precise purity checking for Scala.

\section{Conclusions} \label{sec:conc}

This paper proposed a semantic framework for purity and a measure of expressiveness for effect typing disciplines. We showed that canonical binary effect and capability systems are incomparable, motivating a synthesis that combines their strengths, which we call \emph{type, ability, and effect systems}. Our semantic definition of purity, along with our mechanized logical relation, provides a foundation for comparing and proving properties across diverse effect typing disciplines.

\begin{acks}                            %
  This paper has benefited from fruitful discussions 
  at the 24th Meeting of IFIP WG 2.11 in Edinburgh,
  notably with Jeremy Gibbons, Sam Lindley, and others.
  This work was supported in part by NSF award 2348334 and an Augusta faculty startup
  package, as well as gifts from Meta, Google, Microsoft, and VMware.
\end{acks}



\bibliography{references}



\end{document}
