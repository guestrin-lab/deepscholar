
\textbf{Building:}
%
% SC cut
%
Languages common in HPC, like C++ and Fortran, are notably missing in commonly used package managers.
%
EasyBuild~\cite{6495863} builds HPC applications from source using specific toolchains, supporting hierarchical module creation~\cite{7081225}.
%
Spack~\cite{10.1145/2807591.2807623} is a package manager that parameterizes builds with constraints and versioned dependencies.
%
Resolving dependencies can be reduced with declarative programming~\cite{10046107} or machine learning~\cite{10793143}.
E4S provides curated HPC software stacks, including hardware-specific containers~\cite{10513439,e4s}.
%
Binary distribution is possible: Spack uses binary caches~\cite{spackbinary}, and EESSI distributes EasyBuild stacks via network filesystems~\cite{https://doi.org/10.1002/spe.3075}.
%
\toolname{} complements these tools by addressing the trade-off between container portability and performance.

\textbf{Portable and HPC Containers:}
%
Injecting or replacing container libraries with host counterparts can be achieved with many container runtimes, but it can require expert knowledge of the system.
%
Apptainer~\cite{10.1371/journal.pone.0177459} supports semi-manual mounting of host MPI~\cite{apptainerdocs}.
%
Charliecloud~\cite{10.1145/3126908.3126925} uses heuristics to copy resource-specific files (NVIDIA, libfabric) into images, permanently modifying them.
%
Sarus~\cite{10.1007/978-3-030-34356-9_5, 10029965} and Podman-HPC~\cite{10030014} use OCI hooks to inject host MPI and GPU libraries.
%
\toolname{} can use the same hooks, but source containers can be compiled to use the version of the specialized library compatible with the one available on the system.
%
Vendor container registries offer optimized but platform-specific images~\cite{nvidiangc,amdinfinity}.

Containers can already contain intermediate representation as Python and Java bytecode~\cite{9242268}.
%
Popcorn Linux~\cite{10.1145/3093337.3037738} enables cross-ISA live migration with a custom compiler and kernel that transform LLVM IR into multi-ISA binaries with compatible data layouts~\cite{10.1145/3688351.3689152}.
%
H-Containers~\cite{10.1145/3381052.3381321, 10.1145/3524452} achieve migration by decompiling to LLVM IR and recompiling to different ISAs.
%
To the best of our knowledge, this is the only known use of IR for container deployment.
%
However, it differs fundamentally from \toolname{}: we use IR-based representations to access customized performance features of each system. 

\textbf{Performance Portability:}
%
Performance portability often involves rewriting applications using models like OpenMP, OpenACC, or SYCL~\cite{9484790, 10.1145/3529538.3529980}.
%
Frameworks provide new abstractions for memory access (Kokkos~\cite{CARTEREDWARDS20143202}), loop parallelism (Raja~\cite{8945721}), and data-centric programming (DaCe~\cite{10.1145/3458817.3476176}).
%
Compilers can translate programming idioms to specialized libraries~\cite{10.1145/3173162.3173182} and accelerators~\cite{10.1145/3578360.3580262},
and upgrade applications to use newer and specialized implementations of linear algebra libraries~\cite{8891611}.
%
\toolname{} focuses on portable representations of existing applications without rewriting or requiring single-source code.
%
We do not require applications to be single-source
or use the same set of source files across all systems and devices.

\textbf{Emulation, Translation, and JIT:}
%
Cross-ISA emulation, such as Docker with QEMU~\cite{dockerqemu}, is unsuitable for HPC due to performance overheads.
%
Runtime MPI ABI translation layers like\sloppy~Wi4MPI~\cite{9556086} can incur performance overhead.
%
Other tools include mpixlate~\cite{mpixlatecray} (compatibility with Cray MPI), MPITrampoline~\cite{schnetter_2022_6174409}, Mukautuva~\cite{mukautuva}, and MPI-Adapter2~\cite{10.1145/3636480.3637219}.
%
JIT compilation, used in CUDA PTX, OpenCL, SYCL IR~\cite{alpayOnePassBind2023}, allows for specialization of the final implementation by compiling the code dynamically.
