
We implement a prototype of \toolname{} containers that can create source and IR images and then deploy them on selected HPC systems.
%
For common choices of specialization points, like CUDA or Intel oneAPI, we provide an extensible fleet of Docker containers and manual installation steps.
%
In source containers, we build a toolset for matching system specifications and specialization points, implement application-specific patching and integration, and provide two base source images, one for x64 and one for ARM64.
%
The prototype of IR containers is built on top of Clang 19 and CMake, and includes a collection of Docker images with common runtimes and application dependencies.
%
Users provide application-specific parameters and build steps, from which we generate all build configurations.

The new types of containers proposed in this work differ fundamentally from existing approaches, which raises new challenges in handling different applications and systems (Section~\ref{sec:ir-integration-challenges}).
%
We transition from multi-arch container images to multi-IR images, highlighting that performance portability requires a change in container structure.
%
Source and IR containers are vessels for delivering the correct environment and application, and they need to be transformed during the deployment step.
%
\toolname{} containers will need new approaches to integrate into container ecosystems (Section~\ref{sec:ir-integration-oci}).

\subsection{Challenges}
\label{sec:ir-integration-challenges}

\textbf{Can an IR container be cross-platform?}
%
\toolname{} needs to create one IR container per architecture, e.g., \emph{IR, x86} and \emph{IR, AArch64}.
%
While the LLVM intermediate representation can be independent of the target system, this condition does not hold for practical compilation of C/C++ applications.\footnote{C/C++ code \emph{cannot} be compiled to a platform-independent LLVM IR~\cite{llvmdocs}.} 
%
The IR is affected by the compilation platform, e.g., through type sizes, definitions included in system headers, inlined assembly, and intrinsics~\cite{llvmbitcodeindependent}.

\vspace{0.5ex}
\noindent\textbf{How to handle custom targets?}
%
Applications can use custom targets to fetch dependencies or generate source files.
%
For example, when no FFT implementation is selected for GROMACS, it will build a custom implementation, but this does not happen at configuration time - only at build time.
%
We assume that the user specifies all such targets, and we execute them before analyzing build configurations.

\vspace{0.5ex}
\noindent\textbf{Which IRs are available?}
%
The IR container requires a toolchain that can export the intermediate representation and import it in subsequent compilation steps.
%
Here, LLVM IR is the primary example.
%
While GNU Compilers export the program representation in GIMPLE, this format cannot be imported later and lowered to the target architecture.
%
On GPUs, the intermediate representation can be provided through PTX on NVIDIA architectures, and SPIR-V for applications using SYCL and OpenCL. 
%
However, at this moment, the intermediate representations of Intel DPC++/C++ Compiler and Cray Compiling Environment are unavailable to end users.
%
When partial compilation to IR is impossible, source containers offer the fallback option.
%
\toolname{} can also use high-level intermediate representations suitable for HPC optimizations, e.g., DaCe SDFG~\cite{10.1145/3295500.3356173}.

\subsection{Compatibility with OCI Containers}
\label{sec:ir-integration-oci}

%\noindent\textbf{OCI Compatibility}

% https://github.com/opencontainers/image-spec/blob/main/spec.md#understanding-the-specification
% https://specs.opencontainers.org/image-spec/
Our deployment model fundamentally differs from traditional containers: \toolname{} completely breaks the relationship between the image in the registry and the image on the system.
%
This can raise the question of OCI compliance, since the container standard requires that changes to image layers are recorded in the manifest, leading to a new hash value and a new immutable identifier of the image~\cite{ocimagespec}.
%
However, \toolname{} publishes standard container images, pulls them from container registries, and produces specialized images in the same OCI-compliant format that can be consumed later by general-purpose and HPC-focused container runtimes.
%
We introduce a new deployment tool customized for HPC specialization, but all other steps of container management - building, publishing, pulling, and running - are conducted with standard and existing container tools.
%
Furthermore, virtually none of the current HPC container solutions preserve OCI compliance: images are generally flattened~\cite{Gerhardt_2017,10.1007/978-3-030-34356-9_5,10.1145/3126908.3126925} (destroying the original OCI layers), converted to SquashFS, or use the custom Singularity Image Format (SIF)~\cite{10.1371/journal.pone.0177459}.

\vspace{0.5ex}
\noindent\textbf{Image Architecture and Annotations:}
%
In \toolname{} containers, we propose that the source and IR formats become a new identifying feature of the container image.
%
This would require that the OCI specification recognizes LLVM IR as a valid architecture.
%
The current specification allows an image to have an architecture and a variant of the architecture~\cite{ocimagespec}.
%
% https://github.com/opencontainers/image-spec/blob/main/image-index.md#platform-variants
%While variants can be flexible, they must be associated with a specific architecture.
%
Additionally, it reserves a list of \emph{features}
which can be used to encode deployment format.

% https://github.com/opencontainers/image-spec/blob/main/annotations.md
%
OCI images use annotations for additional metadata in various media types (indexes, manifests, image configurations), with the latter consumed directly by container runtimes. 
%
In \toolname{}, annotations could embed specialization points of the HPC application.
%
We propose that future versions could include specialization points as image annotations, allowing \toolname{} tools to query them before pulling and building the final image.
%
Furthermore, it would simplify image tags and allow for the easy location of specialized images. %on the HPC systems.
