\subsection{Code Correctness Assessment Problem Formulation}
\label{sec:problem_formulation}


Given the prevalence of hallucinations in LLM-generated code and the potential of internal representations to signal such failures, we aim to formulate the task of \textit{code correctness assessment} based on a model's internal states.
%
Let $\mathscr{M}$ be a code LLM consisting of $L$ layer, which generates sequence of code tokens $c = \{c_1, \dots, c_m\}$ given an input $x = \{x_1, \dots, x_n\}$. At each generation step $s$, $s \in [1, m]$, the model produces internal representation $h_{l,s}$ at every layer $l$, $l \in [1, L]$, capturing contextualized information about token $c_s$. We define $\mathcal{H} = \{ h_{l,s} \mid l \in [1, L],\ s \in [1, m] \}$ as the set of internal representations associated with the entire generated sequence, across all $L$ layers and $m$ token positions.

Formally, we define the \textit{code correctness assessment} task as a binary classification problem:

\begin{definition}[\textbf{Code Correctness Assessment}]
Given the internal representations $\mathcal{H}$ associated with the generated code sequence $c$, the goal of code correctness assessment is to predict whether $c$ is correct or not. Formally,  we aim to learn a function:

$$
f_\theta: \mathcal{H} \mapsto y
$$
where $f_\theta$ maps the internal states $\mathcal{H}$ to a correctness label $y \in \{0, 1\}$, where $y = 1$ indicating correct code and $y = 0$ indicating incorrect or hallucinated code.
\end{definition}


The correctness of the generated code can be evaluated along multiple dimensions, including \textit{compilability}, \textit{functionality}, and \textit{security}. Depending on the use case, different oracles, such as compilers, dynamic test cases, or static security analyzers, can be employed to provide ground-truth correctness labels.
 
\begin{definition}[\textbf{Compilability}]

Compilability refers to whether the generated code $c$ can be parsed and compiled successfully without syntax or structural errors.  
Let $\texttt{compile}(c)$ denote the result of compiling $c$ using a standard compiler (e.g., \texttt{gcc} for C/C++, \texttt{javac} for Java) , where $\texttt{compile}(c) \in \{\textit{success}, \textit{failure}\}$.  
Code $c$ is considered compilable if and only if it compiles without errors:
\[
\chi(c) =
\begin{cases}
1 & \text{if } \texttt{compile}(c) = \textit{success}, \\
0 & \text{otherwise}.
\end{cases}
\]
\end{definition}

\begin{definition}[\textbf{Functionality}]
Functionality ensures that the generated code $c$ satisfies the functional requirements specified by the input prompt $x$. 
Let $\mathcal{T} = \{t_1, \dots, t_k\}$ denote a set of functional test cases designed to validate whether $c$ fulfills the intended behaviors. Let $t(c)$ represent the outcome of applying a test $t \in \mathcal{T}$ to the code $c$, where $t(c) \in \{passed, failed\}$.
Code $c$ is considered functionally correct if and only if it passes all tests in  $\mathcal{T}$: 

\begin{equation}
\eta(c) = 
\begin{cases} 
1 & \text{if } \forall t \in \mathcal{T}, \; t(c) = \textit{passed}, \\ 
0 & \text{otherwise}.
\end{cases}
\end{equation}

\end{definition}

\begin{definition}[\textbf{Security}]

Security assesses whether the generated code $c$ adheres to secure coding practices. 
Let $\mathcal{V} = \{v_1, \dots, v_h\}$ denote a set of security vulnerability checks, and $v(c)$ represents the outcome of evaluating $c$ against vulnerability check $v \in \mathcal{V}$, where $v(c) \in \{\textit{safe}, \textit{unsafe}\}$.
Code $c$ is considered secure if and only if it passes all security checks in $\mathcal{V}$:

\begin{equation}
\sigma(c) = 
\begin{cases} 
1 & \text{if } \forall v \in \mathcal{V}, \; v(c) = \textit{safe}, \\ 
0 & \text{otherwise}.
\end{cases}    
\end{equation}

\end{definition}



This work focuses on three key dimensions of code correctness: compilability, functionality, and security, as they represent fundamental aspects of practical code quality~\cite{al2011software}. These dimensions cover syntactic validity, behavioral correctness, and safety, each critical for ensuring reliable and trustworthy code. While our framework is tailored to these dimensions, it can be readily extended to incorporate additional correctness criteria in a similar manner.