%%%%%%%% ICML 2025 EXAMPLE LATEX SUBMISSION FILE %%%%%%%%%%%%%%%%%

\documentclass{article}

% Recommended, but optional, packages for figures and better typesetting:
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} % for professional tables
\usepackage{rotating} 
\usepackage{adjustbox}
\usepackage{multirow}
\usepackage{multicol}

% hyperref makes hyperlinks in the resulting PDF.
% If your build breaks (sometimes temporarily if a hyperlink spans a page)
% please comment out the following usepackage line and replace
% \usepackage{icml2025} with \usepackage[nohyperref]{icml2025} above.
\usepackage{hyperref}


% Attempt to make hyperref and algorithmic work together better:
\newcommand{\theHalgorithm}{\arabic{algorithm}}

% Use the following line for the initial blind version submitted for review:
% \usepackage{icml2025}

% If accepted, instead use the following line for the camera-ready submission:
\usepackage[accepted]{icml2025}

% For theorems and such
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}

% if you use cleveref..
\usepackage[capitalize,noabbrev]{cleveref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THEOREMS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{assumption}[theorem]{Assumption}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

% Todonotes is useful during development; simply uncomment the next line
%    and comment out the line below the next line to turn off comments
%\usepackage[disable,textsize=tiny]{todonotes}
\usepackage[textsize=tiny]{todonotes}


% The \icmltitle you define below is probably too long as a header.
% Therefore, a short form for the running title is supplied here:
\icmltitlerunning{Understanding Collective Social Behavior in OSS Communities: A Co-editing Network Analysis of Activity Cascades}

\begin{document}

\twocolumn[
\icmltitle{Understanding Collective Social Behavior in OSS Communities:\\ A Co-editing Network Analysis of Activity Cascades}

% It is OKAY to include author information, even for blind
% submissions: the style file will automatically remove it for you
% unless you've provided the [accepted] option to the icml2025
% package.

% List of affiliations: The first argument should be a (short)
% identifier you will use later to specify author affiliations
% Academic affiliations should list Department, University, City, Region, Country
% Industry affiliations should list Company, City, Region, Country

% You can specify symbols, otherwise they are numbered in order.
% Ideally, you should not use this facility. Affiliations will be numbered
% in order of appearance and this is the preferred way.
\icmlsetsymbol{equal}{*}

\begin{icmlauthorlist}
\icmlauthor{Lisi Qarkaxhija}{yyy}
\icmlauthor{Maximilian Carparo}{comp1}
\icmlauthor{Stefan Menzel}{comp2}
\icmlauthor{Bernhard Sendhoff}{comp2}
\icmlauthor{Ingo Scholtes}{yyy}
%\icmlauthor{}{sch}
%\icmlauthor{}{sch}
\end{icmlauthorlist}

\icmlaffiliation{yyy}{Chair of Machine Learning and Complex Networks, Julius-Maximilians-Universität Würzburg, CAIDAS - Center for Artificial Intelligence and Data Science, Würzburg, Germany}
\icmlaffiliation{comp1}{DATEV eG, N\"urnberg, Germany}
\icmlaffiliation{comp2}{Honda Research Institute Europe, Offenbach am Main, Germany}
% \icmlaffiliation{sch}{School of ZZZ, Institute of WWW, Location, Country}

\icmlcorrespondingauthor{Lisi Qarkaxhija,}{lisi.qarkaxhija@uni-wuerzburg.de}
% \icmlcorrespondingauthor{Jan von Pichowski}{jan.pichowski@uni-wuerzburg.de}
% \icmlcorrespondingauthor{Franziska Heeg}{franziska.heeg@uni-wuerzburg.de}

% You may provide any keywords that you
% find helpful for describing your paper; these are used to populate
% the "keywords" metadata in the PDF but will not be shown in the document
\icmlkeywords{Open Source Software, Social Networks, Activity Cascades, Collaborative Development, Network Analysis}

\vskip 0.3in
]

% this must go after the closing bracket ] following \twocolumn[ ...

% This command actually creates the footnote in the first column
% listing the affiliations and the copyright notice.
% The command takes one argument, which is text to display at the start of the footnote.
% The \icmlEqualContribution command is standard text for equal contribution.
% Remove it (just {}) if you do not need this facility.

% \printAffiliationsAndNotice{}  % leave blank if no need to mention equal contribution
\printAffiliationsAndNotice{} % otherwise use the standard text.


\begin{abstract}
Understanding the collective social behavior of software developers is crucial to model and predict the long-term dynamics and sustainability of Open Source Software (OSS) communities. To this end, we analyze temporal activity patterns of developers, revealing an inherently ``bursty'' nature of commit contributions. To investigate the social mechanisms behind this phenomenon, we adopt a network-based modelling framework that captures developer interactions through co-editing networks. Our framework models social interactions, where a developer editing the code of other developers triggers accelerated activity among collaborators. 
Using a large data set on 50 major OSS communities, we further develop a method that identifies activity cascades, i.e. the propagation of developer activity in the underlying co-editing network. 
Our results suggest that activity cascades are a statistically significant phenomenon in more than half of the studied projects. We further show that our insights can be used to develop a simple yet practical churn prediction method that forecasts which developers are likely to leave a project. Our work sheds light on the emergent collective social dynamics in OSS communities and highlights the importance of activity cascades to understand developer churn and retention in collaborative software projects.
\end{abstract}

\section{Introduction}
\label{sec:intro}

% Collective dynamics in OSS projects
Open source software (OSS) development represents one of the most successful forms of large-scale collaborative knowledge work in the digital age~\cite{raymond2001cathedral, weber2004success}. 
Understanding the social mechanisms that enable thousands of distributed developers to effectively coordinate their work is fundamental to comprehend how complex software systems emerge from decentralized collaboration~\cite{Crowston_Howison_2005, von2003community}. 
To this end, numerous studies in empirical software engineering have considered human and social aspects such as the motivation of individual developers~\cite{lakhani2003hackers, hertel2003motivation}, the influence of project governance structures and team size~\cite{o2003guarding,shaikh2017governing,scholtes2016aristotle} as well as the role of (temporal) collaboration and communication networks~\cite{bird2006mining, wolf2009predicting,gote2019git2net}.


% Burstiness
An interesting yet less studied aspect of collective social dynamics in OSS communities are temporal patterns of developer contributions, i.e. at which times developers contribute to a project.
Human activities are often characterized by ``bursty'' dynamics, where short periods of intense activity are followed by long periods of inactivity \cite{goh2008burstiness,karsai2018bursty}. 
Such patterns are a hallmark for the influence of complex memory and triggering effects-- i.e. one action influencing the timing of subsequent actions-- which invalidates simple Poissonian models for memoryless events independently occurring at a constant rate.
Such memory effects can naturally arise due to \emph{individual human behavior}, since humans are likely to exhibit bursts in which they perform sequences of similar actions within a short time period.
However, apart from this exogenous explanation, the same patterns can also be endogenously explained by \emph{collective human behavior} in social networks, where the action of one actor triggers subsequent events by its neighbors.
The importance of such social mechanisms to understand collective behavior has been highlighted in various contexts, including E-Mail and letter correspondence \cite{malmgren2009universality}, online forums \cite{panzarasa2015emergence}, collective attention in social media \cite{de2020unraveling}, or synchronized  editing behavior on Wikipedia \cite{kwon2016double}.

The presence of such collective dynamics in other types of human behavioral data raises the question whether similar forms of social influence drive temporal activity patterns of developers in OSS communities. 
Moreover, if such a collective phenomenon exists, it is interesting to study which type of interactions between developers mediate the underlying social influence, and whether it can lead to \emph{activity cascades} that propagate through the time-evolving collaboration network of OSS communities (see Figure~\ref{fig:infographics}).
Understanding the mechanisms behind such activity cascades could provide insights into how distributed teams self-organize and how individual actions influence collective behavior.
Moreover, discovering social mechanisms that trigger developer activity can shed light on the question why some developers leave a project, possibly informing the development of methods to predict developer churn or retention.
To the best of our knowledge these questions have not been studied in the context of collaborative software engineering, which constitutes the research gap that is addressed by our work.

\begin{figure}[htbp]
    \includegraphics[width=\linewidth]{img/unfolded_cascade_network.pdf}
    \caption{Visualization of activity cascades in software development. 
    Each row represents a time step, and each column a developer. 
    Arrows indicate co-edited code between developers, while vertical arrows show subsequent edits by the same developer. 
    A cascade is triggered when a developer ``responds'' faster than usual after his or her code is edited (highlighted with 'Faster Response!' and a trigger label). Co-edits that do not result in a faster response (e.g., A $\rightarrow$ D) are also shown, illustrating that not all edits necessarily trigger a cascade.}
    \label{fig:infographics}
\end{figure}


\paragraph{Research Questions and Hypotheses} Closing this gap, our work is guided by three primary research questions:

\textbf{RQ1: Do commit activities of developers in OSS communities exhibit bursty patterns?} We hypothesize that the inter-event time distributions of commits in OSS projects exhibit a bursty pattern, indicating that developer contributions are not independent events. The presence of such a pattern--and thus the deviation from a Poissonian distribution-- indicates the presence of memory (i.e. the action of one developer influencing future actions of the \emph{same} developer) and/or social influence (i.e. the action of one developer influencing future actions of other developers).

\textbf{RQ2: Do activity cascades propagate along co-editing networks?} Beyond memory effects, we hypothesize that a possible explanation for the presence of bursty activity patterns is social influence that is mediated via co-editing networks. 
This assumes a social mechanism where developers are likely to exhibit a higher level of activity shortly after their code has been edited by other developers.
We further investigate whether this social influence transitively expands into activity cascades that propagate through the co-editing network, further driving the collective dynamics.

\textbf{RQ3: Can the presence of activity cascades inform developer churn prediction?} 
We finally hypothesize that the social mechanism behind developer activity patterns studied in {\bf RQ2} can enhance our ability to forecast which developers are likely to leave a project.
This is based on the assumption that a lack of activity in the neighborhood of a given developer, and the resulting lack of social influence triggering future contributions, can ultimatively make it more likely that the developer leaves the project.

\paragraph{Industry Relevance} Answering these questions is relevant for practitioners from industry that adopt OSS projects or OSS-based development practices for the following reasons:
%
\begin{itemize}
    \item {\bfseries Predicting Risks in OSS Projects:} If we better understand what motivates developers to leave or stay in a project and how likely this is to happen, we can better assess a project’s health and chance of long-term survival. And even if a project survives, the loss of key developers might lead to a situation where depending companies face severe risks (e.g. due to a higher likelihood of unfixed bugs or vulnerabilities). A better understanding of the community dynamics can help us to predict and identify such risks.
    \item {\bfseries Risk-Mitigation Mechanisms:} Understanding the mechanisms behind developer departures in OSS communities is fundamental to design intervention and risk-mitigation strategies by which we can improve developer retention in large software projects, e.g. in the context of so-called \emph{InnerSource communities} that adopt Open Source-style practices in company-internal software projects.
    \item {\bfseries AI-supported Project Management} The early prediction of emerging risks in software projects is crucial for the development of AI-based project monitoring and management tools that can support project management tasks. 
    Moreover, a better understanding of collective social dynamics in software teams is the basis to derive AI-based recommendation schemes to improve social aspects of software projects.
    \item {\bfseries Influence of Agentic AI:} Finally, with the arrival of agentic AI, where software agents become part of hybrid human-AI development teams, insights on the collective social dynamics in OSS communities are crucial to effectively design agents and to promotoe effective agent-agent, agent-human and agent-team collaboration.
\end{itemize}

Besides these applications in software development, our insights can also foster efficient team work in other collaborative engineering contexts such as, e.g.,  automotive product design:

\begin{itemize}
\item {\bfseries Collaboration patterns in teams: } Even if engineering development teams may function according to tighter rule sets and project plans compared to OSS communities, insights into how activity cascades spread across co-editing networks of teams, and how this in turn influences developer retention can potentially be used to support productivity and improve collaboration patterns.
\item {\bfseries Influence of support tools: } Besides human-human collaboration and co-editing dynamics, results generated by support tools such as Computational Aided Engineering (CAE) software could potentially act as triggers that shape temporal collaboration patterns and trigger activity cascades in development teams.
\item {\bfseries Identifying key team members:} The approach to use co-editing networks as a proxy for social interactions offers the chance to identify team members who are central to the network, i.e. people who are connected to many other team members. 
These individuals often support the distribution of knowledge and facilitate the efficient flow of information between different parts of the team. 
Conserving their knowledge, e.g. by documentation, knowledge sharing platforms or early mentoring, supports seamless knowledge transition and overall project success.
\item {\bfseries Knowledge flow in teams:} Additionally, co-editing networks can help us to understand how knowledge flows between team members, how knowledge is distributed and where it is concentrated. 
This can help to identify hidden talents, who might be in less central positions but nonetheless make significant contributions to the team.
\end{itemize}


\paragraph{Research Contribution and Methodology} Addressing the questions outlined above, our work makes the following contributions:
\begin{itemize}
    \item Using a corpus of 50 major OSS communities covering five years, we analyze temporal commit patterns of developers. Our results show that inter-commit times exhibit bursty patterns both at the level of projects and individual developers.
    \item Motivated by this finding, we develop a method to detect activity cascades that traces the propagation of accelerated responses through the co-editing network. 
    \item Through an analysis of 50 diverse OSS projects, we show that activity cascades are a statistically significant phenomenon in 56\% of the analyzed projects. This suggests developers are highly responsive to code modifications, indicating implicit coordination that enables rapid collaborative responses in distributed environments.
    \item We finally show that insights from cascade analysis can enhance the prediction of developer churn, demonstrating the practical utility of our framework.
\end{itemize}



The remainder of this paper is structured as follows: \Cref{sec:related} reviews related work. \Cref{sec:methodology} presents our methods to analyze bursty commit patterns and detect activity cascades. 
In section~\Cref{sec:results} we present empirical results. \Cref{sec:churn} applies our insights to predict developer churn. 
In \cref{sec:discussion} we discuss implications and limitations of our work, before concluding in \cref{sec:conclusion}.


\section{Related Work}
\label{sec:related}

Understanding social aspects in software development has emerged as an important research area in empirical software engineering, organizational theory, and computational social science. 
Our work builds upon several interconnected research streams that examine temporal collaboration patterns, social networks, and emergent coordination in OSS communities, which we summarize below.

\paragraph{Collaboration Patterns in Software Projects}

The application of social network analysis to software projects has provided important insights into how the structure and temporal patterns of collaboration influence project outcomes.
\citet{zoller2020topology} highlight connections between GitHub collaboration networks and project success, showing how network topology affects the resilience and adaptability of projects.
In particular, their work shows that the hierarchical group structure of collaboration networks influences long-term sustainability and productivity of Open Source communities.
Studying co-editing networks extracted from software repositories, \citet{scholtes2016aristotle} studied the interplay between the densification of collaboration structures and developer productivity.
Mapping the social structure of Free and Open Source Software Communities, \citet{Crowston_Howison_2005} studied interactions in bug fixing processes.
They find that the centralization of communication is an important characteristic that distinguishes projects, where larger communities tend to have more decentralized communication patterns.

The temporal dimension of collaboration networks has gained increasing attention in software engineering research.
\cite{gote2019git2net} developed a method to mine time-stamped co-editing networks from Git repositories, which is a foundation for temporal network analysis in OSS communities.
A follow-up work further showed that the co-editing structure influences the timing of commits, where developers are faster to edit their own code compared to code by other developers \cite{gote2022big}.
Considering temporal patterns of commit behavior, \citet{ma2014dynamics} reveal a power law distribution of file- and project-level inter-commit times, which is an indication of collective dynamics. 
Similarly, \cite{sornette2014much} find a heavy-tail distribution of developer commit contributions, arguing that it is indicative of a collective dynamical process.
Studies of temporal activity patterns reveal that  contribution patterns are strong predictors of sustained engagement \cite{xiao2023early}. 
This finding suggests that responsive behavior early in a developer's participation may influence long-term commitment. 
To understand collaboration dynamics in large software projects, the timing of interactions may thus be as important as their content.

\paragraph{Cascade Analysis in Complex Networks}
While studying the structure of temporal collaboration networks is important, a crucial and less investigated further aspect is that those networks are the substrate of dynamical processes that operate on them.
An important class of processes are \emph{cascades} by which information, failures, diseases or social behavior propagates through complex networks.
This phenomenon has been extensively studied in various complex networks, including social media~\cite{10.1145/2229012.2229058, doi:10.1126/science.aap9559, gomez2012inferring}, financial markets~\cite{10.1257/aer.104.10.3115,10.1257/jel.20151228}, and biological networks~\cite{pastor2015epidemic}. 
Traditional cascade analysis focuses on information propagation~\cite{kempe2003maximizing} or behavioral contagion~\cite{centola2010spread}, where actions by one agent influence the probability of similar actions by connected agents.
However, fewer studies have analyzed the propagation of cascades in the context of collaborative software projects.
Being a natural application of models of failure cascades in technical systems, some studies have considered the propagation of changes or failures in software dependency networks.
\citet{Geipel2009} studied cascades of changes propagating through the dependency networks of Open Source projects.
More recently, \cite{shehata2025cascading} investigated how project failures propagate across the dependency network of the Maven Central ecosystem.
Neither of the two works did link this to the developer collaboration networks of the underlying projects.
While \citet{sornette2014much} studied a ``cascading model of productive activity'' in terms of a Hawkes Poisson process, this model deviates from previously cited works on cascades in the sense that it did not consider the propagation of cascades in a (social) network.
Recently, \citet{schueller2024modeling} demonstrated how risks propagate through dependency and maintainer networks, showing that social factors can amplify technical vulnerabilities.

\paragraph{Modeling and Predicting Developer Turnover}

Research on developer motivation and retention has established theoretical frameworks for understanding collaborative engagement. 
Self\-/Determination Theory (SDT) and Social Identity Theory have been applied to explain how autonomy, competence, and social belonging influence developer participation \cite{10.1145/2214091.2214119}. 
While these theories focus on individual psychological factors, our work examines how social interactions create behavioral cascades that influence collective activity patterns.
The relationship between project characteristics and developer behavior has been explored through various lenses. 
\citet{betti2025dynamics} reveal that leadership changes are common in OSS projects and significantly impact various success metrics. Their findings about leadership transitions provide context for understanding how individual departures can trigger broader changes in project dynamics—a phenomenon that may be related to the cascade effects we investigate.
Studies of value-based discussions in OSS projects have shown that conversations about project values can predict changes in contributor turnover patterns \cite{jamieson2024predicting}. 
This work highlights the importance of social dynamics beyond pure technical considerations, supporting our hypothesis that social responsiveness plays a crucial role in collaborative software development.
The application of survival analysis to understand developer turnover patterns has provided insights into retention factors \cite{lin2017developer}.
Using recent advances in deep graph learning. \citet{chang2024condygnn} use graph neural networks to predict which developers are likely to leave a project.

\paragraph{Research Gap}
While existing research has established foundations for understanding social dynamics in  software projects, several research gaps remain. 
Most studies focus on network properties or individual-level factors, with limited attention to dynamic social processes that emerge from direct developer interactions. 
To the best of our knowledge, no studies examined how developer activity propagates through temporal collaboration networks and how this process shapes the collective dynamics of developer contributions.
Finally, the resulting collective dynamics has not been considered as a factor that influences which developers are likely to leave a project.
Addressing these gaps, our work introduces cascade analysis as a tool to understand collective social dynamics in software development. 
Unlike previous works that treat social behavior as exogenous factor, we position social dynamics as endogeneous driver of collaborative behavior that can be measured, analyzed, and leveraged to improve our understanding of large software projects.

\section{Methodology}
\label{sec:methodology}

Our methodology is twofold: 
First, we analyze the temporal dynamics of commit activity to test for burstiness, which informs our subsequent investigation. 
Second, based on these findings, we develop a framework to detect and analyze activity cascades that propagate within co-editing networks.

\subsection{Burstiness Analysis (RQ1)}
To investigate RQ1, we analyze temporal patterns of commits to determine if they exhibit burstiness.
Considering the Pareto principle in OSS communities~\cite{goeminne2011evidence} stating that the majority of work is executed by a small group of developers, for each project we focus on the top 20\% developers with the largest number of commits.
Burstiness refers to fact that a large number of events occur clustered within short time periods that are separated by long periods of inactivity. 
We quantify this using the burstiness coefficient, $B$, proposed by~\citet{goh2008burstiness}.
Given a sequence of inter-event times, $\tau = \{\tau_1, \tau_2, ..., \tau_n\}$ capturing time differences between consecutive commits, the burstiness coefficient is given as:
\begin{equation}
B = \frac{\sigma_{\tau} - \mu_{\tau}}{\sigma_{\tau} + \mu_{\tau}} = \frac{CV_{\tau} - 1}{CV_{\tau} + 1}
\end{equation}
where $\mu_{\tau}$ and $\sigma_{\tau}$ are the mean and standard deviation of inter-event times, respectively, and $CV_{\tau} = \sigma_{\tau} / \mu_{\tau}$ is the coefficient of variation. 
The value of $B$ ranges from -1 to 1: For $B \approx 1$ the process is highly bursty, for $B \approx 0$ events occur independently (following a Poissonian distribution), and for $B \approx -1$ the process is highly regular or periodic.

We calculate $B$ for the inter-event times of commits at two levels:
\begin{enumerate}
    \item \textbf{Project-Level Burstiness:} We treat all commits in a project as a single time series, independent of commit authors.
    \item \textbf{Individual-Level Burstiness:} For each developer, we calculate $B$ based on their personal commit history, i.e. we consider inter-event times for commits of the same developer.
\end{enumerate}

To validate that individual-level burstiness  constitutes a pattern, we compare the observed coefficient against a null model in which we randomly shuffle the time stamps of all commits within a project.
By this, we selectively destroy individual-level burstiness but preserve other aspects such as the total commit activity, project-level inter-event times, as well as the number of commits per developer.


\subsection{Co-editing Network Construction}

Our analysis of activity cascades (RQ2) relies on co-editing networks constructed from Git commit histories. 
A directed temporal edge $A \to B$ is created at time $t$ if developer $A$ commits a change to a line of code previously edited by developer $B$. 
We use git2net~\cite{gote2019git2net} to extract these file-level co-editing relationships. 
The temporal nature of edges is crucial, as it allows us to trace the sequential flow of interactions and detect accelerated responses as described below.

\subsection{Trigger Event and Cascade Detection (RQ2)}
Bursty activity patterns can possibly be explained by a triggering mechanism by which the commit of one developer triggers subsequent commits of other developers.
Our cascade detection method is designed to identify such triggering events and trace their propagation.
Theidea is that a cascade is initiated when a co-editing event prompts an unusually rapid response from the edited developer.

\begin{algorithm}
\caption{Trigger Event Detection}
\label{alg:trigger_detection}
\begin{algorithmic}[1]
\REQUIRE Developer commit histories $H$, co-editing event $e = (editor, edited, edit\_time)$
\ENSURE Boolean indicating if $e$ is a trigger event
\STATE $C \leftarrow H[edited]$ \COMMENT{All commit times of the edited developer}
\STATE $B \leftarrow \{t \in C : t < edit\_time\}$ \COMMENT{Commits before the edit}
\STATE $A \leftarrow \{t \in C : t > edit\_time\}$ \COMMENT{Commits after the edit}
\IF{$|B| \geq 2$ \AND $|A| \geq 1$}
    \STATE $I \leftarrow$ intervals between consecutive times in $B$
    \STATE $r \leftarrow$ percentile rank of $(A[0] - edit\_time)$ among $I$
    \IF{$r \leq 25$}
        \STATE \textbf{return true} \COMMENT{Unusually fast response}
    \ENDIF
\ENDIF
\STATE \textbf{return false}
\end{algorithmic}
\end{algorithm}

\Cref{alg:trigger_detection} details our method for identifying trigger events. 
When developer A edits B's code, we examine B's response time relative to B's historical commit patterns.
We compute the percentile rank of the response interval (time to B's next commit) compared to B's typical inter-commit intervals.
A response in the lowest quartile (rank $\leq 25\%$) is classified as a trigger.
Our choice of the 25th percentile as the threshold for a ``rapid'' response is a standard approach in exploratory data analysis for identifying significant deviations from a baseline without strong distributional assumptions~\cite{tukey1977exploratory}. 
This balances sensitivity and specificity.

\begin{algorithm}
\caption{Cascade Chain Detection}
\label{alg:cascade_detection}
\begin{algorithmic}[1]
\REQUIRE Commit histories $H$, co-editing events $E$, top developers $T$
\ENSURE Set of cascade chains $C$
\STATE $C \leftarrow \emptyset$
\STATE $S \leftarrow$ events in $E$ sorted by time
\FOR{each $e$ in $S$}
    \IF{$e.editor \notin T$ or not \textsc{IsTrigger}($H, e$)}
        \STATE \textbf{continue}
    \ENDIF
    \STATE $chain \leftarrow [e]$
    \STATE $cur \leftarrow e$
    \WHILE{True}
        \STATE $n \leftarrow$ first event in $S$ with $editor = cur.edited$ and $edit\_time > cur.edit\_time$
        \IF{$n$ is None or not \textsc{IsTrigger}($H, n$)}
            \STATE \textbf{break}
        \ENDIF
        \STATE append $n$ to $chain$; $cur \leftarrow n$
    \ENDWHILE
    \IF{$|chain| > 1$}
        \STATE add $chain$ to $C$
    \ENDIF
\ENDFOR
\STATE \textbf{return} $C$
\end{algorithmic}
\end{algorithm}

We use \cref{alg:cascade_detection} to trace such triggers and identify activity cascade. 
Again adopting the Pareto principle, we focus on cascades initiated by the top 20\% most active developers. 
An activity cascade is a sequence of trigger events: 
A edits B, B responds quickly (trigger 1); then B edits C, and C responds quickly (trigger 2), and so on (see Figure~\ref{fig:infographics}). 
We only consider cascades of depth greater than one, i.e. a sequence of at least two trigger events.

\subsection{Statistical Validation Framework}

To establish the statistical significance of observed cascade patterns, we use permutation testing, a non-parametric approach that avoids distributional assumptions.

We consider a \textbf{Temporal Shuffling} null model, which randomly permutes the timestamps of co-editing links while preserving the developers involved in a co-editing relationships. 
With this we test if cascades depend on the temporal ordering of co-edits.
We repeat the detection of triggering and cascade events for shuffled commits. 
For each project we compare empirical cascade counts against the distribution of cascades detected in 100 iterations of the null model.
We calculate empirical $p$-values by determining the fraction of shuffled instances where expected cascade counts equal or exceed empirically observed count.

Beyond statistical significance, in statistical analysis it is crucial to additional consider effect size to assess the importance of a finding \cite{wasserstein2016asa}.
To this end, we calculate Cohen's $d$, which quantifies the difference between observed cascade count and the expected cascade count null model means in terms of standard deviations.

To validate our cascade detection framework, we test it in two synthetically generated networks with known ground truth patterns. 
This evaluation demonstrates the method's accuracy, sensitivity to specific cascade types, and robustness against noise.

Our synthetic validation employs two synthetically generated networks: (1) a \textbf{random network} serving as a negative control, where developers have random commit histories and co-editing events occur between random developer pairs at random times, designed to confirm our method does not produce false positives; and (2) a \textbf{cascade network} engineered to test the detection of cascades, where developers have characteristic commit intervals creating regular development rhythms, and cascades are planted by inserting co-editing events immediately before expected commit times to create unusually short response intervals \footnote{Code and data to reproduce our experiments can be accessed via following link: \url{https://doi.org/10.5281/zenodo.17093608}.}.

\subsection{Dataset and Preprocessing}

Our evaluation uses a dataset of 50 OSS repositories spanning diverse domains (see Table \ref{tab:repo_stats}). 
Building on the corpus presented by \citet{gote2022big}, we selected a subset of 50 projects with a minimum of 5 years of development history and a minimum of 50 contributors.
We extract complete commit histories and apply author disambiguation~\cite{gote2021gambit} to consolidate commit histories across aliases, preventing artificial fragmentation of activity patterns.
We focus on the top 20\% of developers by commit count, who typically contribute a disproportionate share of project activity \cite{goeminne2011evidence}.

\section{Results}
\label{sec:results}

In the following, we present the results of our analysis.

\subsection{Burstiness of Commit Activity (RQ1)}
Our first research question addresses whether commit activity in OSS projects is bursty. 
The analysis of 50 projects provides strong evidence that this is the case both at project and individual level.

Figure \ref{fig:burstiness_distribution} visualizes the burstiness coefficient distributions for original and shuffled individual developer timelines. 
The original data's distribution is centered around a positive B value, indicating a strong tendency towards bursty behavior. 
In contrast, the shuffled data's distribution is centered near zero, as expected from a random process. 
This difference underscores that the observed burstiness is a genuine feature of developer behavior.

\paragraph{Individual-Level Burstiness}
At the individual developer level, the mean burstiness is $B = 0.36$ (std = 0.22), significantly higher than the mean for shuffled data, $B_{shuffled} = 0.09$ (std = 0.17). 
The fact that individual developers exhibit bursty behavior confirms their work patterns are not random. 
The drop in burstiness after shuffling inter-commit times confirms the temporal sequence of commits is crucial, providing evidence for memory effects where one commit influences the timing of the next.

\paragraph{Project-Level Burstiness}
At the project level, we find a mean burstiness coefficient $B = 0.54$ (std = 0.14). 
All projects have $B > 0.19$, indicating that project-wide commit activity is consistently and significantly bursty. 
The temporal clustering of commits suggests that development is not a random, independent process but is characterized by coordinated bursts of activity, motivating the search for underlying triggering mechanisms like activity cascades.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\linewidth]{img/combined_burstiness_distributions.pdf}
    \caption{Distribution of burstiness coefficients (B) for individual developers (blue) and their shuffled counterparts (orange). The clear separation between the distributions shows that developer activity is inherently bursty and not a product of random timing.}
    \label{fig:burstiness_distribution}
\end{figure}


\subsection{Cascade Detection Results (RQ2)}

Table~\ref{tab:pareto_cascade_analysis} presents results for cascade detection across 50 repositories, focusing on cascades initiated by the top 20\% most active developers.
Our analysis reveals that activity cascades are a statistically significant phenomenon in a substantial subset of the analyzed OSS projects. 

\paragraph{Validation of Cascade Detection Method}

The validation of our cascade detection method synthetic networks demonstrates good performance (bottom rows of Table~\ref{tab:pareto_cascade_analysis}). 
The random network shows minimal cascade activity (5 observed vs. 4.3 expected, p=0.416), confirming that our method does not yield false positives.
The cascade network validation shows 249 cascades vs. 176.4 expected (p < 0.001, d = 8.81), confirming that our method is able to successfully detect planted cascades.

\paragraph{Statistical Significance of Cascades in Empirical Data}

The permutation testing framework reveals statistically significant cascade effects in 28 out of 50 repositories (56\%) when comparing observed cascade counts against the temporal null model. 
Projects demonstrating the strongest cascade effects include large-scale repositories such as `woocommerce` (1741 observed cascades vs. 337 expected under temporal shuffling, p = 0.010, Cohen's d = 26.95), `birt` (2261 vs. 852, p = 0.010, d = 25.84), and `readability` (301 vs. 8, p = 0.010, d = 23.06). 
These results confirm that activity cascades are not merely random fluctuations but represent genuine patterns of social responsiveness in software development.

\paragraph{Effect Sizes}
Effect size varies dramatically across repositories, ranging from small (Cohen's d < 0.5) to extremely large (d > 20). 
The distribution of effect sizes follows a bimodal pattern, with most repositories showing either very small effects (suggesting minimal cascade activity) or very large effects (indicating dominant cascade behavior).
The largest effect sizes are observed in repositories with substantial cascade activity, such as `woocommerce` (d = 26.95), `birt` (d = 25.84), and `readability` (d = 23.06). 
These extreme effect sizes indicate that cascade behavior, when present, represents a dominant mode of collaborative interaction rather than a subtle statistical pattern.

\paragraph{Project Heterogeneity and Context Dependence}

A striking finding is the substantial heterogeneity in cascade susceptibility across different projects. 
While some repositories exhibit robust cascade effects with thousands of observed cascades, others show minimal or no cascade activity. 
For instance, projects like `balrog`, `thunar-archive-plugin`, `kit`, `azure-sdk-for-node`, `diyHue`, `zero-to-jupyterhub-k8s`, `enzyme`, `github3.py`, and `pyomo` demonstrate zero observed cascades, suggesting that collaborative responsiveness patterns vary significantly across projects, possibly due to project characteristics, development culture, or team structure.

The heterogeneity is particularly evident when examining the Pareto statistics, which show that the top 20\% of developers contribute between 62.3\% and 96.9\% of total commits across repositories. 
Projects with higher activity concentration, such as `OpenTTD-patches` (96.9\%) and `amp-wp` (95.5\%), do not necessarily exhibit stronger cascade effects, suggesting that activity concentration alone does not determine cascade susceptibility. 
This finding indicates that cascade behavior emerges from complex interactions between individual responsiveness patterns and project-specific factors rather than simple activity distributions.

\paragraph{Role of Top Contributors}

The focus on the top 20\% most active developers reveals their crucial role in initiating cascades. 
These developers contribute a disproportionate share of commits, and our analysis shows that cascades initiated by them are statistically significant in most repositories where cascade effects are detected.


\begin{table}[htbp]
\centering
\resizebox{\linewidth}{!}{%
\begin{tabular}{l|cc|ccc|ccccc}
\toprule
 & \multicolumn{2}{c|}{Pareto Stats} & \multicolumn{3}{c|}{Empirical Data} & \multicolumn{5}{c}{Temporal Shuffling} \\
\cmidrule(lr){2-3} \cmidrule(lr){4-6} \cmidrule(lr){7-11}
Dataset & Top20\% & Commit\% & \#Cascades & Avg. Depth & Avg. Devs & \multicolumn{3}{c}{\#Cascades} & Avg. Depth & Avg. Devs \\
\cmidrule(lr){7-9}
 & & & & & & Mean & p-val & d &  &  \\
\midrule
balrog & 13 & 86.5 & 0 & 0.00 & 0.00 & 10.62 & 1.000 & -0.60 & 1.86 & 2.33 \\
\textbf{birt} & \textbf{27} & \textbf{79.7} & \textbf{2261} & \textbf{2.33} & \textbf{2.58} & \textbf{852.19} & \textbf{$0.010^{**}$} & \textbf{25.84} & \textbf{2.16} & \textbf{2.82} \\
ignite & 47 & 88.3 & 236 & 2.01 & 2.80 & 299.88 & 0.941 & -1.49 & 2.19 & 2.99 \\
\textbf{omnibus-gitlab} & \textbf{81} & \textbf{92.3} & \textbf{350} & \textbf{2.03} & \textbf{2.76} & \textbf{133.43} & \textbf{$0.010^{**}$} & \textbf{6.14} & \textbf{2.06} & \textbf{2.89} \\
thunar-archive-plugin & 15 & 62.3 & 0 & 0.00 & 0.00 & 0.77 & 1.000 & -0.43 & 0.48 & 0.71 \\
\textbf{nodejs-docs-samples} & \textbf{35} & \textbf{85.6} & \textbf{137} & \textbf{2.04} & \textbf{2.39} & \textbf{38.45} & \textbf{$0.010^{**}$} & \textbf{6.44} & \textbf{2.04} & \textbf{2.69} \\
\textbf{mule-integration-tests} & \textbf{18} & \textbf{78.7} & \textbf{47} & \textbf{2.87} & \textbf{2.98} & \textbf{1.21} & \textbf{$0.010^{**}$} & \textbf{11.61} & \textbf{0.86} & \textbf{1.21} \\
\textbf{qmk\_firmware} & \textbf{219} & \textbf{82.8} & \textbf{580} & \textbf{2.09} & \textbf{2.99} & \textbf{160.79} & \textbf{$0.010^{**}$} & \textbf{8.07} & \textbf{2.04} & \textbf{2.90} \\
Python & 80 & 66.0 & 3 & 2.00 & 3.00 & 1.40 & 0.198 & 0.82 & 1.14 & 1.54 \\
pay-selfservice & 15 & 77.1 & 55 & 2.00 & 2.73 & 45.63 & 0.248 & 0.56 & 2.03 & 2.88 \\
kit & 15 & 84.8 & 0 & 0.00 & 0.00 & 0.00 & 1.000 & $\infty$ & 0.00 & 0.00 \\
\textbf{calendar} & \textbf{16} & \textbf{93.9} & \textbf{250} & \textbf{2.00} & \textbf{3.00} & \textbf{12.89} & \textbf{$0.010^{**}$} & \textbf{17.76} & \textbf{1.88} & \textbf{2.62} \\
\textbf{droolsjbpm-integration} & \textbf{22} & \textbf{79.6} & \textbf{228} & \textbf{2.28} & \textbf{2.39} & \textbf{70.52} & \textbf{$0.050^{*}$} & \textbf{2.54} & \textbf{2.03} & \textbf{2.87} \\
\textbf{react-native} & \textbf{267} & \textbf{88.5} & \textbf{988} & \textbf{2.03} & \textbf{2.76} & \textbf{283.29} & \textbf{$0.010^{**}$} & \textbf{13.69} & \textbf{2.04} & \textbf{2.99} \\
\textbf{material-ui} & \textbf{196} & \textbf{91.0} & \textbf{1139} & \textbf{2.04} & \textbf{2.90} & \textbf{320.60} & \textbf{$0.010^{**}$} & \textbf{9.79} & \textbf{2.03} & \textbf{2.89} \\
\textbf{amp-wp} & \textbf{19} & \textbf{95.5} & \textbf{87} & \textbf{2.00} & \textbf{2.92} & \textbf{26.04} & \textbf{$0.040^{*}$} & \textbf{1.52} & \textbf{2.01} & \textbf{2.70} \\
es.react.dev & 112 & 82.9 & 11 & 2.00 & 3.00 & 40.28 & 0.950 & -0.33 & 2.03 & 2.67 \\
azure-sdk-for-node & 27 & 89.8 & 0 & 0.00 & 0.00 & 2.93 & 1.000 & -0.54 & 0.90 & 1.34 \\
\textbf{gitlabhq} & \textbf{230} & \textbf{95.9} & \textbf{1305} & \textbf{2.03} & \textbf{2.84} & \textbf{607.52} & \textbf{$0.010^{**}$} & \textbf{9.45} & \textbf{2.04} & \textbf{2.98} \\
\textbf{fs2} & \textbf{37} & \textbf{92.7} & \textbf{25} & \textbf{2.00} & \textbf{2.96} & \textbf{4.90} & \textbf{$0.010^{**}$} & \textbf{4.85} & \textbf{1.93} & \textbf{2.49} \\
diyHue & 12 & 87.7 & 0 & 0.00 & 0.00 & 0.01 & 1.000 & -0.10 & 0.02 & 0.03 \\
nest-simulator & 25 & 84.7 & 18 & 2.61 & 2.00 & 15.42 & 0.347 & 0.24 & 2.03 & 2.82 \\
sphinx & 82 & 94.6 & 2 & 2.00 & 2.00 & 5.90 & 0.663 & -0.37 & 1.72 & 2.26 \\
\textbf{readability} & \textbf{6} & \textbf{76.1} & \textbf{301} & \textbf{2.00} & \textbf{2.00} & \textbf{7.95} & \textbf{$0.010^{**}$} & \textbf{23.06} & \textbf{0.60} & \textbf{0.74} \\
\textbf{godot} & \textbf{273} & \textbf{93.7} & \textbf{1568} & \textbf{2.12} & \textbf{2.71} & \textbf{675.46} & \textbf{$0.030^{*}$} & \textbf{4.90} & \textbf{2.05} & \textbf{2.96} \\
\textbf{woocommerce} & \textbf{183} & \textbf{94.3} & \textbf{1741} & \textbf{2.07} & \textbf{2.82} & \textbf{336.59} & \textbf{$0.010^{**}$} & \textbf{26.95} & \textbf{2.05} & \textbf{2.95} \\
\textbf{ironic} & \textbf{66} & \textbf{90.8} & \textbf{745} & \textbf{2.08} & \textbf{2.90} & \textbf{349.21} & \textbf{$0.010^{**}$} & \textbf{8.08} & \textbf{2.11} & \textbf{3.01} \\
pandas & 264 & 90.6 & 978 & 2.02 & 2.71 & 632.94 & 0.099 & 1.06 & 2.06 & 2.96 \\
lutris & 39 & 93.1 & 12 & 2.00 & 2.00 & 3.97 & 0.069 & 1.75 & 1.50 & 1.85 \\
\textbf{prebid-server} & \textbf{48} & \textbf{69.3} & \textbf{859} & \textbf{2.43} & \textbf{2.42} & \textbf{472.81} & \textbf{$0.020^{*}$} & \textbf{3.53} & \textbf{2.15} & \textbf{2.78} \\
binaryninja-api & 15 & 91.0 & 35 & 2.00 & 2.91 & 61.12 & 0.832 & -0.39 & 2.17 & 2.80 \\
\textbf{cloud-init} & \textbf{38} & \textbf{90.6} & \textbf{478} & \textbf{2.57} & \textbf{2.72} & \textbf{236.55} & \textbf{$0.040^{*}$} & \textbf{1.61} & \textbf{2.10} & \textbf{2.79} \\
\textbf{infinispan} & \textbf{26} & \textbf{92.7} & \textbf{1886} & \textbf{2.36} & \textbf{3.02} & \textbf{1025.84} & \textbf{$0.040^{*}$} & \textbf{3.00} & \textbf{2.06} & \textbf{2.90} \\
zero-to-jupyterhub-k8s & 26 & 93.6 & 0 & 0.00 & 0.00 & 0.86 & 1.000 & -0.50 & 0.72 & 0.83 \\
graphql-dotnet & 12 & 92.9 & 2 & 2.00 & 2.00 & 3.49 & 0.465 & -0.25 & 1.36 & 1.54 \\
\textbf{qemu} & \textbf{310} & \textbf{92.3} & \textbf{55} & \textbf{2.00} & \textbf{2.53} & \textbf{32.16} & \textbf{$0.040^{*}$} & \textbf{2.22} & \textbf{2.05} & \textbf{2.86} \\
\textbf{hadoop} & \textbf{83} & \textbf{82.4} & \textbf{1775} & \textbf{2.09} & \textbf{2.75} & \textbf{581.21} & \textbf{$0.010^{**}$} & \textbf{19.91} & \textbf{2.09} & \textbf{2.95} \\
enzyme & 18 & 88.1 & 0 & 0.00 & 0.00 & 2.78 & 1.000 & -0.56 & 0.74 & 1.10 \\
\textbf{sonic-buildimage} & \textbf{74} & \textbf{76.4} & \textbf{934} & \textbf{2.39} & \textbf{3.04} & \textbf{359.47} & \textbf{$0.010^{**}$} & \textbf{11.82} & \textbf{2.14} & \textbf{3.00} \\
ansible & 483 & 88.1 & 333 & 2.04 & 2.62 & 301.52 & 0.317 & 0.40 & 2.02 & 2.92 \\
\textbf{cosmos-sdk} & \textbf{65} & \textbf{90.0} & \textbf{2676} & \textbf{2.13} & \textbf{2.85} & \textbf{963.17} & \textbf{$0.010^{**}$} & \textbf{12.49} & \textbf{2.08} & \textbf{2.97} \\
\textbf{xfdesktop} & \textbf{46} & \textbf{83.1} & \textbf{183} & \textbf{2.00} & \textbf{2.01} & \textbf{74.46} & \textbf{$0.030^{*}$} & \textbf{3.05} & \textbf{2.03} & \textbf{2.79} \\
\textbf{data} & \textbf{56} & \textbf{91.4} & \textbf{102} & \textbf{2.00} & \textbf{2.53} & \textbf{17.63} & \textbf{$0.020^{*}$} & \textbf{5.82} & \textbf{2.02} & \textbf{2.94} \\
github3.py & 18 & 92.2 & 0 & 0.00 & 0.00 & 0.36 & 1.000 & -0.15 & 0.06 & 0.08 \\
\textbf{keras} & \textbf{103} & \textbf{85.4} & \textbf{544} & \textbf{2.01} & \textbf{2.72} & \textbf{118.09} & \textbf{$0.010^{**}$} & \textbf{7.63} & \textbf{2.04} & \textbf{2.95} \\
\textbf{browser-compat-data} & \textbf{68} & \textbf{94.2} & \textbf{46} & \textbf{2.00} & \textbf{3.00} & \textbf{15.37} & \textbf{$0.010^{**}$} & \textbf{4.60} & \textbf{2.01} & \textbf{2.86} \\
OpenTTD-patches & 30 & 96.9 & 11 & 2.00 & 2.00 & 14.62 & 0.465 & -0.15 & 2.00 & 2.89 \\
NewPipe & 103 & 83.9 & 19 & 2.05 & 2.74 & 35.14 & 0.802 & -0.83 & 2.05 & 2.88 \\
\textbf{mattermost-mobile} & \textbf{20} & \textbf{77.4} & \textbf{719} & \textbf{2.16} & \textbf{2.59} & \textbf{489.35} & \textbf{$0.010^{**}$} & \textbf{3.00} & \textbf{2.27} & \textbf{2.73} \\
pyomo & 19 & 93.6 & 0 & 0.00 & 0.00 & 6.85 & 1.000 & -1.24 & 1.77 & 2.47 \\ \hline
random network & - & - & 5 & 2.2 & 3.2 & 4.3 & 0.416 & 0.30 & 2.18 & 3.13 \\
\textbf{cascade network} & - & - & \textbf{249} & \textbf{7.4} & \textbf{8.01} & \textbf{176.4} & \textbf{$0.001^{**}$} & \textbf{8.81} & \textbf{6.29} & \textbf{6.97} \\
\bottomrule
\end{tabular}%
}
\caption{Cascades initiated by top 20\% most active developers. Top20\% shows number of top developers, Commit\% shows their share of total commits. Empirical data shows observed values. For temporal shuffling, \#Cascades includes mean, empirical p-value and Cohen\'s d. Avg. Depth and Avg. Devs show mean values. P-values from one-sided permutation tests (100 shuffles). Significance: $^{*}p<0.05$, $^{**}p<0.01$, $^{***}p<0.001$.}
\label{tab:pareto_cascade_analysis}
\end{table}


\subsection{Interpretation of Results}

The results from our first two research questions have implications for understanding the collective dynamics of collaboration in OSS communities.

\textbf{RQ1: The Finding of Burstiness.} 
Our analysis confirms that commit activity is fundamentally bursty, not random. This finding challenges models that treat developer contributions as independent events. 
The presence of burstiness at both the project and individual levels indicates that there are memory effects at play; one action influences the next. 
This suggests that OSS development is a self-organizing system characterized by periods of intense, coordinated effort rather than a steady, predictable workflow. The key implication is that there must be underlying mechanisms that trigger these bursts of activity.

\textbf{RQ2: Cascades as a Driving Mechanism.} 
Our cascade analysis offers an explanation for the burstiness observed in RQ1. 
The existence of statistically significant activity cascades in over half of the projects answers RQ2 in the affirmative and reveals an implicit coordination mechanism. 
Rather than relying solely on formal communication, developers appear to coordinate through rapid, responsive actions to code modifications from their peers.

The role of top contributors as primary initiators of these cascades highlights their dual function: they are not just the main producers of code, but also the social catalysts who spark collaborative momentum. Their actions ripple through the network, activating other developers and driving the project forward in coordinated bursts. This socio-temporal process, where specific developers interact in a precise, time-sensitive manner, is a key driver of emergent coordination in decentralized development environments.

\section{Developer Churn Prediction  (RQ3)}\label{sec:churn}

While our primary focus is understanding collective social dynamics emerging from the propagation of activity cascades, we now demonstrate the relevance of our insights for developer churn prediction, i.e. for a given developer at a given time $t$ we seek to forecast whether this developer will become inactive in a future time window $[t, t+\delta]$ for some time $\delta$.
This application serves as a validation of our approach and illustrates how insights from cascade analysis can inform method to address practically relevant issues in software development.

\subsection{Churn Prediction Framework}

We employ Logistic Regression as a binary classification model due to its simplicity, interpretability, efficiency for large-scale temporal networks, and robust handling of class imbalance through balanced class weighting. 
Our experimental design follows a leave-one-out cross-validation approach to evaluate churn prediction performance across directed and undirected co-editing network representations.

For each repository in our dataset, we create non-overlapping time windows of 12 months. 
Each time window serves as an independent training instance, where we extract network features from the collaboration patterns within that year and predict developer churn occurring at the window's end.
This temporal segmentation approach ensures that our model learns from diverse collaboration dynamics across different project phases and scales.

We adopt a leave-one-out methodology that excludes one target repository entirely from training, using all time windows from the remaining repositories as training instances. 
Specifically, for a dataset of $n$ repositories, we train on $(n-1) \times w_i$ instances, where $w_i$ represents the number of valid time windows for repository $i$, and evaluate on all time windows of the held-out repository. 
This inductive approach provides a robust assessment of cross-project generalizability while maximizing the utilization of temporal data across repositories.
To address class imbalance inherent in churn prediction tasks, we apply the Synthetic Minority Oversampling Technique (SMOTE) \cite{10.5555/1622407.1622416} to the aggregated training data from all time windows.
We combine SMOTE with balanced class weighting in the logistic regression model to further mitigate class imbalance effects.
We utilize Balanced Accuracy as evaluation metric. 
It provides robust performance assessment in the presence of class imbalance, ensuring equal importance to both churn detection and retention prediction accuracy.
To ensure statistical reliability, we execute each leave-one-out experiment across five independent runs using different random seeds, quantifying prediction variance and providing confidence intervals. 
All continuous features are standardized using the \texttt{StandardScaler} of the machine learning package \texttt{scikit-learn}. 
Time windows containing only one class are excluded from evaluation to prevent an artificial inflation of performance metrics.

\begin{table}[htbp]
\centering
\resizebox{\linewidth}{!}{%
\scriptsize
\begin{tabular}{lrrrrrc}
\toprule
Repository & Nodes & Edges & Unique Edges & First Co-edit & Last Co-edit & Windows \\
\midrule
amp-wp & 143 & 155,634 & 607 & 2015-10-05 & 2024-11-12 & 10 \\
ansible & 6,043 & 951,694 & 29,982 & 2012-02-05 & 2024-11-08 & 13 \\
azure-sdk-for-node & 213 & 125,576 & 731 & 2012-01-15 & 2023-04-28 & 12 \\
balrog & 111 & 31,971 & 454 & 2011-06-30 & 2024-10-31 & 14 \\
binaryninja-api & 117 & 37,452 & 450 & 2015-07-26 & 2024-11-11 & 10 \\
birt & 170 & 665,077 & 2,077 & 2005-02-04 & 2024-11-10 & 20 \\
browser-compat-data & 1,065 & 162,097 & 3,960 & 2016-03-31 & 2024-11-09 & 9 \\
calendar & 142 & 53,080 & 501 & 2014-04-23 & 2024-11-11 & 11 \\
cloud-init & 451 & 82,923 & 2,418 & 2009-01-14 & 2024-11-07 & 16 \\
cosmos-sdk & 630 & 398,956 & 6,086 & 2017-01-11 & 2024-11-12 & 8 \\
data & 606 & 149,337 & 3,621 & 2011-12-19 & 2024-11-11 & 13 \\
diyHue & 121 & 15,091 & 335 & 2017-06-28 & 2024-10-26 & 8 \\
droolsjbpm-integration & 157 & 95,536 & 1,048 & 2006-12-19 & 2024-08-07 & 18 \\
enzyme & 390 & 10,533 & 791 & 2015-11-16 & 2024-02-14 & 9 \\
es.react.dev & 2,195 & 91,542 & 7,013 & 2013-05-29 & 2024-11-10 & 12 \\
fs2 & 308 & 55,853 & 998 & 2013-03-07 & 2024-10-24 & 12 \\
github3.py & 187 & 12,809 & 426 & 2012-07-09 & 2024-10-08 & 13 \\
gitlabhq & 2,519 & 1,019,375 & 22,835 & 2011-10-08 & 2024-11-11 & 14 \\
godot & 2,830 & 645,244 & 20,703 & 2014-02-10 & 2024-11-11 & 11 \\
graphql-dotnet & 169 & 44,832 & 627 & 2015-09-10 & 2024-11-02 & 10 \\
hadoop & 699 & 632,323 & 9,320 & 2009-05-26 & 2024-11-11 & 16 \\
ignite & 369 & 649,374 & 6,140 & 2014-02-21 & 2024-11-12 & 11 \\
infinispan & 233 & 475,904 & 1,520 & 2009-03-23 & 2024-11-08 & 16 \\
ironic & 572 & 123,512 & 5,150 & 2012-01-31 & 2024-11-06 & 13 \\
keras & 1,292 & 152,126 & 4,365 & 2015-03-27 & 2024-11-10 & 10 \\
kit & 223 & 10,011 & 428 & 2015-02-14 & 2023-05-30 & 9 \\
lutris & 377 & 52,049 & 1,019 & 2012-05-17 & 2024-11-11 & 13 \\
material-ui & 3,136 & 493,564 & 15,219 & 2014-08-19 & 2024-11-12 & 11 \\
mattermost-mobile & 169 & 48,836 & 527 & 2020-11-24 & 2024-11-11 & 4 \\
mule-integration-tests & 100 & 165,042 & 916 & 2005-03-16 & 2024-11-01 & 20 \\
nest-simulator & 153 & 158,726 & 1,351 & 2015-05-12 & 2024-10-18 & 10 \\
NewPipe & 922 & 98,785 & 5,768 & 2015-09-16 & 2024-11-13 & 10 \\
nodejs-docs-samples & 352 & 75,193 & 1,561 & 2013-01-22 & 2024-11-01 & 11 \\
omnibus-gitlab & 819 & 64,246 & 3,480 & 2013-12-03 & 2024-11-08 & 11 \\
OpenTTD-patches & 254 & 722,513 & 1,945 & 2004-08-10 & 2024-11-12 & 21 \\
pandas & 3,473 & 641,259 & 27,114 & 2011-03-18 & 2024-11-12 & 14 \\
pay-selfservice & 84 & 93,964 & 824 & 2015-10-08 & 2024-11-07 & 10 \\
prebid-server & 439 & 52,077 & 2,597 & 2017-05-01 & 2024-11-05 & 8 \\
pyomo & 139 & 158,705 & 436 & 2014-10-11 & 2024-11-08 & 11 \\
Python & 1,187 & 28,118 & 3,824 & 2016-07-20 & 2024-11-11 & 9 \\
qemu & 2,448 & 877,431 & 24,884 & 2006-02-04 & 2024-11-06 & 19 \\
qmk\_firmware & 2,410 & 228,813 & 8,473 & 2012-10-18 & 2022-02-12 & 10 \\
react-native & 3,434 & 564,859 & 24,934 & 2015-01-30 & 2024-11-11 & 10 \\
readability & 85 & 9,224 & 269 & 2015-02-09 & 2024-10-17 & 10 \\
sonic-buildimage & 548 & 71,509 & 4,128 & 2016-03-09 & 2024-11-08 & 9 \\
sphinx & 817 & 118,674 & 3,017 & 2007-08-03 & 2024-11-08 & 18 \\
thunar-archive-plugin & 141 & 4,128 & 466 & 2006-03-27 & 2024-10-08 & 19 \\
woocommerce & 1,570 & 725,328 & 9,588 & 2011-08-25 & 2024-11-13 & 14 \\
xfdesktop & 345 & 157,083 & 2,078 & 2003-01-16 & 2024-11-12 & 22 \\
zero-to-jupyterhub-k8s & 240 & 17,554 & 592 & 2016-11-04 & 2024-11-07 & 9 \\
\bottomrule
\end{tabular}
}
\caption{Repository Statistics.}
\label{tab:repo_stats}
\end{table}


\paragraph{Network-based Features} Our features summarized in \cref{tab:features} consider various aspects of developer behavior and the topology of co-editing networks.
To study the importance of directed relationships, we perform predictions both for directed and undirected version of the co-editing network.
Network features include metrics like node degree for undirected networks, in-and out-degree for directed networks, the topological distance and connection strength to the founder of a project, as well as betweenness and closeness centrality (both for directed networks).
We also consider features of temporal activity patterns such as inactivity periods, developer tenure in terms of time, and the number of prior commits.

\paragraph{Cascade Features} Inspired by our cascade analysis findings, we introduce neighbor inactivity features that capture temporal activity patterns of a developer's collaborators. 
Our cascade analysis revealed that developers respond more quickly to code modifications when their collaborators are active, suggesting that neighbor activity patterns influence individual behavior.
The neighbor inactivity features—including neighbors' minimum, maximum, and mean inactivity time—represent the minimum, maximum, and mean of the maximum inactivity periods of a developer's collaborators within each time window. 
These features quantify activity in the social environment of each developer. 
If a developer's collaborators exhibit long periods of inactivity, this may signal reduced social engagement and increased risk to become inactive.
Conversely, active neighbors may provide social support and engagement that encourages continued activity. 
This directly translates insights from our cascade analysis--that social responsiveness drives collaborative behavior--into predictive signals for developer retention.


\subsection{Experimental Results}

\Cref{fig:churn_comparison} presents a comprehensive comparison of balanced accuracy scores between directed and undirected co-editing networks across all 50 repositories.
The results reveal substantial performance variation across repositories, with balanced accuracies ranging from 58.2\% to 84.5\%. 
The best-performing repository is `binaryninja-api`, achieving 84.5\% accuracy with the undirected model, while `github3.py` achieves 84.3\% with the directed model. 
Conversely, `thunar-archive-plugin` represents the most challenging prediction case, with accuracies of 58.2\% (undirected) and 58.3\% (directed).

\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{img/loo_churn_comparison.pdf}
    \caption{Balanced accuracy of undirected and directed network models for churn prediction across 50 repositories. Error bars represent standard deviations across five independent runs. Asterisks (*) indicate statistically significant differences (p < 0.05) between the two approaches. Repositories are sorted by average performance across both models.}
    \label{fig:churn_comparison}
\end{figure}

The difference between directed and undirected models is remarkably small. 
Undirected models perform better in 29 repositories, while directed models excel in 21. 
Projects where directed models substantially outperform undirected ones include `github3.py` (+4.87\%), `readability` (+3.15\%), and `enzyme` (+2.64\%), suggesting that directional relationship information is particularly valuable in these contexts. 
Conversely, undirected models show substantial advantages in projects like `mule-integration-tests` (+4.13\%), `binaryninja-api` (+3.00\%), and `pyomo` (+2.77\%).


\subsection{Feature Importance}

To gain insights into the relative predictive power of features in \cref{tab:features} we present the relative importance of features based on the logistic regression coefficients for a model trained across all projects.
The results reveal that cascade features dominate the predictive landscape, with maximum inactivity time emerging as the most critical predictor in both network configurations (importance = 1.011). 
This supports our cascade analysis insights, confirming that developers' engagement patterns and responsiveness to collaborative activity serve as powerful indicators of developer retention.

Neighbor-based features consistently rank among the top predictors in both models, with neighbors' maximum inactivity time (0.605) and neighbors' mean inactivity time (0.467) showing exceptionally high importance. 
This pattern validates our hypothesis that churn behavior exhibits contagion-like properties, where developers' retention is influenced by the engagement patterns of their immediate collaborators. 
The strong predictive power of neighbor inactivity patterns provides empirical support for social influence mechanisms in collaborative software development.

Among positional features, out-degree emerges as the most important predictor (0.364), followed by distance to first contributor (0.263) and (undirected) degree (0.201).
Notably, closeness centrality shows moderate importance (0.126), while betweenness centrality demonstrates minimal predictive power (0.008). 
Developer age also shows moderate importance (0.284), suggesting that experience in the project ecosystem influences retention decisions.

Interestingly, traditional contribution metrics like the number of unique commits show relatively low predictive power (0.055), emphasizing that behavioral patterns and network position are more indicative of developer retention than raw productivity measures. 
This highlights the importance of social and temporal dynamics over simple activity counts in understanding developer churn.

\begin{table}[htb]
\centering
\resizebox{\linewidth}{!}{%
\scriptsize
\label{tab:features}
\begin{tabular}{|p{3cm}|p{3.5cm}|p{1.2cm}|}
\hline
\textbf{Feature} & \textbf{Description} & \textbf{Importance} \\
\hline
\multicolumn{3}{|c|}{\textbf{Cascade Features}} \\
\hline
Maximum Inactivity Time & Longest gap between consecutive commits within window & 1.011 \\
\hline
Neighbors' Maximum Inactivity Time & Maximum of the longest inactivity gaps among a developer's neighbors & 0.605 \\
\hline
Neighbors' Mean Inactivity Time & Mean of the longest inactivity gaps among a developer's neighbors & 0.467 \\
\hline
Developer Age & Time elapsed since developer's first contribution & 0.284 \\
\hline
Neighbors' Minimum Inactivity Time & Minimum of the longest inactivity gaps among a developer's neighbors & 0.136 \\
\hline
Unique No. Commits & Total number of distinct commits authored & 0.055 \\
\hline
\multicolumn{3}{|c|}{\textbf{Network-based Features}} \\
\hline
Out-Degree & Number of developers whose code this developer edited (directed) & 0.364 \\
\hline
Distance to First Contributor & Shortest path length to project's original contributor & 0.263 \\
\hline
Degree & Number of collaborators (undirected) & 0.201 \\
\hline
Closeness Centrality & Inverse of the average shortest path distance to all other developers & 0.126 \\
\hline
Strength to First Contributor & Weighted connection strength with project's original contributor & 0.120 \\
\hline
In-Degree & Number of developers who edited this developer's code (directed) & 0.046 \\
\hline
Betweenness Centrality & Fraction of shortest paths that pass through the developer & 0.008 \\
\hline
\end{tabular}
}
\caption{Feature Categories, Descriptions, and Importance Rankings for Developer Churn Prediction. Features are ordered by their predictive importance within a category,  importance values represent the mean of absolute coefficients both for directed and undirected networks.}
\end{table}


\subsection{Interpretation of Results}

Our investigation into churn prediction serves as a practical validation for the insights gained from our cascade analysis, directly addressing \textbf{RQ3: Can the presence of activity cascades inform developer churn prediction?} 
The answer is affirmative, but the key insight comes not from the prediction scores themselves, but from understanding which features drive them.

Our models, which combine network metrics with cascade\-/inspired features, achieve balanced accuracies ranging from 58.2\% to 84.5\% across 50 repositories. 
This performance significantly outperforms a random baseline and confirms that the features contain a strong predictive signal. 
However, the most crucial finding comes from the feature importance analysis. 
The analysis reveals that the most powerful predictors are those directly related to the social dynamics uncovered in RQ2. 
Specifically, temporal features like a developer's own `maximum\_inactivity\_time` and, critically, the inactivity patterns of their collaborators are paramount.

This directly answers RQ3 by demonstrating that the social responsiveness central to activity cascades also predicts long-term engagement. 
The fact that a developer's risk to become inactive is so strongly tied to their neighbors' activity patterns validates our core thesis: the micro-level, responsive interactions we observe in cascades have tangible, macro-level consequences for project health and developer retention.
This confirms that activity cascades are more than a new phenomenon; they provide a new lens to understand and predict sustainability of collaborative projects.

\section{Discussion}
\label{sec:discussion}

Our work provides empirical evidence that temporal contributions of developers in OSS communities exhibit bursty patterns, which can be explained by the propagation of activity cascades through co-editing networks.
This has implications for how we understand and model collaborative software development.

\paragraph{Burstiness as a Precursor to Cascades}
The confirmation of bursty activity patterns in RQ1 is a critical precursor to our cascade analysis. 
The fact that commits are not independent, random events, but rather occur in clusters, suggests the existence of underlying triggering mechanisms. 
Our work bridges the gap between observing burstiness and identifying a concrete social mechanism --the co-editing cascade-- that can explain it. 
The bursty nature of development means that periods of high activity are expected; 
our cascade model provides a framework for understanding how these bursts are initiated and propagated through social interactions.

\paragraph{Activity Cascades as Emergent Coordination}
The results from RQ2 demonstrate that activity cascades are a statistically significant phenomenon in over half of the projects studied.
This suggests that developers are highly responsive to each other's work, creating an implicit, emergent form of coordination. 
In a distributed environment like OSS, where formal coordination can be minimal, these cascades may play a crucial role in aligning efforts, propagating information, and maintaining momentum.
A cascade could represent a rapid, collaborative bug-fix, a shared effort to complete a feature, or a mentoring interaction where a senior developer's edit prompts a junior developer to quickly follow up.

The heterogeneity of cascade effects across projects is also revealing. 
Some projects, like `woocommerce` and `birt`, are hotbeds of cascade activity, suggesting a highly responsive and tightly-coupled collaborative culture. 
Others show no significant cascade effects, which might indicate a more modularized workflow, different communication norms, or a less socially-driven development process. 
These differences highlight that ``one size fits all'' models of OSS collaboration are inadequate.

\paragraph{Practical Implications for Churn Prediction}
The successful application of cascade features to improve churn prediction (RQ3) demonstrates the practical relevance of our framework.
Traditional churn models often rely on static or slowly-changing developer attributes. 
By incorporating metrics that capture a developer's social responsiveness--their tendency to initiate or participate in cascades--we add a dynamic, behavioral dimension to the prediction. 
A developer who is highly integrated into the cascade network may be more socially embedded and thus less likely to leave. 
Conversely, a decline in a developer's cascade participation could be an early warning sign of disengagement. 
This opens up new avenues for project managers and community health analysts to monitor and foster developer engagement.

\paragraph{Relevance to Industry} Referring to the industrial relevance highlighted in \Cref{sec:intro}, our findings suggest concrete strategies to stabilize Open Source Software communities affected by high rates of developer turnover.
One possible strategy could be to identify developers who initiate activity cascades (i.e., by hiring them to continue their work or offering financial support).
Moreover, our work highlights an important previously unknown dimension in the dynamics of teams, which is relevant for a meaningful integration of automated support tools or agentic AI, which could potentially influence the social mechanisms revealed in our work.

% In that case, your efforts will have a higher return on investment: You get the contributions from the initiating developer plus the developers down the chain.

\paragraph{Limitations and Future Work}
Our study has several limitations. 
First, our cascade detection method, relies on a fixed percentile threshold (25\%) to define a "rapid" response. 
While this is a standard approach, the optimal threshold could vary across projects or developers and future work could thus explore adaptive thresholds. 
Second, we only consider cascades initiated by top developers. 
While justified by the Pareto principle, this means we may miss cascades initiated by other community members. 
A more comprehensive analysis could explore the role of different developer archetypes in cascade dynamics.
Third, we find that cascades are a significant phenomenon in more than half of the projects, which leaves open the question what are the mechanism for project-level burstiness in those projects where we do not find significant cascades.
We hypothesize that this is due to the rather conservative threshold applied in the trigger and cascade detection method.
Finally, our analysis is based on commit data alone. 
Integrating communication data from platforms like Slack, mailing lists, or GitHub issues could provide a richer context for why cascades occur and in which networks they propagate.
Future research could also explore qualitative aspects of cascades. 
Are they primarily about bug-fixing, or feature development? 
Combining our quantitative analysis with qualitative case studies could provide deeper insights into the mechanisms driving this behavior.

\section{Conclusion}
\label{sec:conclusion}

In this work, we present a multi-stage analysis of collective social dynamics in OSS development, moving from a mere description of temporal commit patterns to the underlying social mechanisms of activity cascades.
We first establish that commit activity is inherently bursty, confirming that developer actions are not independent events and suggesting the presence of memory and triggering effects. 
This foundational finding motivated our investigation of activity cascades as a tangible social mechanism driving this dynamics.
We successfully validate the existence of activity cascades in a majority of the 50 OSS projects we analyzed. 
These cascades, where one developer's edit triggers a chain of rapid responses from collaborators, represent a form of emergent, implicit coordination that is vital in decentralized development environments. 
We demonstrate that these social responsiveness patterns are not only statistically significant but also practically useful, as they can improve the prediction of developer churn.

Our research contributes to the open question how macro-level collective dynamics such as bursty contribution patterns emerge based on micro-level social mechanism.
It provides a new lens through which we can view OSS collaboration, shifting the focus from static network structures to the dynamic, responsive interactions that form the social fabric of these communities. 
By understanding the propagation of activity, we gain deeper insights into project health, developer engagement, and the complex interplay between social and technical contributions in the world of open source.
It also sheds light on the larger question how the integration of AI agents can possibly influence collaboration patterns in teams.

%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.

\section*{Acknowledgements}
We thank the open source communities whose collaborative efforts made this research possible. We also acknowledge the high-performance computing resources provided by the Julius-Maximilians-Universität Würzburg for enabling large-scale network analysis. Lisi Qarkaxhija and Ingo Scholtes acknowledge funding from the German Federal Ministry of Education and Research (BMBF) via the Project "Software Campus 3.0", Grant No. (FKZ) 01IS24030. 

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{icml2025}
\bibliography{example_paper}
%%
%% If your work has an appendix, this is the place to put it.
\appendix

\end{document}
\endinput
%%
%% End of file `sample-sigconf-authordraft.tex'.