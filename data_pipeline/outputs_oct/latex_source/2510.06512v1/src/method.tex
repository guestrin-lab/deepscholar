\section{LogSTOP: An Algorithm for Computing STOPs}
\label{sec:method}

Quantitative semantics for variants of LTL, such as Metric or Signal Temporal Logic (MTL/STL), have been proposed to quantify how well a sequence satisfies a temporal property, in \(\mathcal{O}(poly(T \cdot |\varphi|))\) time.
These semantics have been widely used for monitoring, falsification, and control synthesis 
and differ in how the degree of satisfaction is interpreted~\citep{FAINEKOS20094262,donze2010robust,Akazaki2015TimeRI,gmrob}.
For instance, the standard quantitative semantics for STL, \textit{spatial robustness}, uses the \(\min\) and \(\max\) operators to 
compute deviations from satisfaction~\citep{FAINEKOS20094262}; robustness of "Always p" is the minimum score for \(p\) over the sequence. We provide more details on this standard semantics in Appendix~\ref{appendix:semantics}.
\citet{donze2010robust} propose extending this to \textit{space-time robustness} which is higher if the property is satisfied earlier.


Inspired by this literature on quantitative semantics, we propose a scoring function \textit{LogSTOP}, 
that recursively computes a score 
for a sequence \(X[t_s:t_e]\) satisfying temporal property \(\varphi\) 
, given start and end timesteps \(t_s\) and \(t_e\), and a smoothing window \(w\) that we discuss later (Algorithm~\ref{alg:LogSTOP_complete}).
LogSTOP provides a solution to the STOP problem with \(t_s = t\) and \(t_e = T\).
There are three key design choices that distinguish LogSTOP from other quantitative semantics and prior work:

First, the LogSTOP for a sequence with respect to a temporal property represents the log probability of the sequence 
satisfying the temporal property if certain assumptions are met. 
Concretely, this is true when (1) the local properties represent independent events over time, 
(2) the scores for local properties reflect true log probabilities, 
and (3) temporal properties consist of compositions of independent local properties.
We acknowledge that these assumptions are rarely true for real-world sequences and properties.
For instance, the presence of "car" at timestep \(t\) and \(t+1\) are not independent events.
However, these assumptions allow us to use ideas from probability theory for independent events to compute the score.
Moreover, our experiments in Section~\ref{sec:experiments}
show that LogSTOPs are useful for applications such as query matching and ranked retrieval
even when these assumptions are not met.

Second, LogSTOP deals with potentially noisy local predictions 
by downsampling and smoothing predictions over windows of length \(w\) 
(Algorithm~\ref{alg:LogSTOP_complete}, line~\ref{alg:smoothing_op}). 
This 
essentially captures the property that local property scores cannot change drastically in a short local window 
(objects cannot momentarily disappear and reappear, actions cannot change in fractions of seconds, etc.). 
Note that \(w\) is a hyperparameter; a higher value of \(w\) can be used to control for higher variance in local predictions.

Third, LogSTOP operates in the \(\log\) space to prevent underflow with fixed precision and hence assumes that 
the scores for local properties are given in range \([-\infty, 0]\), i.e., \(\hat{y}(c, \cdot) \in [-\infty, 0]\). 
Whenever needed, we normalize the 
\(\hat{y}(c, \cdot)\) to be in the \([0, 1]\) range using \(e^{\hat{y}(c, \cdot)}\).

\begin{algorithm}[t]
\caption{LogSTOP \(\hat{y}(X, \varphi, t_s, t_e, w)\)}\label{alg:cstoptlsmooth}
\begin{algorithmic}[1]
\Require Sequence \(X\), Temporal property \(\varphi\), current timestep \(1 \leq t_s \leq T\), end timestep \(t_s \leq t_e \leq T\), downsampling-smoothing window \(1 \leq w \leq (t_e - t_s + 1)\)
\Ensure \(\hat{y}(X, \varphi, t_s, t_e, w)\)
\Function{$\hat{y}$}{$X, \varphi, t_s, t_e, w$}
\If{$t_s > t_e$} \Return $-\infty$ \label{alg:termination}
\ElsIf{$\varphi = \top$} \Return 0
\ElsIf{$\varphi = \bot$} \Return $-\infty$
\ElsIf{$\varphi = c$}
    \State \Return $\log (\mathrm{avg}_{t' \in [t_s, \min\{t_s+w, t_e\}]} e^{\hat{y}(X, c, t')})$
    \Comment{Smooth scores in window $[t_s, t_s+w]$} \label{alg:smoothing_op}
\ElsIf{$\varphi = \neg \varphi'$}
    \State \Return $\log (1 - e^{\hat{y}(X, \varphi, t_s, t_e, w)})$ \label{alg:not_op}
    % \Comment{Complement rule}
\ElsIf{$\varphi = \varphi_1 \land \varphi_2$}
    \State \Return $\hat{y}(X, {\varphi_1}, t_s, t_e, w) + \hat{y}(X, {\varphi_2}, t_s, t_e, w)$  \label{alg:and_op}
    % \Comment{A3, Independence}
\ElsIf{$\varphi = \varphi_1 \lor \varphi_2$}
    \State \Return $\hat{y}(X, {\neg(\neg \varphi_1 \land \neg \varphi_2)}, t_s, t_e, w)$ \label{alg:or_op}
    % \Comment{De Morgan's law}
\ElsIf{$\varphi = \bigcirc\, \varphi'$}
    \State \Return $\hat{y}(X, {\varphi'}, t_s+w, t_e, w)$
    \Comment{Shift the current timestep from $t_s$ to $t_s+w$}
    \label{alg:next_op}
\ElsIf{$\varphi = \BoxOp{I}\, \varphi'$}
    \State \Return $\hat{y}(X, {\varphi' \land \bigcirc\, \BoxOp{I}\, \varphi'}, t_s, t_e, w)$
    \label{alg:always_op}
\ElsIf{$\varphi = \varphi_1 \UntilOp{I} \varphi_2$}
    \State \Return $\hat{y}(X, {\varphi_2 \lor (\varphi_1 \land \neg \varphi_2 \land \bigcirc\,(\varphi_1 \UntilOp{I-1} \varphi_2))}, t_s, t_e, w)$
    \label{alg:until_op}
\EndIf
\EndFunction
\end{algorithmic}
\label{alg:LogSTOP_complete}
\end{algorithm}
% \vspace{-0.1in}

We briefly discuss how different operators 
are handled in Algorithm~\ref{alg:LogSTOP_complete}
and defer a detailed discussion with examples to Appendix~\ref{appendix:alg1_details}.
The scores for logical operators, negation \(\neg \varphi\), conjunction \(\varphi_1 \land \varphi_2\), and disjunction \(\varphi_1 \lor \varphi_2\) 
are computed using simple rules from probability theory.
Concretely, LogSTOP for \(\varphi_1 \land \varphi_2\) is the sum of the LogSTOPs for \(\varphi_1\) and \(\varphi_2\) (line~\ref{alg:and_op}), and
the LogSTOP for \(\varphi_1 \lor \varphi_2\) is computed using DeMorgan's law 
(line~\ref{alg:or_op}).
The score for the "next" operator \(\bigcirc \varphi\) is computed by shifting the timestep by one window (line~\ref{alg:next_op}). 
Scores for the "always" (\(\square \varphi\)) and "until" (\(\varphi_1 \mathcal{U} \varphi_2\))
operators
are computed recursively using the scores for these properties at the next window (lines~\ref{alg:always_op}-\ref{alg:until_op}).
Informally, the LogSTOP for Always \(\varphi\) at \(t\) can be computed with a \textit{"temporal and"} over \(\varphi\) at \(t\) and Always \(\varphi\) at the next window, \(t+w\).
Similarly, the LogSTOP for \(\varphi_1 \UntilOp{I} \varphi_2\) can be computed with a \textit{"temporal or"} over (1) \(\varphi_2\) at \(t\), and (2) \(\varphi_1\) at \(t\) with \(\varphi_1 \UntilOp{I} \varphi_2\) at the next window.


\noindent \textbf{Complexity analysis for LogSTOP.}
The computational complexity of Algorithm~\ref{alg:LogSTOP_complete}, 
for a temporal property \(\varphi\) with length \(|\varphi|\) and a sequence of \(T\) predictions  
is \(\mathcal{O}(T \cdot |\varphi|)\).
This uses dynamic programming to cache scores for all sub-properties over the sequence~\citep{fainekos2012verification}. 
The key observation here is that at any timestep \(t\), the LogSTOP for \textit{any} property \(\varphi\) can be computed in \(\mathcal{O}(|\varphi|)\) given the LogSTOPs for its sub-properties at \(t\) and itself at \(t+w\).
This is because the LogSTOPs for temporal properties are defined recursively and there are at most \(|\varphi|\) sub-properties. 
For \(T/w\) timesteps, this results in \(\mathcal{O}((T/w) \cdot |\varphi|)\) time.
Since the smoothing operation takes \(\mathcal{O}(w)\) time per window, 
computing LogSTOP for \(\varphi\) over a sequence of length \(T\) requires \(\mathcal{O}(T \cdot |\varphi|)\) time. 

\subsection{LogSTOP for Query Matching}
\label{sec:logstop_qm}

We define query matching with temporal properties as the task of predicting whether a given temporal property / query matches, or is expressed by, a sequence. 
LogSTOPs can be used for matching sequence \(X\) with query \(\varphi\) by comparing \(\hat{y}(X, \varphi, 1, T)\) with an appropriate threshold.

A natural first choice for such a threshold for LogSTOP is the constant \(\tau = \log0.5\). This threshold, is employed by existing works to determine if a video satisfies a temporal property~\citep{yang2023specification,Choi2024TowardsNV}. This, however, does not scale with the length of the sequence. For instance, given a 6-frame video with constant \(\log 0.9\) scores for "car",
the LogSTOP for temporal property "Always car", with \(w = 1\), is \(\log(0.9^6)\). This is greater than \(\log(0.5)\) and hence the video matches the query. 
However, when another frame with the same high score \(\log(0.9)\) is added,
the score drops to \(\log(0.9^7)\), which is less than \(\log(0.5)\) and hence the video no longer matches the query.
We would ideally also like the latter to match the query since the property "car" is detected with high scores. 

We propose an adaptive threshold \(\tau\) for query \(\varphi\) and sequence length \(T\) as follows:
\begin{align*}
\hat{y}_{0.5}(\cdot, \varphi, T, w) &= \hat{y}(\cdot, \varphi, 1, T, w) \text{ using } \hat{y}_{0.5}(\cdot, c, t) = \log 0.5 \text{ for all } c \in C, 1 \leq t \leq T \\
\tau(\varphi, T, w) &= \min\left\{ \log 0.5,\, \hat{y}_{0.5}(\cdot, \varphi, T, w) \right\}
\end{align*}

Informally, a sequence expresses a temporal property if the LogSTOP is higher than both random chance \(\log 0.5\) 
and LogSTOP using random chance predictors for local properties \(\hat{y}_{0.5}(\cdot, \varphi, T, w)\).
This threshold can be computed in \(\mathcal{O}(T \cdot |\varphi|)\) and is guaranteed to match at least as many sequences as the constant \(\log 0.5\) threshold.
For properties where the score decreases with sequence length (e.g., \(\BoxOp{I} \varphi\)), the adaptive threshold 
allows more sequences to match 
the query 
than the constant threshold.

% Algorithm for logstop retrieval:
\begin{algorithm}[t]
\caption{LogSTOP for Ranked Sequence Retrieval}
\label{alg:logstop-retrieval}
\begin{algorithmic}[1]
\Require Database \(\mathcal{D} = \{X_1, X_2, \ldots, X_N\}\), temporal property \(\varphi\), event length range \((T_{lo}, T_{hi})\), number of retrievals \(k\), smoothing window for LogSTOP \(w\)
\Ensure Ranked list \(\mathcal{R}\)

\State \(R \gets []\)
\For{\(X_i \in \mathcal{D}\)}
    \State \(s_i \leftarrow -\inf\)
    \State \(T \gets X_i{.length()}\)
    \For{\(T_{end} \in \{T_{lo}, \ldots, T\}\)}
        \State \(T_{start} \gets \max\{1, T_{end} - T_{hi}\}\) \Comment{Max length of subsequence is \(T_{hi}\)}
        \State \(\text{Compute }\hat{y}(X_i, \varphi, T_{start}, T_{end}, w)\) using Algorithm~\ref{alg:LogSTOP_complete} \Comment{Caches scores for suffix subsequences}
        \State \(s_{i, T_{end}} \gets \max\{\hat{y}(X_i, \varphi, t, T_{end}, w) \text{ for } t \in [T_{start}, T_{end} - T_{lo}]\}\)
        \State \(s_i \leftarrow \max(s_i, s_{i, T_{end}})\) \Comment{Track maximum score}
    \EndFor
    \State \(\mathcal{R}\text{.append}((i, s_i))\)
\EndFor \\
\Return \(\text{top-}k\text{ sequences from } \mathcal{R} \text{ in decreasing order of } s_i\)
\end{algorithmic}
\end{algorithm}


\subsection{LogSTOP for Ranked Retrieval}

LogSTOP 
can also be used for the task of ranking and
retrieving sequences relevant to temporal properties of interest. 
Formally, given a database of \(N\) sequences \(\mathcal{D} = \{X_1, \ldots, X_N\}\) 
a temporal property \(\varphi\), 
and a range of event lengths \((T_{lo}, T_{hi})\),
the goal is to rank each \(X_i\) based on whether 
it contains a subsequence \(X_i[t:t']\) of length \(t' - t \in [T_{lo}, T_{hi}]\) that expresses \(\varphi\). 
Examples of such queries include "videos with a 10 to 20 second scene where a person is sitting down until they stand up".
This task is different from the query matching task in two key ways:
firstly, the relative ranking of sequences is more important than absolute scores.
Secondly and more importantly, 
the relevance of a sequence may only be with respect to a part of the sequence (a \textit{moment} in the video, for example).

Algorithm~\ref{alg:logstop-retrieval} outlines how LogSTOP can be used for ranked retrieval.
Informally, given a temporal property \(\varphi\), sequence \(X\), and event duration \((T_{lo}, T_{hi})\),
the relevance of \(X\) to \(\varphi\) 
is defined as the maximum LogSTOP of any subsequence of \(X\) of length in \([T_{lo}, T_{hi}]\).
The relevance score for any sequence can be computed in \(\mathcal{O}(T^2 \cdot |\varphi|)\) time
since LogSTOPs for suffix subsequences are cached with dynamic programming.
Note
that this represents one way of computing scores for ranking videos, where subsequences of certain lengths are relevant to queries; there could be other variants which LogSTOP could be used for but are not considered (for example, computing the score with respect to the entire video, or only considering videos where the subsequence score is over a threshold). 