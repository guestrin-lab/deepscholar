
\section{Transformation}\label{sec:trans}

This section details \tool's approach to automatically inserting flush
and fence operations to ensure programs are free from missing
flush/fence bugs.

\subsection{Flush Insertion}

When \tool's analysis detects a violation, \tool fixes it by
immediately flushing the PM locations after they become \dirty using
\code{clwb}, which changes their state to \clwb in our analysis. Our
experience shows that conservatively flushing on atomic loads
can incur a significant overhead.
To alleviate this problem, we implement the FliT
transformation~\cite{flit} for atomic memory accesses, which uses
counters to signal whether all stores to a PM location have been
flushed.  By reading this counter after an atomic load, we
can determine whether the store may not have
completed its flush and thus the load must help.  This improves the
performance of many atomic-load-heavy benchmarks, as can be seen in
the evaluation results of Section~\ref{sec:eval}.

The flush instruction can be chosen from \code{clflush}, \code{clwb},
and \code{clflushopt}. We choose \code{clwb} as it has weaker ordering
properties than \code{clflush} and may retain the cache line on some
architectures as compared to \code{clflushopt}, potentially leading to
better performance.

If the length of dirty bytes in the object is not constant, which
could occur when modifying an object using functions like as
\code{memcpy}, a call to a variable-sized flush function is inserted
that issues \code{clwb} instructions over the entire range.

\subsection{Fence Insertion}
After flushes are inserted, \tool uses the detected robustness violations to perform fence insertions. We
insert a \code{sfence} before the instruction where a violation is
reported, eliminating the violation.

Specifically, fences are inserted for the two types of \tool
robustness violations as follows:
\begin{enumerate}
    \item \label{error1} A fence is inserted at function exit when
      there are objects in the $\clwb$ state.
    \item \label{error2} When there are two escaped and non-clean
      objects at the same time, a fence is inserted right before the
      second object becomes escaped and non-clean.
\end{enumerate}

Figure~\ref{fig:fence} provides an example of the second case,
showing a block of code with PM-pointers \code{x} and \code{y},
which are escaped and clean at the beginning.
In the unmodified version, the address of \code{x} is written
first, making it dirty, and the address of \code{y} is written later, causing a violation. To fix the violation, \tool inserts
a \code{clwb} instruction on \code{x} after the write, making its
state $\clwb$, and before the address of \code{y} is written, it
inserts a fence, removing the
violation.

\begin{figure}[!h]
\begin{subfigure}{.49\linewidth}
{\scriptsize
  \begin{lstlisting}
//x: <esc,clean>
*x = 1; 
//x: <esc,dirty>
...
//y: <esc,clean>
*y = 1; 
//x: <esc,dirty>, 
//y: <esc,dirty>
//violation!!
\end{lstlisting}
\caption{Before insertions}
}
\end{subfigure}
\begin{subfigure}{.49\linewidth}
  {\scriptsize
  \begin{lstlisting}
//x: <esc,clean>
*x = 1; 
//x: <esc,dirty>
clwb(x);
//x: <esc,clwb>
...
fence();
//x: <esc,clean>
*y = 1; 
//y: <esc,dirty>
//no violation
  \end{lstlisting}
  }
  \caption{After insertions}
  \end{subfigure}
    \caption{Example Insertion of Flushes/Fences.  esc = escaped}
  \label{fig:fence}
\end{figure}

Cases that \tool does not analyze precisely, such as pointer
arithmetic on PM addresses, involve only one object
and are handled by conservatively inserting a fence. The correctness
of this approach follows from our proof for the error detection
mechanism---the inserted fences turn objects that trigger
violations to \clean before the violation, no violation remains
after the fence insertion procedure completes.

Atomic loads turn object states to 
\dirty in our analysis due to potentially unflushed stores from other threads. However, flushes
of previous writes to PM only need to be serialized before the next
store to PM and not the next atomic load. In other words, there is no
need for fences between multiple atomic loads. Thus, fences
for atomic loads are deferred until the next store to PM
to avoid inserting redundant
fences.



 