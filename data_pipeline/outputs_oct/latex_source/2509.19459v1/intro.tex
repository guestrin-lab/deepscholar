\section{Introduction\label{sec:intro}}

In several different contexts, hardware designers have developed
systems in which the contents of memory can survive system crashes.
Compute Express Link (CXL) is a new open standard that enables cache
coherent shared memory across a network.  CXL also supports 
memory interface to persistent storage~\cite{samsungcxlssd}.
Finally, the contents of battery-backed NVDIMM's can survive power
outages.

In all of these contexts, the in-memory data manipulated by a
computation can survive machine crashes, and it can be desirable to
ensure that key data structures are crash consistent so that they can
be safely accessed after crashes.  Achieving crash consistency is
complicated by the volatility of CPU caches, necessitating explicit
flush and fence instructions to persist data.~\footnote{CXL can 
optionally use energy storage to implement flush on failure, though
this requires support by both the device and
system components. This is not a panacea; many failure modes
would still result in lost cache lines.}  Software developers must use special flush and fence instructions to force data to be
written back to the underlying memory.

There is a body of work~\cite{psan,yashme,pmtest} on finding
bugs in persistent memory programs that utilize flushes and fences.  These tools range from model checkers~\cite{yat,jaaru}
to various dynamic bug finding
tools~\cite{xfdetector,pmemcheck,agamotto}.  The prevalence of such bugs,
with 183 new bugs reported by various tools~\cite{jaaru, psan,
  witcher-sosp21, pmdebugger-asplos21, xfdetector, pmtest, agamotto}
in a small expert-written program set, underscores the difficulty of
manual management and motivates automating flush/fence insertion via
compilers.

We developed a new tool that automatically generates the necessary
flush and fence operations.  Strict
persistency~\cite{memorypelley2014} ensures that the ``persistency
memory order is identical to volatile memory order''.  The observation
here is that bugs caused by missing flush and fence operations can be
eliminated by making stores become persistent in the same order that
they become visible to other threads.

Enforcing strict
persistency is expensive as it requires threads to stall frequently to wait for previous stores to be persisted. Fortunately, we can further loosen the requirements for strict persistency.  If it
is impossible for the program to observe that stores were persisted in
a different order, we can permit those stores to be reordered, and partly recover from the performance penalties of strict persistency.
Robustness leverages this additional degree of freedom and ensures
that any execution of a program under a weak persistency model is
equivalent to some execution of the program under the strict
persistency model~\cite{psan}.  This suffices to ensure the correct
usage of flush and fence operations as additional flush and fence
operations will not alter the set of possible post-crash program
executions. As missing flushes and fences are a major source of bugs in persistent memory program, a tool that eliminates these concerns greatly simplifies persistent memory programming. 

Robustness to persistency models has been explored before in the context of bug finding.  PSan uses a dynamic analysis combined with random execution or model checking to check robustness.  PSan
suffers from the same limitations as all dynamic analysis---it
requires test cases and may miss bugs that are not revealed by the
test cases.  Thus, the analysis used by PSan cannot be the foundation
of a compiler that automatically inserts flush and fence operations.

\textbf{\tool is
  applicable to CXL shared memory and all non-volatile memory 
  types.  We collectively refer to all of these memory types as
  persistent memory (PM) throughout the paper for convenience.}

This paper makes the following contributions:
\begin{itemize}
\item {\bf Static Analysis:}  It presents the first static analysis that can efficiently analyze full programs for missing flushes or fences using robustness as a correctness criteria.

\item {\bf PM Analysis:} 
It presents the first static analysis that can determine which operations will only modify volatile or local memory, reducing analysis and annotation overhead.   

\item {\bf Automated Flush Insertion:} It presents the first static tool that can both repair missing flush and fence bugs as well as insert any missing fences, freeing the developer from this task.

\item {\bf Eliminates Missing Flush Bugs:} It presents the first tool that ensures the absence of missing flush bugs.

\item {\bf Evaluation:} It evaluates \tool on a wide range benchmarks, incurring minimal runtime overhead.
\end{itemize}

We have made \tool's source code, benchmarks, and scripts for reproducing evaluation results available at: \url{https://github.com/uci-plrg/PMRobust-docker}