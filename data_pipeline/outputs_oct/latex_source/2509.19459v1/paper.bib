@inproceedings{autopersist,
author = {Shull, Thomas and Huang, Jian and Torrellas, Josep},
title = {AutoPersist: an easy-to-use Java NVM framework based on reachability},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314608},
doi = {10.1145/3314221.3314608},
abstract = {Byte-addressable, non-volatile memory (NVM) is emerging as a revolutionary memory technology that provides persistency, near-DRAM performance, and scalable capacity. To facilitate its use, many NVM programming models have been proposed. However, most models require programmers to explicitly specify the data structures or objects that should reside in NVM. Such requirement increases the burden on programmers, complicates software development, and introduces opportunities for correctness and performance bugs.  We believe that requiring programmers to identify the data structures that should reside in NVM is untenable. Instead, programmers should only be required to identify durable roots - the entry points to the persistent data structures at recovery time. The NVM programming framework should then automatically ensure that all the data structures reachable from these roots are in NVM, and stores to these data structures are persistently completed in an intuitive order.  To this end, we present a new NVM programming framework, named AutoPersist, that only requires programmers to identify durable roots. AutoPersist then persists all the data structures that can be reached from the durable roots in an automated and transparent manner. We implement AutoPersist as a thread-safe extension to the Java language and perform experiments with a variety of applications running on Intel Optane DC persistent memory. We demonstrate that AutoPersist requires minimal code modifications, and significantly outperforms expert-marked Java NVM applications.},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {316–332},
numpages = {17},
keywords = {Non-Volatile Memory, Java, JIT Compilation},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}

@article{delayset,
author = {Shasha, Dennis and Snir, Marc},
title = {Efficient and correct execution of parallel programs that share memory},
year = {1988},
issue_date = {April 1988},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {10},
number = {2},
issn = {0164-0925},
url = {https://doi.org/10.1145/42190.42277},
doi = {10.1145/42190.42277},
abstract = {In this paper we consider an optimization problem that arises in the execution of parallel programs on shared-memory multiple-instruction-stream, multiple-data-stream (MIMD) computers. A program on such machines consists of many sequential program segments, each executed by a single processor. These segments interact as they access shared variables. Access to memory is asynchronous, and memory accesses are not necessarily executed in the order they were issued. An execution is correct if it is sequentially consistent: It should seem as if all the instructions were executed sequentially, in an order obtained by interleaving the instruction streams of the processors. Sequential consistency can be enforced by delaying each access to shared memory until the previous access of the same processor has terminated. For performance reasons, however, we want to allow several accesses by the same processor to proceed concurrently. Our analysis finds a minimal set of delays that enforces sequential consistency. The analysis extends to interprocessor synchronization constraints and to code where blocks of operations have to execute atomically. We use a conflict graph similar to that used to schedule transactions in distributed databases. Our graph incorporates the order on operations given by the program text, enabling us to do without locks even when database conflict graphs would suggest that locks are necessary. Our work has implications for the design of multiprocessors; it offers new compiler optimization techniques for parallel languages that support shared variables.},
journal = {ACM Trans. Program. Lang. Syst.},
month = apr,
pages = {282–312},
numpages = {31}
}

@InProceedings{staticpersist,
author="Bansal, Sorav",
editor="Dragoi, Cezara
and Emmi, Michael
and Wang, Jingbo",
title="StaticPersist: Compiler Support for PMEM Programming",
booktitle="Verification, Model Checking, and Abstract Interpretation",
year="2023",
publisher="Springer Nature Switzerland",
address="Cham",
pages="44--65",
abstract="Persistent Memory (PMEM) programs present unique programmability challenges. An important challenge involves ensuring that programs with mixed volatile-memory and persistent-memory ensure an important reachability invariant: at no point in the program execution should a persistent memory region contain a pointer to a volatile memory region. Such invariants are difficult to detect through testing methodologies, as the corresponding failures show up only in the presence of crashes. Prior work has leveraged runtime support in managed languages like Java (e.g., AutoPersist [31]) to check these invariants at runtime. However, such proposals incur a significant runtime cost. We propose a compile-time analysis that checks and maintains such reachability invariants statically with high precision. We implement this compile-time analysis in tool called StaticPersist which identifies such reachability-invariant violations and proposes fixes in C/C++ code.",
isbn="978-3-031-24950-1"
}



@inproceedings{nvlc,
author = {Denny, Joel E. and Lee, Seyong and Vetter, Jeffrey S.},
title = {{NVL-C}: Static Analysis Techniques for Efficient, Correct Programming of Non-Volatile Main Memory Systems},
year = {2016},
isbn = {9781450343145},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2907294.2907303},
doi = {10.1145/2907294.2907303},
abstract = {Computer architecture experts expect that non-volatile memory (NVM) hierarchies will play a more significant role in future systems including mobile, enterprise, and HPC architectures. With this expectation in mind, we present NVL-C: a novel programming system that facilitates the efficient and correct programming of NVM main memory systems. The NVL-C programming abstraction extends C with a small set of intuitive language features that target NVM main memory, and can be combined directly with traditional C memory model features for DRAM. We have designed these new features to enable compiler analyses and run-time checks that can improve performance and guard against a number of subtle programming errors, which, when left uncorrected, can corrupt NVM-stored data. Moreover, to enable recovery of data across application or system failures, these NVL-C features include a flexible directive for specifying NVM transactions. So that our implementation might be extended to other compiler front ends and languages, the majority of our compiler analyses are implemented in an extended version of LLVM's intermediate representation (LLVM IR). We evaluate NVL-C on a number of applications to show its flexibility, performance, and correctness.},
booktitle = {Proceedings of the 25th ACM International Symposium on High-Performance Parallel and Distributed Computing},
pages = {125–136},
numpages = {12},
keywords = {ssd, scm, pmem, persistent memory, openarc, nvm, llvm, flash, c, acid transactions},
location = {Kyoto, Japan},
series = {HPDC '16}
}

@article{pog,
author = {Raad, Azalea and Lahav, Ori and Vafeiadis, Viktor},
title = {Persistent {Owicki-Gries} reasoning: A program logic for reasoning about persistent programs on {Intel}-x86},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428219},
doi = {10.1145/3428219},
abstract = {The advent of non-volatile memory (NVM) technologies is expected to transform how software systems are structured fundamentally, making the task of correct programming significantly harder. This is because ensuring that memory stores persist in the correct order is challenging, and requires low-level programming to flush the cache at appropriate points. This has in turn resulted in a noticeable verification gap. To address this, we study the verification of NVM programs, and present Persistent Owicki-Gries (POG), the first program logic for reasoning about such programs. We prove the soundness of POG over the recent Intel-x86 model, which formalises the out-of-order persistence of memory stores and the semantics of the Intel cache line flush instructions. We then use POG to verify several programs that interact with NVM.},
journal = {Proc. ACM Program. Lang.},
month = {nov},
articleno = {151},
numpages = {28},
keywords = {x86-TSO, program logic, persistency, non-volatile memory, consistency}
}

@inproceedings{pierogi,
author = {Bila, Eleni Vafeiadi and Dongol, Brijesh and Lahav, Ori and Raad, Azalea and Wickerson, John},
title = {View-Based {Owicki–Gries} Reasoning for Persistent {x86-TSO}},
year = {2022},
isbn = {978-3-030-99335-1},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-030-99336-8_9},
doi = {10.1007/978-3-030-99336-8_9},
abstract = {The rise of persistent memory is disrupting computing to its core. Our work aims to help programmers navigate this brave new world by providing a program logic for reasoning about x86 code that uses low-level operations such as memory accesses and fences, as well as persistency primitives such as flushes. Our logic, Pierogi, benefits from a simple underlying operational semantics based on views, is able to handle optimised flush operations, and is mechanised in the Isabelle/HOL proof assistant. We detail the proof rules of Pierogi and prove them sound. We also show how Pierogi can be used to reason about a range of challenging single- and multi-threaded persistent programs.},
booktitle = {Programming Languages and Systems: 31st European Symposium on Programming, ESOP 2022, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2022, Munich, Germany, April 2–7, 2022, Proceedings},
pages = {234–261},
numpages = {28},
keywords = {Persistent memory, x86-TSO, Owicki-Gries, Isabelle/HOL, verification},
location = {Munich, Germany}
}

@inproceedings{psan,
author = {Gorjiara, Hamed and Luo, Weiyu and Lee, Alex and Xu, Guoqing Harry and Demsky, Brian},
title = {Checking Robustness to Weak Persistency Models},
year = {2022},
isbn = {9781450392655},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519939.3523723},
doi = {10.1145/3519939.3523723},
abstract = {Persistent memory (PM) technologies offer performance close to DRAM with persistence. Persistent memory enables programs to directly modify persistent data through normal load and store instructions bypassing heavyweight OS system calls for persistency. However, these stores are not made immediately made persistent, the developer must manually flush the corresponding cache lines to force the data to be written to persistent memory. While state-of-the-art testing tools can help developers find and fix persistency bugs, prior studies have shown fixing persistency bugs on average takes a couple of weeks for PM developers. The developer has to manually inspect the execution to identify the root cause of the problem. In addition, most of the existing state-of-the-art testing tools require heavy user annotations to detect bugs without visible symptoms such as a segmentation fault. In this paper, we present robustness as a sufficient correctness condition to ensure that program executions are free from missing flush bugs. We develop an algorithm for checking robustness and have implemented this algorithm in the PSan tool. PSan can help developers both identify silent data corruption bugs and localize bugs in large traces to the problematic memory operations that are missing flush operations. We have evaluated PSan on a set of concurrent indexes, persistent memory libraries, and two popular real-world applications. We found 48 bugs in these benchmarks that 17 of them were not reported before.},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {490–505},
numpages = {16},
keywords = {Software Verification, Testing, Debugging, Robustness, Persistent Memory},
location = {San Diego, CA, USA},
series = {PLDI 2022} }

@article{memento, 
author = {Cho, Kyeongmin and Jeon, Seungmin and Raad, Azalea and Kang, Jeehoon}, 
title = {Memento: A Framework for Detectable Recoverability in Persistent Memory}, 
year = {2023}, 
issue_date = {June 2023}, 
publisher = {Association for Computing Machinery}, 
address = {New York, NY, USA}, 
volume = {7}, 
number = {PLDI}, 
url = {https://doi.org/10.1145/3591232}, 
doi = {10.1145/3591232}, 
abstract = {Persistent memory (PM) is an emerging class of storage technology that combines the performance of DRAM with the durability of SSD, offering the best of both worlds. This had led to a surge of research on persistent objects in PM. Among such persistent objects, concurrent data structures (DSs) are particularly interesting thanks to their performance and scalability. One of the most widely used correctness criteria for persistent concurrent DSs is detectable recoverability, ensuring both thread safety (for correctness in non-crashing concurrent executions) and crash consistency (for correctness in crashing executions). However, the existing approaches to designing detectably recoverable concurrent DSs are either limited to simple algorithms or suffer from high runtime overheads. We present Memento: a general and high-performance programming framework for detectably recoverable concurrent DSs in PM. To ensure general applicability to various DSs, Memento supports primitive operations such as checkpoint and compare-and-swap and their composition with control constructs. To ensure high performance, Memento employs a timestamp-based recovery strategy that requires fewer writes and flushes to PM than the existing approaches. We formally prove that Memento ensures detectable recoverability in the presence of crashes. To showcase Memento, we implement a lock-free stack, list, queue, and hash table, and a combining queue that detectably recovers from random crashes in stress tests and performs comparably to existing hand-tuned persistent DSs with and without detectable recoverability.}, 
journal = {Proc. ACM Program. Lang.}, 
month = {jun}, 
articleno = {118}, 
numpages = {26}, 
keywords = {persistent memory, detectable recovery, concurrent data structure} }

@inproceedings{atlas-follow-up,
author = {Boehm, Hans-J. and Chakrabarti, Dhruva R.},
title = {Persistence Programming Models for Non-Volatile Memory},
year = {2016},
isbn = {9781450343176},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2926697.2926704},
doi = {10.1145/2926697.2926704},
abstract = { It is expected that DRAM memory will be augmented, and perhaps eventually replaced, by one of several up-and-coming memory technologies. These are all non-volatile, in that they retain their contents without power. This allows primary memory to be used as a fast disk replacement. It also enables more aggressive programming models that directly leverage persistence of primary memory. However, it is challenging to maintain consistency of memory in such an environment. There is no consensus on the right programming model for doing so, and subtle differences can have large, and sometimes surprising, effects on the implementation and its performance. The existing literature describes multiple programming systems that provide point solutions to the selective persistence for user data structures. Real progress in this area requires a choice of programming model, which we cannot reasonably make without a real understanding of the design space. Point solutions are insufficient. We systematically explore what we consider to be the most promising part of the space, precisely defining semantics and identifying implementation costs. This allows us to be much more explicit and precise about semantic and implementation trade-offs that were usually glossed over in prior work. It also exposes some promising new design alternatives. },
booktitle = {Proceedings of the 2016 ACM SIGPLAN International Symposium on Memory Management},
pages = {55--67},
numpages = {13},
keywords = {non-volatile memory, locks, transactions, consistency},
location = {Santa Barbara, CA, USA},
series = {ISMM 2016}
}

@Misc{samsungcxlssd,
  key =          {Samsung},
  title =        {Memory-Semantic {SSD}},
  howpublished = {\url{https://samsungmsl.com/ms-ssd/}},
  year =         {2023}
}

@article{armmodel,
author = {Raad, Azalea and Wickerson, John and Vafeiadis, Viktor},
title = {Weak Persistency Semantics from the Ground up: Formalising the Persistency Semantics of {ARMv8} and Transactional Models},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360561},
doi = {10.1145/3360561},
abstract = {Emerging non-volatile memory (NVM) technologies promise the durability of disks with the performance of volatile memory (RAM). To describe the persistency guarantees of NVM, several memory persistency models have been proposed in the literature. However, the formal persistency semantics of mainstream hardware is unexplored to date. To close this gap, we present a formal declarative framework for describing concurrency models in the NVM context, and then develop the PARMv8 persistency model as an instance of our framework, formalising the persistency semantics of the ARMv8 architecture for the first time. To facilitate correct persistent programming, we study transactions as a simple abstraction for concurrency and persistency control. We thus develop the PSER (persistent serialisability) persistency model, formalising transactional semantics in the NVM context for the first time, and demonstrate that PSER correctly compiles to PARMv8. This then enables programmers to write correct, concurrent and persistent programs, without having to understand the low-level architecture-specific persistency semantics of the underlying hardware.},
journal = {Proceedings of the ACM on Programming Languages},
month = oct,
articleno = {135},
numpages = {27},
keywords = {memory persistency, ARMv8, non-volatile memory, weak memory}
}

@misc{standardpm,
author={Niall Douglas},
year={2018},
title={{P1026R0}: A call for a data persistence (iostream v2) study group},
howpublished={\url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1026r0.pdf}}
}

@inproceedings{relacqpm,
author = {Kolli, Aasheesh and Gogte, Vaibhav and Saidi, Ali and Diestelhorst, Stephan and Chen, Peter M. and Narayanasamy, Satish and Wenisch, Thomas F.},
title = {Language-Level Persistency},
year = {2017},
isbn = {9781450348928},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3079856.3080229},
doi = {10.1145/3079856.3080229},
abstract = {The commercial release of byte-addressable persistent memories, such as Intel/Micron 3D XPoint memory, is imminent. Ongoing research has sought mechanisms to allow programmers to implement recoverable data structures in these new main memories. Ensuring recoverability requires programmer control of the order of persistent stores; recent work proposes persistency models as an extension to memory consistency to specify such ordering. Prior work has considered persistency models at the abstraction of the instruction set architecture. Instead, we argue for extending the language-level memory model to provide guarantees on the order of persistent writes.We explore a taxonomy of guarantees a language-level persistency model might provide, considering both atomicity and ordering constraints on groups of persistent stores. Then, we propose and evaluate Acquire-Release Persistency (ARP), a language-level persistency model for C++11. We describe how to compile code written for ARP to a state-of-the-art ISA-level persistency model. We then consider enhancements to the ISA-level persistency model that can distinguish memory consistency constraints required for proper synchronization but unnecessary for correct recovery. With these optimizations, we show that ARP increases performance by up to 33.2% (19.8% avg.) over coding directly to the baseline ISA-level persistency model for a suite of persistent-write-intensive workloads.},
booktitle = {Proceedings of the 44th Annual International Symposium on Computer Architecture},
pages = {481--493},
numpages = {13},
keywords = {Persistent memories, memory persistency, language-level models},
location = {Toronto, ON, Canada},
series = {ISCA '17} }

@InProceedings{asplospm,
  author = 	 {Hamed Gorjiara and Guoqing Harry Xu and Brian Demsky},
  title = 	 {Jaaru: Efficiently Model Checking Persistent Memory Programs},
  booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
  year = 	 {2021},
  url = {https://doi.org/10.1145/3445814.3446735},
  doi = {10.1145/3445814.3446735}
}

@inproceedings{witcher-sosp21,
author= {Xinwei Fu and Wook-Hee Kim and Ajay Paddayuru Shreepathi and Mohannad Ismail and Sunny Wadkar and Dongyoon Lee and Changwoo Min},
title = {Witcher: Systematic Crash Consistency Testing for Non-Volatile Memory Key-Value Stores},
booktitle = {Proceedings of the 28th ACM Symposium on Operating Systems Principles},
location = {Virtual},
year = {2021},
publisher = {Association for Computing Machinery}, 
address = {New York, NY, USA}, 
pages = {100--115}, 
numpages = {16}, 
series = {SOSP 2021}
}

@inproceedings{jaaru,
author = {Gorjiara, Hamed and Xu, Guoqing Harry and Demsky, Brian},
title = {Jaaru: Efficiently Model Checking Persistent Memory Programs},
year = {2021},
isbn = {9781450383172},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3445814.3446735},
doi = {10.1145/3445814.3446735},
booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {415--428},
numpages = {14},
keywords = {Testing, Crash Consistency, Debugging, Persistent Memory},
location = {Virtual, USA},
series = {ASPLOS 2021}
}

@inproceedings{nvtraverse,
author = {David, Tudor and Dragojevi\'{c}, Aleksandar and Guerraoui, Rachid and Zablotchi, Igor},
title = {Log-Free Concurrent Data Structures},
year = {2018},
isbn = {9781931971447},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 2018 USENIX Conference on Usenix Annual Technical Conference},
pages = {373--385},
numpages = {13},
location = {Boston, MA, USA},
series = {USENIX ATC '18}
}

@inbook{mirror,
author = {Friedman, Michal and Petrank, Erez and Ramalhete, Pedro},
title = {Mirror: Making Lock-Free Data Structures Persistent},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454105},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {1218--1232},
numpages = {15}
}

@ARTICLE{memorypelley2015,
  author={Pelley, Steven and Chen, Peter M. and Wenisch, Thomas F.},
  journal={IEEE Micro}, 
  title={Memory Persistency: Semantics for Byte-Addressable Nonvolatile Memory Technologies}, 
  publisher = {Institute of Electrical and Electronics Engineers},
  year={2015},
  volume={35},
  number={3},
  pages={125--131},
  doi={10.1109/MM.2015.46}}

@INPROCEEDINGS{memorypelley2014,
  author={Pelley, Steven and Chen, Peter M. and Wenisch, Thomas F.},
  booktitle={2014 ACM/IEEE 41st International Symposium on Computer Architecture (ISCA)}, 
  title={Memory persistency},
  publisher = {Institute of Electrical and Electronics Engineers},
  year={2014},
  address={Minneapolis, MN, USA},
  volume={},
  number={},
  pages={265--276},
  doi={10.1109/ISCA.2014.6853222}}

  @INPROCEEDINGS{tsoperekemark2021,
  author={Ekemark, Per and Yao, Yuan and Ros, Alberto and Sagonas, Konstantinos and Kaxiras, Stefanos},
  booktitle={2021 IEEE International Symposium on High-Performance Computer Architecture (HPCA)}, 
  title={TSOPER: Efficient Coherence-Based Strict Persistency}, 
  year={2021},
  publisher = {Institute of Electrical and Electronics Engineers},
  address={Seoul, Korea},
  volume={},
  number={},
  pages={125--138},
  doi={10.1109/HPCA51647.2021.00021}}
  
@inproceedings{pmemjeong2021,
author = {Jeong, Jungi and Jung, Changhee},
title = {PMEM-Spec: Persistent Memory Speculation (Strict Persistency Can Trump Relaxed Persistency)},
year = {2021},
isbn = {9781450383172},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3445814.3446698},
doi = {10.1145/3445814.3446698},
booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {517--529},
numpages = {13},
keywords = {Persistency Model, Strict Persistency, HW/SW Codesign},
location = {Virtual, USA},
series = {ASPLOS 2021}
}

@INPROCEEDINGS{relaxedgogte2020,
  author={Gogte, Vaibhav and Wang, William and Diestelhorst, Stephan and Chen, Peter M. and Narayanasamy, Satish and Wenisch, Thomas F.},
  booktitle={2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA)}, 
  title={Relaxed Persist Ordering Using Strand Persistency},
  publisher = {Institute of Electrical and Electronics Engineers},
  year={2020},
  address={Valencia, Spain},
  volume={},
  number={},
  pages={652--665},
  doi={10.1109/ISCA45697.2020.00060}}
  
  @INPROCEEDINGS{persistfreij2020,
  author={Freij, Alexander and Yuan, Shougang and Zhou, Huiyang and Solihin, Yan},
  booktitle={2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)}, 
  title={Persist Level Parallelism: Streamlining Integrity Tree Updates for Secure Persistent Memory},
  publisher = {Institute of Electrical and Electronics Engineers},
  year={2020},
  address={Athens, Greece},
  volume={},
  number={},
  pages={14-27},
  doi={10.1109/MICRO50266.2020.00015}}
  
@article{usingangeletti2010,
author = {Angeletti, Damiano and Giunchiglia, Enrico and Narizzano, Massimo and Puddu, Alessandra and Sabina, Salvatore},
year = {2010},
month = {12},
pages = {397-414},
title = {Using Bounded Model Checking for Coverage Analysis of Safety-Critical Software in an Industrial Setting},
volume = {45},
journal = {J. Autom. Reasoning},
doi = {10.1007/s10817-010-9172-3}
}

@inproceedings{kleecadar2008,
author = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson},
title = {KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs},
year = {2008},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation},
pages = {209--224},
numpages = {16},
location = {San Diego, California},
series = {OSDI'08}
}

@article{execadar2008,
author = {Cadar, Cristian and Ganesh, Vijay and Pawlowski, Peter M. and Dill, David L. and Engler, Dawson R.},
title = {EXE: Automatically Generating Inputs of Death},
year = {2008},
issue_date = {December 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {2},
issn = {1094-9224},
url = {https://doi.org/10.1145/1455518.1455522},
doi = {10.1145/1455518.1455522},
journal = {ACM Trans. Inf. Syst. Secur.},
month = dec,
articleno = {10},
numpages = {38},
keywords = {attack generation, dynamic analysis, bug finding, constraint solving, test case generation, symbolic execution}
}

@INPROCEEDINGS{automatingbotella2009,
  author={Botella, Bernard and Delahaye, Mickael and Hong-Tuan-Ha, Stephane and Kosmatov, Nikolai and Mouy, Patricia and Roger, Muriel and Williams, Nicky},
  booktitle={2009 ICSE Workshop on Automation of Software Test}, 
  title={Automating structural testing of C programs: Experience with PathCrawler}, 
  year={2009},
  address={Vancouver, BC, Canada},
  publisher = {Institute of Electrical and Electronics Engineers},
  volume={},
  number={},
  pages={70-78},
  doi={10.1109/IWAST.2009.5069043}}


@inproceedings{staticallybabai2011,
author = {Babi\'{c}, Domagoj and Martignoni, Lorenzo and McCamant, Stephen and Song, Dawn},
title = {Statically-Directed Dynamic Automated Test Generation},
year = {2011},
isbn = {9781450305624},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2001420.2001423},
doi = {10.1145/2001420.2001423},
booktitle = {Proceedings of the 2011 International Symposium on Software Testing and Analysis},
pages = {12--22},
numpages = {11},
keywords = {prioritization, static analysis, dynamic analysis, automated testing},
location = {Toronto, Ontario, Canada},
series = {ISSTA '11}
}

@InProceedings{kloverli2011,
author="Li, Guodong
and Ghosh, Indradeep
and Rajan, Sreeranga P.",
editor="Gopalakrishnan, Ganesh
and Qadeer, Shaz",
title="KLOVER: A Symbolic Execution and Automatic Test Generation Tool for C++ Programs",
booktitle="Computer Aided Verification",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="609--615",
abstract="We present the first symbolic execution and automatic test generation tool for C++ programs. First we describe our effort in extending an existing symbolic execution tool for C programs to handle C++ programs. We then show how we made this tool generic, efficient and usable to handle real-life industrial applications. Novel features include extended symbolic virtual machine, library optimization for C and C++, object-level execution and reasoning, interfacing with specific type of efficient solvers, and semi-automatic unit and component testing. This tool is being used to assist the validation and testing of industrial software as well as publicly available programs written using the C++ language.",
isbn="978-3-642-22110-1"
}

@InProceedings{pextillmann2008,
author="Tillmann, Nikolai
and de Halleux, Jonathan",
editor="Beckert, Bernhard
and H{\"a}hnle, Reiner",
title="Pex--White Box Test Generation for .NET",
booktitle="Tests and Proofs",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="134--153",
abstract="Pex automatically produces a small test suite with high code coverage for a .NET program. To this end, Pex performs a systematic program analysis (using dynamic symbolic execution, similar to path-bounded model-checking) to determine test inputs for Parameterized Unit Tests. Pex learns the program behavior by monitoring execution traces. Pex uses a constraint solver to produce new test inputs which exercise different program behavior. The result is an automatically generated small test suite which often achieves high code coverage. In one case study, we applied Pex to a core component of the .NET runtime which had already been extensively tested over several years. Pex found errors, including a serious issue.",
isbn="978-3-540-79124-9"
}

@inproceedings{cutesen2005,
author = {Sen, Koushik and Marinov, Darko and Agha, Gul},
title = {CUTE: A Concolic Unit Testing Engine for C},
year = {2005},
isbn = {1595930140},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1081706.1081750},
doi = {10.1145/1081706.1081750},
booktitle = {Proceedings of the 10th European Software Engineering Conference Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
pages = {263--272},
numpages = {10},
keywords = {unit testing, concolic testing, data structure testing, explicit path model-checking, random testing, testing C programs},
location = {Lisbon, Portugal},
series = {ESEC/FSE-13}
}


@article{dartgodefroid2005,
author = {Godefroid, Patrice and Klarlund, Nils and Sen, Koushik},
title = {DART: Directed Automated Random Testing},
year = {2005},
issue_date = {June 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1064978.1065036},
doi = {10.1145/1064978.1065036},
journal = {SIGPLAN Not.},
month = jun,
pages = {213--223},
numpages = {11},
keywords = {interfaces, program verification, automated test generation, random testing, software testing}
}

@ONLINE{godefroid2008automated,
author = {Godefroid, Patrice and Levin, Michael Y. and Molnar, David},
title = {Automated Whitebox Fuzz Testing},
booktitle={Proceedings of the Network and Distributed System Security Symposium},
organization={Microsoft},
address={San Diego, California, USA},
year = {2008},
month = {November},
url = {https://www.microsoft.com/en-us/research/publication/automated-whitebox-fuzz-testing/},
}

@inproceedings{combiningpundefinedsundef2008,
author = {Pundefinedsundefinedreanu, Corina S. and Mehlitz, Peter C. and Bushnell, David H. and Gundy-Burlet, Karen and Lowry, Michael and Person, Suzette and Pape, Mark},
title = {Combining Unit-Level Symbolic Execution and System-Level Concrete Execution for Testing Nasa Software},
year = {2008},
isbn = {9781605580500},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1390630.1390635},
doi = {10.1145/1390630.1390635},
booktitle = {Proceedings of the 2008 International Symposium on Software Testing and Analysis},
pages = {15--26},
numpages = {12},
keywords = {symbolic execution, software model checking, unit testing, system testing},
location = {Seattle, WA, USA},
series = {ISSTA '08}
}

@inproceedings{fasttrackflanagan2009,
author = {Flanagan, Cormac and Freund, Stephen N.},
title = {FastTrack: Efficient and Precise Dynamic Race Detection},
year = {2009},
isbn = {9781605583921},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1542476.1542490},
doi = {10.1145/1542476.1542490},
booktitle = {Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {121--133},
numpages = {13},
keywords = {race conditions, dynamic analysis, concurrency},
location = {Dublin, Ireland},
series = {PLDI '09}
}
@article{raadpopl2022,
author = {Raad, Azalea and Maranget, Luc and Vafeiadis, Viktor},
title = {Extending Intel-x86 consistency and persistency: formalising the semantics of Intel-x86 memory types and non-temporal stores},
year = {2022},
issue_date = {January 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {POPL},
url = {https://doi.org/10.1145/3498683},
doi = {10.1145/3498683},
abstract = {Existing semantic formalisations of the Intel-x86 architecture cover only a small fragment of its available features that are relevant for the consistency semantics of multi-threaded programs as well as the persistency semantics of programs interfacing with non-volatile memory. We extend these formalisations to cover: (1) non-temporal writes, which provide higher performance and are used to ensure that updates are flushed to memory; (2) reads and writes to other Intel-x86 memory types, namely uncacheable, write-combined, and write-through; as well as (3) the interaction between these features. We develop our formal model in both operational and declarative styles, and prove that the two characterisations are equivalent. We have empirically validated our formalisation of the consistency semantics of these additional features and their subtle interactions by extensive testing on different Intel-x86 implementations.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {22},
numpages = {31},
keywords = {Intel-x86, cacheability, memory consistency, memory persistency, memory types, non-temporal accesses, non-volatile memory, weak memory}
}

@article{intelx86,
author = {Raad, Azalea and Wickerson, John and Neiger, Gil and Vafeiadis, Viktor},
title = {Persistency Semantics of the {Intel-x86} Architecture},
year = {2020},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371079},
doi = {10.1145/3371079},
journal = {Proceedings of the ACM on Programming Languages},
month = {December},
articleno = {11},
numpages = {31},
keywords = {memory persistency, weak memory, Intel-x86, non-volatile memory}
}

@inproceedings{cceh,
author = {Nam, Moohyeon and Cha, Hokeun and Choi, Young-Ri and Noh, Sam H. and Nam, Beomseok},
title = {Write-Optimized Dynamic Hashing for Persistent Memory},
year = {2019},
isbn = {9781931971485},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 17th USENIX Conference on File and Storage Technologies},
pages = {31--44},
numpages = {14},
location = {Boston, MA, USA},
series = {FAST '19}
}

@inproceedings{fastfair,
author = {Hwang, Deukyeon and Kim, Wook-Hee and Won, Youjip and Nam, Beomseok},
title = {Endurable Transient Inconsistency in Byte-Addressable Persistent B+-Tree},
year = {2018},
isbn = {9781931971423},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 16th USENIX Conference on File and Storage Technologies},
pages = {187--200},
numpages = {14},
location = {Oakland, CA, USA},
series = {FAST '18}
}

@inproceedings{yashme,
author = {Gorjiara, Hamed and Xu, Guoqing Harry and Demsky, Brian},
title = {Yashme: Detecting Persistency Races},
year = {2022},
isbn = {9781450392051},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3503222.3507766},
doi = {10.1145/3503222.3507766},
abstract = {Persistent memory (PM) or Non-Volatile Random-Access Memory (NVRAM) hardware such as Intel’s Optane memory product promises to transform how programs store and manipulate information. Ensuring that persistent memory programs are crash consistent is a major challenge. We present a novel class of crash consistency bugs for persistent memory programs, which we call persistency races. Persistency races can cause non-atomic stores to be made partially persistent. Persistency races arise due to the interaction of standard compiler optimizations with persistent memory semantics. We present Yashme, the first detector for persistency races. A major challenge is that in order to detect persistency races, the execution must crash in a very narrow window between a store with a persistency race and its corresponding cache flush operation, making it challenging for na\"{\i}ve techniques to be effective. Yashme overcomes this challenge with a novel technique for detecting races in executions that are prefixes of the pre-crash execution. This technique enables Yashme to effectively find persistency races even if the injected crashes do not fall into that window. We have evaluated Yashme on a range of persistent memory benchmarks and have found 26 real persistency races that have never been reported before.},
booktitle = {Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {830–845},
numpages = {16},
keywords = {Debugging, Persistent Memory, Persistency Race, Testing},
location = {Lausanne, Switzerland},
series = {ASPLOS 2022}
}


@inproceedings{recipe,
author = {Lee, Se Kwon and Mohan, Jayashree and Kashyap, Sanidhya and Kim, Taesoo and Chidambaram, Vijay},
title = {{RECIPE}: Converting Concurrent {DRAM} Indexes to Persistent-Memory Indexes},
year = {2019},
isbn = {9781450368735},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3341301.3359635},
doi = {10.1145/3341301.3359635},
booktitle = {Proceedings of the 27th ACM Symposium on Operating Systems Principles},
pages = {462--477},
numpages = {16},
keywords = {isolation, crash consistency, concurrency, persistent memory, data structures, indexing},
location = {Huntsville, Ontario, Canada},
series = {SOSP '19}
}

@inproceedings{ycsb,
  title={Benchmarking cloud serving systems with {YCSB}},
  author={Cooper, Brian F and Silberstein, Adam and Tam, Erwin and Ramakrishnan, Raghu and Sears, Russell},
  booktitle={Proceedings of the 1st ACM symposium on Cloud computing},
  pages={143--154},
  year={2010}
}


@inproceedings {agamotto,
author = {Ian Neal and Ben Reeves and Ben Stoler and Andrew Quinn},
title = {{AGAMOTTO}: How Persistent is your Persistent Memory Application?},
booktitle = {14th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 20)},
year = {2020},
pages = {1047--1064},
numpages = {18},
address = {Banff, Alberta},
publisher = {{USENIX} Association},
month = {November}
}

@inproceedings{pmtest,
author = {Liu, Sihang and Wei, Yizhou and Zhao, Jishen and Kolli, Aasheesh and Khan, Samira},
title = {{PMTest}: A Fast and Flexible Testing Framework for Persistent Memory Programs},
year = {2019},
isbn = {9781450362405},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3297858.3304015},
doi = {10.1145/3297858.3304015},
booktitle = {Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {411--425},
numpages = {15},
keywords = {debugging, crash consistency, testing, persistent memory},
location = {Providence, RI, USA},
series = {ASPLOS '19}
}

@inproceedings{xfdetector,
author = {Liu, Sihang and Seemakhupt, Korakit and Wei, Yizhou and Wenisch, Thomas and Kolli, Aasheesh and Khan, Samira},
title = {Cross-Failure Bug Detection in Persistent Memory Programs},
year = {2020},
isbn = {9781450371025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373376.3378452},
doi = {10.1145/3373376.3378452},
booktitle = {Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {1187--1202},
numpages = {16},
keywords = {crash consistency, debugging, testing, persistent memory},
location = {Lausanne, Switzerland},
series = {ASPLOS '20}
}

@misc{witcherfu2020,
      title={WITCHER : Detecting Crash Consistency Bugs in Non-volatile Memory Programs}, 
      author={Xinwei Fu and Wook-Hee Kim and Ajay Paddayuru Shreepathi and Mohannad Ismail and Sunny Wadkar and Changwoo Min and Dongyoon Lee},
      year={2020},
      eprint={2012.06086},
      archivePrefix={arXiv},
      primaryClass={cs.SE}
}

@InProceedings{yat,
  author = 	 {Philip Lantz and Subramanya Dulloor and Sanjay Kumar and Rajesh Sankaran and Jeff Jackson},
  title = 	 {Yat: A Validation Framework for Persistent Memory Software},
  booktitle = {Proceedings of the 2014 USENIX Annual Technical Conference},
  year = 	 {2014},
  month = 	 {June},
  isbn = {978-1-931971-10-2},
  address = {Philadelphia, PA},
  pages = {433--438},
  url = {https://www.usenix.org/conference/atc14/technical-sessions/presentation/lantz},
  publisher = {{USENIX} Association}
}

@inproceedings{detectable2021li,
author = {Li, Nan and Golab, Wojciech},
title = {Brief Announcement: Detectable Sequential Specifications for Recoverable Shared Objects},
year = {2021},
isbn = {9781450385480},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3465084.3467943},
doi = {10.1145/3465084.3467943},
abstract = {The recent commercial release of persistent main memory by Intel has sparked intense interest in recoverable concurrent objects. Specifying and implementing such objects is technically challenging on current generation hardware precisely because the top layers of the memory hierarchy (CPU registers and cache) remain volatile, which causes application threads to lose critical execution state during a failure. Friedman, Herlihy, Marathe, and Petrank (DISC'17) recently proposed that this difficulty can be alleviated by making the recoverable objects detectable, meaning that during recovery, they can resolve the status of an operation that was interrupted by a failure. In this paper, we formalize this important concept using a detectable sequential specification (DSS), which augments an object's interface with auxiliary methods that threads use to first declare their need for detectability, and then perform detection if needed after a failure. Compared to prior work on this topic, our DSS-based approach is less reliant on assumptions regarding the system, and more flexible in the sense that it allows applications to request detectability on demand. As a proof of concept, we present a detectable recoverable lock-free queue algorithm and evaluate its performance on a multiprocessor equipped with Intel Optane persistent memory. Our queue outperforms the detectable log queue of Friedman, Herlihy, Marthe, and Petrank (PPoPP'18) by up to 1.7x.},
booktitle = {Proceedings of the 2021 ACM Symposium on Principles of Distributed Computing},
pages = {557--560},
numpages = {4},
keywords = {concurrency, persistent memory, shared memory, fault tolerance, detectability},
location = {Virtual Event, Italy},
series = {PODC'21}
}


@inproceedings{makalubhandari2016,
author = {Bhandari, Kumud and Chakrabarti, Dhruva R. and Boehm, Hans-J.},
title = {Makalu: Fast Recoverable Allocation of Non-Volatile Memory},
year = {2016},
isbn = {9781450344449},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2983990.2984019},
doi = {10.1145/2983990.2984019},
booktitle = {Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {677--694},
numpages = {18},
keywords = {persistent memory management, garbage collection, deallocation, allocation, non-volatile memory},
location = {Amsterdam, Netherlands},
series = {OOPSLA 2016}
}


@article{objectcohen2018,
author = {Cohen, Nachshon and Aksun, David T. and Larus, James R.},
title = {Object-Oriented Recovery for Non-Volatile Memory},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276523},
doi = {10.1145/3276523},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {153},
numpages = {22},
keywords = {object-oriented programming, NVM, non-volatile memory, programming model, C++}
}

@inproceedings{logdavid2018,
author = {David, Tudor and Dragojevi\'{c}, Aleksandar and Guerraoui, Rachid and Zablotchi, Igor},
title = {Log-Free Concurrent Data Structures},
year = {2018},
isbn = {9781931971447},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 2018 USENIX Conference on Usenix Annual Technical Conference},
pages = {373--385},
numpages = {13},
location = {Boston, MA, USA},
series = {USENIX ATC '18}
}

@inproceedings{understandingcai2020,
author = {Cai, Wentao and Wen, Haosen and Beadle, H. Alan and Kjellqvist, Chris and Hedayati, Mohammad and Scott, Michael L.},
title = {Understanding and Optimizing Persistent Memory Allocation},
year = {2020},
isbn = {9781450375665},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3381898.3397212},
doi = {10.1145/3381898.3397212},
booktitle = {Proceedings of the 2020 ACM SIGPLAN International Symposium on Memory Management},
pages = {60--73},
numpages = {14},
keywords = {garbage collection, dynamic memory allocation, lock freedom, nonvolatile memory, persistent pointer},
location = {London, UK},
series = {ISMM 2020}
}

@inproceedings{wholenarayanan2012,
author = {Narayanan, Dushyanth and Hodson, Orion},
title = {Whole-System Persistence},
year = {2012},
isbn = {9781450307598},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2150976.2151018},
doi = {10.1145/2150976.2151018},
booktitle = {Proceedings of the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {401--410},
numpages = {10},
keywords = {NVRAM, persistence},
location = {London, England, UK},
series = {ASPLOS XVII}
}

@article{storagepelley2013,
author = {Pelley, Steven and Wenisch, Thomas F. and Gold, Brian T. and Bridge, Bill},
title = {Storage Management in the NVRAM Era},
year = {2013},
issue_date = {October 2013},
publisher = {VLDB Endowment},
volume = {7},
number = {2},
issn = {2150-8097},
url = {https://doi.org/10.14778/2732228.2732231},
doi = {10.14778/2732228.2732231},
journal = {Proc. VLDB Endow.},
month = oct,
pages = {121--132},
numpages = {12}
}

@inproceedings{empiricallee2014,
author = {Lee, Eunji and Bahn, Hyokyung and Yoo, Seunghoon and Noh, Sam},
year = {2014},
month = {09},
pages = {405-410},
publisher= {Institute of Electrical and Electronics Engineers},
address = {Paris, France},
booktitle= {22nd International Symposium on Modelling, Analysis \& Simulation of Computer and Telecommunication Systems},
title = {Empirical Study of NVM Storage: An Operating System's Perspective and Implications},
doi = {10.1109/MASCOTS.2014.56}
}

@inproceedings{studyzhang2015,
author = {Zhang, Yiying and Swanson, Steven},
year = {2015},
month = {05},
pages = {1-10},
publisher= {Institute of Electrical and Electronics Engineers},
address = {Santa Clara, CA, USA},
booktitle= {31st Symposium on Mass Storage Systems and Technologies (MSST)},
title = {A study of application performance with non-volatile main memory},
doi = {10.1109/MSST.2015.7208275}
}

@inproceedings{systemdulloor2014,
author = {Dulloor, Subramanya R. and Kumar, Sanjay and Keshavamurthy, Anil and Lantz, Philip and Reddy, Dheeraj and Sankaran, Rajesh and Jackson, Jeff},
title = {System Software for Persistent Memory},
year = {2014},
isbn = {9781450327046},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2592798.2592814},
doi = {10.1145/2592798.2592814},
booktitle = {Proceedings of the Ninth European Conference on Computer Systems},
articleno = {15},
numpages = {15},
location = {Amsterdam, The Netherlands},
series = {EuroSys '14}
}

@inproceedings {highharendra2017,
author = {Harendra Kumar and Yuvraj Patel and Ram Kesavan and Sumith Makam},
title = {High Performance Metadata Integrity Protection in the {WAFL} Copy-on-Write File System},
booktitle = {15th {USENIX} Conference on File and Storage Technologies ({FAST} 17)},
year = {2017},
isbn = {978-1-931971-36-2},
address = {Santa Clara, CA},
pages = {197--212},
url = {https://www.usenix.org/conference/fast17/technical-sessions/presentation/kumar},
publisher = {{USENIX} Association},
month = feb,
}

@inproceedings{stratakwon2017,
author = {Kwon, Youngjin and Fingler, Henrique and Hunt, Tyler and Peter, Simon and Witchel, Emmett and Anderson, Thomas},
title = {Strata: A Cross Media File System},
year = {2017},
isbn = {9781450350853},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3132747.3132770},
doi = {10.1145/3132747.3132770},
booktitle = {Proceedings of the 26th Symposium on Operating Systems Principles},
pages = {460--477},
numpages = {18},
keywords = {Multi-layer storage, File system, Non-volatile memory},
location = {Shanghai, China},
series = {SOSP '17}
}

@inproceedings {octopusyouyou2017,
author = {Youyou Lu and Jiwu Shu and Youmin Chen and Tao Li},
title = {Octopus: an RDMA-enabled Distributed Persistent Memory File System},
booktitle = {2017 {USENIX} Annual Technical Conference ({USENIX} {ATC} 17)},
year = {2017},
isbn = {978-1-931971-38-6},
address = {Santa Clara, CA},
pages = {773--785},
url = {https://www.usenix.org/conference/atc17/technical-sessions/presentation/lu},
publisher = {{USENIX} Association},
month = jul,
}

@inproceedings{aerievolos2014,
author = {Volos, Haris and Nalli, Sanketh and Panneerselvam, Sankarlingam and Varadarajan, Venkatanathan and Saxena, Prashant and Swift, Michael M.},
title = {Aerie: Flexible File-System Interfaces to Storage-Class Memory},
year = {2014},
isbn = {9781450327046},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2592798.2592810},
doi = {10.1145/2592798.2592810},
booktitle = {Proceedings of the Ninth European Conference on Computer Systems},
articleno = {14},
numpages = {14},
location = {Amsterdam, The Netherlands},
series = {EuroSys '14}
}

@INPROCEEDINGS{scmfswu2011,
  author={Wu, Xiaojian and Reddy, A. L. Narasimha},
  booktitle={SC '11: Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis}, 
  title={SCMFS: A file system for Storage Class Memory}, 
  year={2011},
  publisher={Institute of Electrical and Electronics Engineers},
  address={Seattle, WA, USA},
  volume={},
  number={},
  pages={1-11},
  doi={}}

@inproceedings{novaxu2016,
author = {Xu, Jian and Swanson, Steven},
title = {NOVA: A Log-Structured File System for Hybrid Volatile/Non-Volatile Main Memories},
year = {2016},
isbn = {9781931971287},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 14th Usenix Conference on File and Storage Technologies},
pages = {323--338},
numpages = {16},
location = {Santa Clara, CA},
series = {FAST'16}
}

@inproceedings{novafortisxu2017,
author = {Xu, Jian and Zhang, Lu and Memaripour, Amirsaman and Gangadharaiah, Akshatha and Borase, Amit and Da Silva, Tamires Brito and Swanson, Steven and Rudoff, Andy},
title = {NOVA-Fortis: A Fault-Tolerant Non-Volatile Main Memory File System},
year = {2017},
isbn = {9781450350853},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3132747.3132761},
doi = {10.1145/3132747.3132761},
booktitle = {Proceedings of the 26th Symposium on Operating Systems Principles},
pages = {478--496},
numpages = {19},
keywords = {Reliability, DAX, File Systems, Direct Access, Non-volatile Memory, Persistent Memory},
location = {Shanghai, China},
series = {SOSP '17}
}

@inproceedings{howarulraj2017,
author = {Arulraj, Joy and Pavlo, Andrew},
title = {How to Build a Non-Volatile Memory Database Management System},
year = {2017},
isbn = {9781450341974},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3035918.3054780},
doi = {10.1145/3035918.3054780},
booktitle = {Proceedings of the 2017 ACM International Conference on Management of Data},
pages = {1753--1758},
numpages = {6},
keywords = {database management systems, non-volatile memory},
location = {Chicago, Illinois, USA},
series = {SIGMOD '17}
}

@inproceedings{persistentmarathe2017,
author = {Marathe, Virendra J. and Seltzer, Margo and Byan, Steve and Harris, Tim},
title = {Persistent Memcached: Bringing Legacy Code to Byte-Addressable Persistent Memory},
year = {2017},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 9th USENIX Conference on Hot Topics in Storage and File Systems},
pages = {4},
numpages = {1},
location = {Santa Clara, CA},
series = {HotStorage'17}
}

@INPROCEEDINGS{udornchen2017,
  author={Chen, Xianzhang and Sha, Edwin H.-M. and Abdullah, Ahmad and Zhuge, Qingfeng and Wu, Lin and Yang, Chaoshu and Jiang, Weiwen},
  booktitle={2017 IEEE 6th Non-Volatile Memory Systems and Applications Symposium (NVMSA)}, 
  title={UDORN: A design framework of persistent in-memory key-value database for NVM}, 
  year={2017},
  publisher={Institute of Electrical and Electronics Engineers},
  address={Hsinchu, Taiwan},
  volume={},
  number={},
  pages={1-6},
  doi={10.1109/NVMSA.2017.8064478}}

@inproceedings{nvmcachedwu2016,
author = {Wu, Xingbo and Ni, Fan and Zhang, Li and Wang, Yandong and Ren, Yufei and Hack, Michel and Shao, Zili and Jiang, Song},
title = {NVMcached: An NVM-Based Key-Value Cache},
year = {2016},
isbn = {9781450342650},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2967360.2967374},
doi = {10.1145/2967360.2967374},
booktitle = {Proceedings of the 7th ACM SIGOPS Asia-Pacific Workshop on Systems},
articleno = {18},
numpages = {7},
location = {Hong Kong, Hong Kong},
series = {APSys '16}
}

@inproceedings{hikvxia2017,
author = {Xia, Fei and Jiang, Dejun and Xiong, Jin and Sun, Ninghui},
title = {HiKV: A Hybrid Index Key-Value Store for DRAM-NVM Memory Systems},
year = {2017},
isbn = {9781931971386},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 2017 USENIX Conference on Usenix Annual Technical Conference},
pages = {349--362},
numpages = {14},
location = {Santa Clara, CA, USA},
series = {USENIX ATC '17}
}

@article{persistentchen2015,
author = {Chen, Shimin and Jin, Qin},
title = {Persistent B+-Trees in Non-Volatile Main Memory},
year = {2015},
issue_date = {February 2015},
publisher = {VLDB Endowment},
volume = {8},
number = {7},
issn = {2150-8097},
url = {https://doi.org/10.14778/2752939.2752947},
doi = {10.14778/2752939.2752947},
journal = {Proc. VLDB Endow.},
month = feb,
pages = {786--797},
numpages = {12}
}

@inproceedings{fastongaro2011,
author = {Ongaro, Diego and Rumble, Stephen M. and Stutsman, Ryan and Ousterhout, John and Rosenblum, Mendel},
title = {Fast Crash Recovery in RAMCloud},
year = {2011},
isbn = {9781450309776},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2043556.2043560},
doi = {10.1145/2043556.2043560},
booktitle = {Proceedings of the Twenty-Third ACM Symposium on Operating Systems Principles},
pages = {29--41},
numpages = {13},
keywords = {storage systems, crash recovery, main memory databases, scalability},
location = {Cascais, Portugal},
series = {SOSP '11}
}

@inproceedings{nvtreeyang2015,
author = {Yang, Jun and Wei, Qingsong and Chen, Cheng and Wang, Chundong and Yong, Khai Leong and He, Bingsheng},
title = {NV-Tree: Reducing Consistency Cost for NVM-Based Single Level Systems},
year = {2015},
isbn = {9781931971201},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 13th USENIX Conference on File and Storage Technologies},
pages = {167--181},
numpages = {15},
location = {Santa Clara, CA},
series = {FAST'15}
}

@inproceedings{fptreeoukid2016,
author = {Oukid, Ismail and Lasperas, Johan and Nica, Anisoara and Willhalm, Thomas and Lehner, Wolfgang},
title = {FPTree: A Hybrid SCM-DRAM Persistent and Concurrent B-Tree for Storage Class Memory},
year = {2016},
isbn = {9781450335317},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2882903.2915251},
doi = {10.1145/2882903.2915251},
booktitle = {Proceedings of the 2016 International Conference on Management of Data},
pages = {371--386},
numpages = {16},
keywords = {hardware transactional memory, data structures, data management, database recovery, storage class memory, B-tree},
location = {San Francisco, California, USA},
series = {SIGMOD '16}
}

@inproceedings{consistentvenkataraman2011,
author = {Venkataraman, Shivaram and Tolia, Niraj and Ranganathan, Parthasarathy and Campbell, Roy H.},
title = {Consistent and Durable Data Structures for Non-Volatile Byte-Addressable Memory},
year = {2011},
isbn = {9781931971829},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 9th USENIX Conference on File and Stroage Technologies},
pages = {5},
numpages = {1},
location = {San Jose, California},
series = {FAST'11}
}

@article{hinfschen2018,
author = {Chen, Youmin and Shu, Jiwu and Ou, Jiaxin and Lu, Youyou},
title = {HiNFS: A Persistent Memory File System with Both Buffering and Direct-Access},
year = {2018},
issue_date = {April 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {1},
issn = {1553-3077},
url = {https://doi.org/10.1145/3204454},
doi = {10.1145/3204454},
journal = {ACM Trans. Storage},
month = apr,
articleno = {4},
numpages = {30},
keywords = {direct access, file system, buffering, Persistent memory}
}

@article{dptreezhou2019,
author = {Zhou, Xinjing and Shou, Lidan and Chen, Ke and Hu, Wei and Chen, Gang},
title = {DPTree: Differential Indexing for Persistent Memory},
year = {2019},
issue_date = {December 2019},
publisher = {VLDB Endowment},
volume = {13},
number = {4},
issn = {2150-8097},
url = {https://doi.org/10.14778/3372716.3372717},
doi = {10.14778/3372716.3372717},
journal = {Proc. VLDB Endow.},
month = dec,
pages = {421--434},
numpages = {14}
}

@inproceedings {slmdbolzhas2019,
author = {Olzhas Kaiyrakhmet and Songyi Lee and Beomseok Nam and Sam H. Noh and Young-ri Choi},
title = {SLM-DB: Single-Level Key-Value Store with Persistent Memory},
booktitle = {17th {USENIX} Conference on File and Storage Technologies ({FAST} 19)},
year = {2019},
isbn = {978-1-939133-09-0},
address = {Boston, MA},
pages = {191--205},
url = {https://www.usenix.org/conference/fast19/presentation/kaiyrakhmet},
publisher = {{USENIX} Association},
month = feb,
}

@inproceedings{dudetmliu2017,
author = {Liu, Mengxing and Zhang, Mingxing and Chen, Kang and Qian, Xuehai and Wu, Yongwei and Zheng, Weimin and Ren, Jinglei},
title = {DudeTM: Building Durable Transactions with Decoupling for Persistent Memory},
year = {2017},
isbn = {9781450344654},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3037697.3037714},
doi = {10.1145/3037697.3037714},
booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {329--343},
numpages = {15},
keywords = {transactional memory, emerging memory technologies, storage systems},
location = {Xi'an, China},
series = {ASPLOS '17}
}

@article{b3treecha2020,
author = {Cha, Hokeun and Nam, Moohyeon and Jin, Kibeom and Seo, Jiwon and Nam, Beomseok},
title = {B3-Tree: Byte-Addressable Binary B-Tree for Persistent Memory},
year = {2020},
issue_date = {August 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {3},
issn = {1553-3077},
url = {https://doi.org/10.1145/3394025},
doi = {10.1145/3394025},
journal = {ACM Trans. Storage},
month = jul,
articleno = {17},
numpages = {27},
keywords = {data structure, Non-volatile memory, persistent indexing}
}

@inproceedings{splitfskadekodi2019,
author = {Kadekodi, Rohan and Lee, Se Kwon and Kashyap, Sanidhya and Kim, Taesoo and Kolli, Aasheesh and Chidambaram, Vijay},
title = {SplitFS: Reducing Software Overhead in File Systems for Persistent Memory},
year = {2019},
isbn = {9781450368735},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3341301.3359631},
doi = {10.1145/3341301.3359631},
booktitle = {Proceedings of the 27th ACM Symposium on Operating Systems Principles},
pages = {494--508},
numpages = {15},
keywords = {crash consistency, file systems, persistent memory, direct access},
location = {Huntsville, Ontario, Canada},
series = {SOSP '19}
}

@inproceedings{flatstorechen2020,
author = {Chen, Youmin and Lu, Youyou and Yang, Fan and Wang, Qing and Wang, Yang and Shu, Jiwu},
title = {FlatStore: An Efficient Log-Structured Key-Value Storage Engine for Persistent Memory},
year = {2020},
isbn = {9781450371025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373376.3378515},
doi = {10.1145/3373376.3378515},
booktitle = {Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {1077--1091},
numpages = {15},
keywords = {persistent memory, key-value store, batching, log structure},
location = {Lausanne, Switzerland},
series = {ASPLOS '20}
}

@INPROCEEDINGS{efficientjoeng2018,
  author={Jeong, Jungi and Park, Chang Hyun and Huh, Jaehyuk and Maeng, Seungryoul},
  booktitle={2018 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)}, 
  title={Efficient Hardware-Assisted Logging with Asynchronous and Direct-Update for Persistent Memory}, 
  publisher = {Institute of Electrical and Electronics Engineers},
  address={Fukuoka, Japan},
  year={2018},
  volume={},
  number={},
  pages={520-532},
  doi={10.1109/MICRO.2018.00049}}

@article{lospemli2020,
author = {Li, Sumin and Huang, Linpeng},
title = {LosPem: A Novel Log-Structured Framework for Persistent Memory},
year = {2020},
issue_date = {July 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {3},
issn = {1550-4832},
url = {https://doi.org/10.1145/3379932},
doi = {10.1145/3379932},
journal = {J. Emerg. Technol. Comput. Syst.},
month = may,
articleno = {27},
numpages = {17},
keywords = {Persistent memory, memory-storage hierarchy, data consistency}
}

@article{nvlsmzhang2021,
author = {Zhang, Baoquan and Du, David H. C.},
title = {NVLSM: A Persistent Memory Key-Value Store Using Log-Structured Merge Tree with Accumulative Compaction},
year = {2021},
issue_date = {August 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {17},
number = {3},
issn = {1553-3077},
url = {https://doi.org/10.1145/3453300},
doi = {10.1145/3453300},
journal = {ACM Trans. Storage},
month = aug,
articleno = {23},
numpages = {26},
keywords = {key-value store, Non-volatile memory, log-structured merge tree}
}

@inproceedings{chameleondbzhang2021,
author = {Zhang, Wenhui and Zhao, Xingsheng and Jiang, Song and Jiang, Hong},
title = {ChameleonDB: A Key-Value Store for Optane Persistent Memory},
year = {2021},
isbn = {9781450383349},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3447786.3456237},
doi = {10.1145/3447786.3456237},
booktitle = {Proceedings of the Sixteenth European Conference on Computer Systems},
pages = {194--209},
numpages = {16},
keywords = {Optane DC, key-value store, persistent-memory},
location = {Online Event, United Kingdom},
series = {EuroSys '21}
}

@INPROCEEDINGS{forcahuang2018,
  author={Huang, Haixin and Huang, Kaixin and You, Litong and Huang, Linpeng},
  booktitle={2018 IEEE 36th International Conference on Computer Design (ICCD)}, 
  title={Forca: Fast and Atomic Remote Direct Access to Persistent Memory}, 
  publisher = {Institute of Electrical and Electronics Engineers},
  address={Orlando, FL, USA},
  year={2018},
  volume={},
  number={},
  pages={246-249},
  doi={10.1109/ICCD.2018.00045}}

@inproceedings{NV-heaps,
author = {Coburn, Joel and Caulfield, Adrian M. and Akel, Ameen and Grupp, Laura M. and Gupta, Rajesh K. and Jhala, Ranjit and Swanson, Steven},
title = {NV-Heaps: Making Persistent Objects Fast and Safe with next-Generation, Non-Volatile Memories},
year = {2011},
isbn = {9781450302661},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1950365.1950380},
doi = {10.1145/1950365.1950380},
pages = {105--118},
numpages = {14},
keywords = {acid transactions, persistent objects, pointer safety, non-volatile heap, transactional memory, phase-change memory, memory mangement, spin-torque transfer memory},
location = {Newport Beach, California, USA},
booktitle = {ASPLOS XVI}
}

@inproceedings{pmbugassist,
author = {Huang, Zunchen and Wang, Chao},
title = {Constraint Based Program Repair for Persistent Memory Bugs},
year = {2024},
isbn = {9798400702174},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3597503.3639204},
doi = {10.1145/3597503.3639204},
booktitle = {Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
articleno = {91},
numpages = {12},
location = {Lisbon, Portugal},
series = {ICSE '24}
}

@inproceedings{pminvariant,
author = {Huang, Zunchen and Ravi, Srivatsan and Wang, Chao},
title = {Discovering Likely Program Invariants for Persistent Memory},
year = {2024},
isbn = {9798400712487},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3691620.3695544},
doi = {10.1145/3691620.3695544},
abstract = {We propose a method for automatically discovering likely program invariants for persistent memory (PM), which is a type of fast and byte-addressable storage device that can retain data after power loss. The invariants, also called PM properties or PM requirements, specify which objects of the program should be made persistent and in what order. Our method relies on a combination of static and dynamic analysis techniques. Specifically, it relies on static analysis to compute dependence relations between LOAD/STORE instructions and instruments the information into the executable program. Then, it relies on dynamic analysis of the execution traces and counterfactual reasoning to infer PM properties. With precisely computed dependence relations, the inferred properties are necessary conditions for the program to behave correctly through power loss and recovery; with imprecise dependence relations, these are likely program invariants. We have evaluated our method on benchmark programs including eight persistent data structures and two distributed storage applications, Redis and Memcached. The results show that our method can infer PM properties quickly and these properties are of higher quality than those inferred by a state-of-the-art technique. We also demonstrate the usefulness of the inferred properties by leveraging them for PM bug detection, which significantly improves the performance of a state-of-the-art PM bug detection technique.},
booktitle = {Proceedings of the 39th IEEE/ACM International Conference on Automated Software Engineering},
pages = {1795–1807},
numpages = {13},
location = {Sacramento, CA, USA},
series = {ASE '24}
}


@inproceedings{highperformancekolli2016,
author = {Kolli, Aasheesh and Pelley, Steven and Saidi, Ali and Chen, Peter M. and Wenisch, Thomas F.},
title = {High-Performance Transactions for Persistent Memories},
year = {2016},
isbn = {9781450340915},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2872362.2872381},
doi = {10.1145/2872362.2872381},
booktitle = {Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {399--411},
numpages = {13},
keywords = {non-volatile memory, transactions, memory persistency, recoverability},
location = {Atlanta, Georgia, USA},
series = {ASPLOS '16}
}

@inproceedings{mnemosynevolos2011,
author = {Volos, Haris and Tack, Andres Jaan and Swift, Michael M.},
title = {Mnemosyne: Lightweight Persistent Memory},
year = {2011},
isbn = {9781450302661},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1950365.1950379},
doi = {10.1145/1950365.1950379},
booktitle = {Proceedings of the Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {91--104},
numpages = {14},
keywords = {storage-class memory, persistence, performance, memory transactions, persistent memory},
location = {Newport Beach, California, USA},
series = {ASPLOS XVI}
}


@Article{inkha2020,
AUTHOR = {Ha, Minjong and Kim, Sang-Hoon},
TITLE = {InK: In-Kernel Key-Value Storage with Persistent Memory},
JOURNAL = {Electronics},
VOLUME = {9},
YEAR = {2020},
NUMBER = {11},
ARTICLE-NUMBER = {1913},
URL = {https://www.mdpi.com/2079-9292/9/11/1913},
ISSN = {2079-9292},
numpages={22},
DOI = {10.3390/electronics9111913}
}

@inproceedings {pangolinlu2019,
author = {Lu Zhang and Steven Swanson},
title = {Pangolin: A Fault-Tolerant Persistent Memory Programming Library},
booktitle = {2019 {USENIX} Annual Technical Conference ({USENIX} {ATC} 19)},
year = {2019},
isbn = {978-1-939133-03-8},
address = {Renton, WA},
pages = {897--912},
url = {https://www.usenix.org/conference/atc19/presentation/zhang-lu},
publisher = {{USENIX} Association},
month = jul,
}

@INPROCEEDINGS{thynvmren2015,
  author={Ren, Jinglei and Zhao, Jishen and Khan, Samira and Choi, Jongmoo and Wu, Yongwei and Mutiu, Onur},
  booktitle={2015 48th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)}, 
  title={ThyNVM: Enabling software-transparent crash consistency in persistent memory systems}, 
  year={2015},
  volume={},
  number={},
  publisher = {Institute of Electrical and Electronics Engineers},
  address={Waikiki, HI, USA},
  pages={672-685},
  doi={10.1145/2830772.2830802}}
  
@inproceedings {gopmemjerrin2020,
author = {Jerrin Shaji George and Mohit Verma and Rajesh Venkatasubramanian and Pratap Subrahmanyam},
title = {go-pmem: Native Support for Programming Persistent Memory in Go},
booktitle = {2020 {USENIX} Annual Technical Conference ({USENIX} {ATC} 20)},
year = {2020},
isbn = {978-1-939133-14-4},
pages = {859--872},
address = {Boston, MA, USA},
url = {https://www.usenix.org/conference/atc20/presentation/george},
publisher = {{USENIX} Association},
month = jul,
}

@article{libpmmarmol2018,
author = {Marmol, Leonardo and Chowdhury, Mohammad and Rangaswami, Raju},
title = {LibPM: Simplifying Application Usage of Persistent Memory},
year = {2018},
issue_date = {December 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {4},
issn = {1553-3077},
url = {https://doi.org/10.1145/3278141},
doi = {10.1145/3278141},
journal = {ACM Trans. Storage},
month = dec,
articleno = {34},
numpages = {18},
keywords = {application persistence, next-generation applications, Persistent memory}
}

@inproceedings{hippocrates-asplos21,
author = {Neal, Ian and Quinn, Andrew and Kasikci, Baris},
title = {Hippocrates: Healing Persistent Memory Bugs without Doing Any Harm},
year = {2021},
isbn = {9781450383172},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3445814.3446694},
doi = {10.1145/3445814.3446694},
booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {401--414},
numpages = {14},
keywords = {persistent memory, program repair},
location = {Virtual, USA},
series = {ASPLOS 2021}
}

@inproceedings{corundum-asplos21,
author = {Hoseinzadeh, Morteza and Swanson, Steven},
title = {Corundum: Statically-Enforced Persistent Memory Safety},
year = {2021},
isbn = {9781450383172},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3445814.3446710},
doi = {10.1145/3445814.3446710},
booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {429--442},
numpages = {14},
keywords = {crash-consistent programming, non-volatile memory programming library, static bug detection},
location = {Virtual, USA},
series = {ASPLOS 2021}
}

@inproceedings{flit,
author = {Wei, Yuanhao and Ben-David, Naama and Friedman, Michal and Blelloch, Guy E. and Petrank, Erez},
title = {{FliT}: A library for simple and efficient persistent algorithms},
year = {2022},
isbn = {9781450392044},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3503221.3508436},
doi = {10.1145/3503221.3508436},
abstract = {Non-volatile random access memory (NVRAM) offers byte-addressable persistence at speeds comparable to DRAM. However, with caches remaining volatile, automatic cache evictions can reorder updates to memory, potentially leaving persistent memory in an inconsistent state upon a system crash. Flush and fence instructions can be used to force ordering among updates, but are expensive. This has motivated significant work studying how to write correct and efficient persistent programs for NVRAM.In this paper, we present FliT, a C++ library that facilitates writing efficient persistent code. Using the library's default mode makes any linearizable data structure durable with minimal changes to the code. FliT avoids many redundant flush instructions by using a novel algorithm to track dirty cache lines. It also allows for extra optimizations, but achieves good performance even in its default setting.To describe the FliT library's capabilities and guarantees, we define a persistent programming interface, called the P-V Interface, which FliT implements. The P-V Interface captures the expected behavior of code in which some instructions' effects are persisted and some are not. We show that the interface captures the desired semantics of many practical algorithms in the literature.We apply the FliT library to four different persistent data structures, and show that across several workloads, persistence implementations, and data structure sizes, the FliT library always improves operation throughput, by at least 2.1X over a naive implementation in all but one workload.},
booktitle = {Proceedings of the 27th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {309–321},
numpages = {13},
keywords = {concurrent data structures, non-volatile memory, recoverability},
location = {Seoul, Republic of Korea},
series = {PPoPP '22}
}

@inproceedings{pmfuzz-asplos21,
author = {Liu, Sihang and Mahar, Suyash and Ray, Baishakhi and Khan, Samira},
title = {PMFuzz: Test Case Generation for Persistent Memory Programs},
year = {2021},
isbn = {9781450383172},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3445814.3446691},
doi = {10.1145/3445814.3446691},
booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {487--502},
numpages = {16},
keywords = {Testing, Fuzzing, Crash Consistency, Persistent Memory, Debugging},
location = {Virtual, USA},
series = {ASPLOS 2021}
}

@inproceedings{pmdebugger-asplos21,
author = {Di, Bang and Liu, Jiawen and Chen, Hao and Li, Dong},
title = {Fast, Flexible, and Comprehensive Bug Detection for Persistent Memory Programs},
year = {2021},
isbn = {9781450383172},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3445814.3446744},
doi = {10.1145/3445814.3446744},
booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {503--516},
numpages = {14},
keywords = {Testing, Crash Consistency, Debugging, Persistent Memory},
location = {Virtual, USA},
series = {ASPLOS 2021}
}

@InProceedings{decidingbouajjani2011,
author="Bouajjani, Ahmed
and Meyer, Roland
and M{\"o}hlmann, Eike",
editor="Aceto, Luca
and Henzinger, Monika
and Sgall, Ji{\v{r}}{\'i}",
title="Deciding Robustness against Total Store Ordering",
booktitle="Automata, Languages and Programming",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="428--440",
isbn="978-3-642-22012-8"
}


@inbook{lazy2020dananjaya,
author = {Dananjaya, Mahesh and Gavrielatos, Vasilis and Joshi, Arpit and Nagarajan, Vijay},
title = {Lazy Release Persistency},
year = {2020},
isbn = {9781450371025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373376.3378481},
abstract = {Fast non-volatile memory (NVM) has sparked interest in log-free data structures (LFDs) that enable crash recovery without the overhead of logging. However, recovery hinges on primitives that provide guarantees on what remains in NVM upon a crash. While ordering and atomicity are two well-understood primitives, we focus on ordering and its efficacy in enabling recovery of LFDs. We identify that one-sided persist barriers of acquire-release persistency (ARP)--the state-of-the-art ordering primitive and its microarchitectural implementation--are not strong enough to enable recovery of an LFD. Therefore, correct recovery necessitates the inclusion of the more expensive full barriers. In this paper, we propose strengthening the one-sided barrier semantics of ARP. The resulting persistency model, release persistency (RP), guarantees that NVM will hold a consistent-cut of the execution upon a crash, thereby satisfying the criterion for correct recovery of an LFD. We then propose lazy release persistency (LRP), a microarchitectural mechanism for efficiently enforcing RP's one-sided barriers. Our evaluation on 5 commonly used LFDs suggests that LRP provides a 14%-44% performance improvement over the state-of-the-art full barrier.},
booktitle = {Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {1173--1186},
numpages = {14}
}


@InProceedings{linearizability2016izraelevitz,
author="Izraelevitz, Joseph
and Mendes, Hammurabi
and Scott, Michael L.",
editor="Gavoille, Cyril
and Ilcinkas, David",
title="Linearizability of Persistent Memory Objects Under a Full-System-Crash Failure Model",
booktitle="Distributed Computing",
year="2016",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="313--327",
abstract="This paper provides a theoretical and practical framework for crash-resilient data structures on a machine with persistent (nonvolatile) memory but transient registers and cache. In contrast to certain prior work, but in keeping with ``real world'' systems, we assume a full-system failure model, in which all transient state (of all processes) is lost on a crash. We introduce the notion of durable linearizability to govern the safety of concurrent objects under this failure model and a corresponding relaxed, buffered variant which ensures that the persistent state in the event of a crash is consistent but not necessarily upÂ to date.",
isbn="978-3-662-53426-7"
}


@article{linearizabilityherlihy1990,
author = {Herlihy, Maurice P. and Wing, Jeannette M.},
title = {Linearizability: A Correctness Condition for Concurrent Objects},
year = {1990},
issue_date = {July 1990},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/78969.78972},
doi = {10.1145/78969.78972},
journal = {ACM Trans. Program. Lang. Syst.},
month = jul,
pages = {463--492},
numpages = {30}
}

@inproceedings{automoou2015,
author = {Ou, Peizhao and Demsky, Brian},
title = {AutoMO: Automatic Inference of Memory Order Parameters for C/C++11},
year = {2015},
isbn = {9781450336895},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2814270.2814286},
doi = {10.1145/2814270.2814286},
booktitle = {Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {221--240},
numpages = {20},
keywords = {Relaxed Memory Model, Sequential Consistency},
location = {Pittsburgh, PA, USA},
series = {OOPSLA 2015}
}

@inproceedings{robustnesslahav2019,
author = {Lahav, Ori and Margalit, Roy},
title = {Robustness against Release/Acquire Semantics},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314604},
doi = {10.1145/3314221.3314604},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {126--141},
numpages = {16},
keywords = {C/C++11, release/acquire, robustness, weak memory models},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}

@inproceedings{patternmeshman2015,
author = {Meshman, Yuri and Rinetzky, Noam and Yahav, Eran},
title = {Pattern-Based Synthesis of Synchronization for the C++ Memory Model},
year = {2015},
isbn = {9780983567851},
publisher = {FMCAD Inc},
address = {Austin, Texas},
booktitle = {Proceedings of the 15th Conference on Formal Methods in Computer-Aided Design},
pages = {120--127},
numpages = {8},
location = {Austin, Texas},
series = {FMCAD '15}
}

@inproceedings{reasoningowens2010,
author = {Owens, Scott},
title = {Reasoning about the Implementation of Concurrency Abstractions on X86-TSO},
year = {2010},
isbn = {3642141064},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 24th European Conference on Object-Oriented Programming},
pages = {478--503},
numpages = {26},
location = {Maribor, Slovenia},
series = {ECOOP'10}
}

@article{tamingkhyzha2021,
author = {Khyzha, Artem and Lahav, Ori},
title = {Taming X86-TSO Persistency},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434328},
doi = {10.1145/3434328},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {47},
numpages = {29},
keywords = {x86-TSO, non-volatile memory, persistency, weak memory models, concurrency}
}

@INPROCEEDINGS{nv-htm,
author = {Daniel Castro and Paolo Romano and Jo{\~a}o Barreto},
booktitle = {2018 IEEE International Parallel and Distributed Processing Symposium},
title = {{Hardware transactional memory meets memory persistency}},
year = {2018},
number = {},
publisher = {Institute of Electrical and Electronics Engineers},
address={Vancouver, BC, Canada},
pages = {368--377},
series = {IPDPS '18}
}

@inbook{clobbernvm,
author = {Xu, Yi and Izraelevitz, Joseph and Swanson, Steven},
title = {Clobber-{NVM}: Log Less, Re-Execute More},
year = {2021},
isbn = {9781450383172},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3445814.3446730},
booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {346--359},
numpages = {14}
}

@inproceedings{crafty-pldi20,
author = {Gen\c{c}, Kaan and Bond, Michael D. and Xu, Guoqing Harry},
title = {Crafty: Efficient, {HTM}-Compatible Persistent Transactions},
year = {2020},
isbn = {9781450376136},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3385412.3385991},
doi = {10.1145/3385412.3385991},
abstract = {Byte-addressable persistent memory, such as Intel/Micron 3D XPoint, is an emerging technology that bridges the gap between volatile memory and persistent storage. Data in persistent memory survives crashes and restarts; however, it is challenging to ensure that this data is consistent after failures. Existing approaches incur significant performance costs to ensure crash consistency. This paper introduces Crafty, a new approach for ensuring consistency and atomicity on persistent memory operations using commodity hardware with existing hardware transactional memory (HTM) capabilities, while incurring low overhead. Crafty employs a novel technique called nondestructive undo logging that leverages commodity HTM to control persist ordering. Our evaluation shows that Crafty outperforms state-of-the-art prior work under low contention, and performs competitively under high contention.},
booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {59--74},
numpages = {16},
keywords = {transactional memory, persistent transactions},
location = {London, UK},
series = {PLDI 2020}
}

@inproceedings{persistent-htm-giles-2017,
author = {Giles, Ellis and Doshi, Kshitij and Varman, Peter},
title = {Continuous Checkpointing of {HTM} Transactions in {NVM}},
year = {2017},
isbn = {9781450350440},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3092255.3092270},
doi = {10.1145/3092255.3092270},
abstract = { This paper addresses the challenges of coupling byte addressable non-volatile memory (NVM) and hardware transaction memory (HTM) in high-performance transaction processing. We first show that HTM transactions can be ordered using existing processor instructions without any hardware changes. In contrast, existing solutions posit changes to HTM mechanisms in the form of special instructions or modified functionality. We exploit the ordering mechanism to design a novel persistence method that decouples HTM concurrency from back-end NVM operations. Failure atomicity is achieved using redo logging coupled with aliasing to guard against mistimed cache evictions. Our algorithm uses efficient lock-free mechanisms with bounded static memory requirements. We evaluated our approach using both micro-benchmarks, and, benchmarks in the STAMP suite, and showed that it compares well with standard (volatile) HTM transactions. We also showed that it yields significant gains in throughput and latency in comparison with persistent transactional locking. },
booktitle = {Proceedings of the 2017 ACM SIGPLAN International Symposium on Memory Management},
pages = {70--81},
numpages = {12},
keywords = {TSX, Storage Class Memory, Checkpointing, Hardware Transactional Memory, HTM, Persistence, Lock-Free},
location = {Barcelona, Spain},
series = {ISMM 2017}
}

@inproceedings{dudetm,
author = {Liu, Mengxing and Zhang, Mingxing and Chen, Kang and Qian, Xuehai and Wu, Yongwei and Zheng, Weimin and Ren, Jinglei},
title = {{DudeTM}: Building Durable Transactions with Decoupling for Persistent Memory},
year = {2017},
isbn = {9781450344654},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3037697.3037714},
doi = {10.1145/3037697.3037714},
abstract = {Emerging non-volatile memory (NVM) offers non-volatility, byte-addressability and fast access at the same time. To make the best use of these properties, it has been shown by empirical evidence that programs should access NVM directly through CPU load and store instructions, so that the overhead of a traditional file system or database can be avoided. Thus, durable transactions become a common choice of applications for accessing persistent memory data in a crash consistent manner. However, existing durable transaction systems employ either undo logging, which requires a fence for every memory write, or redo logging, which requires intercepting all memory reads within transactions.This paper presents DUDETM, a crash-consistent durable transaction system that avoids the drawbacks of both undo logging and redo logging. DUDETM uses shadow DRAM to decouple the execution of a durable transaction into three fully asynchronous steps. The advantage is that only minimal fences and no memory read instrumentation are required. This design also enables an out-of-the-box transactional memory (TM) to be used as an independent component in our system. The evaluation results show that DUDETM adds durability to a TM system with only 7.4 ~ 24.6% throughput degradation. Compared to the existing durable transaction systems, DUDETM provides 1.7times to 4.4times higher throughput. Moreover, DUDETM can be implemented with existing hardware TMs with minor hardware modifications, leading to a further 1.7times speedup.},
booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {329--343},
numpages = {15},
keywords = {emerging memory technologies, storage systems, transactional memory},
location = {Xi'an, China},
series = {ASPLOS '17}
}

@inproceedings{atlas,
author = {Chakrabarti, Dhruva R. and Boehm, Hans-J. and Bhandari, Kumud},
title = {Atlas: Leveraging Locks for Non-Volatile Memory Consistency},
year = {2014},
isbn = {9781450325851},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2660193.2660224},
doi = {10.1145/2660193.2660224},
abstract = {Non-volatile main memory, such as memristors or phase change memory, can revolutionize the way programs persist data. In-memory objects can themselves be persistent without the need for a separate persistent data storage format. However, the challenge is to ensure that such data remains consistent if a failure occurs during execution.In this paper, we present our system, called Atlas, which adds durability semantics to lock-based code, typically allowing us to automatically maintain a globally consistent state even in the presence of failures. We identify failure-atomic sections of code based on existing critical sections and describe a log-based implementation that can be used to recover a consistent state after a failure. We discuss several subtle semantic issues and implementation tradeoffs. We confirm the ability to rapidly flush CPU caches as a core implementation bottleneck and suggest partial solutions. Experimental results confirm the practicality of our approach and provide insight into the overheads of such a system.},
booktitle = {Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages \& Applications},
pages = {433--452},
numpages = {20},
keywords = {transactions, persistence, consistency semantics, locks, durability, non-volatile memory, logging},
location = {Portland, Oregon, USA},
series = {OOPSLA '14}
}

@inproceedings{nvthreads,
author = {Hsu, Terry Ching-Hsiang and Br\"{u}gner, Helge and Roy, Indrajit and Keeton, Kimberly and Eugster, Patrick},
title = {{NVthreads}: Practical Persistence for Multi-Threaded Applications},
year = {2017},
isbn = {9781450349383},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3064176.3064204},
doi = {10.1145/3064176.3064204},
abstract = {Non-volatile memory technologies, such as memristor and phase-change memory, will allow programs to persist data with regular memory instructions. Liberated from the overhead to serialize and deserialize data to storage devices, programs can aim for high performance and still be crash fault-tolerant. Unfortunately, to leverage non-volatile memory, existing systems require hardware changes or extensive program modifications.We present NVthreads, a programming model and runtime that adds persistence to existing multi-threaded C/C++ programs. NVthreads is a drop-in replacement for the pthreads library and requires only tens of lines of program changes to leverage non-volatile memory. NVthreads infers consistent states via synchronization points, uses the process memory to buffer uncommitted changes, and logs writes to ensure a program's data is recoverable even after a crash. NVthreads' page level mechanisms result in good performance: applications that use NVthreads can be more than 2\texttimes{} faster than state-of-the-art systems that favor fine-grained tracking of writes. After a failure, iterative applications that use NVthreads gain speedups by resuming execution.},
booktitle = {Proceedings of the Twelfth European Conference on Computer Systems},
pages = {468--482},
numpages = {15},
location = {Belgrade, Serbia},
series = {EuroSys '17}
}

@inproceedings{justdo-logging,
author = {Izraelevitz, Joseph and Kelly, Terence and Kolli, Aasheesh},
title = {Failure-Atomic Persistent Memory Updates via {JUSTDO} Logging},
year = {2016},
isbn = {9781450340915},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2872362.2872410},
doi = {10.1145/2872362.2872410},
abstract = {Persistent memory invites applications to manipulate persistent data via load and store instructions. Because failures during updates may destroy transient data (e.g., in CPU registers), preserving data integrity in the presence of failures requires failure-atomic bundles of updates. Prior failure atomicity approaches for persistent memory entail overheads due to logging and CPU cache flushing. Persistent caches can eliminate the need for flushing, but conventional logging remains complex and memory intensive. We present the design and implementation of JUSTDO logging, a new failure atomicity mechanism that greatly reduces the memory footprint of logs, simplifies log management, and enables fast parallel recovery following failure. Crash-injection tests confirm that JUSTDO logging preserves application data integrity and performance evaluations show that it improves throughput 3x or more compared with a state-of-the-art alternative for a spectrum of data-intensive algorithms.},
booktitle = {Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {427--442},
numpages = {16},
keywords = {crash-resilience, persistent memory, transactions, failure-atomicity, non-volatile memory},
location = {Atlanta, Georgia, USA},
series = {ASPLOS '16}
}

@inproceedings{ido,
author = {Liu, Qingrui and Izraelevitz, Joseph and Lee, Se Kwon and Scott, Michael L. and Noh, Sam H. and Jung, Changhee},
title = {{iDO}: Compiler-Directed Failure Atomicity for Nonvolatile Memory},
year = {2018},
isbn = {9781538662403},
publisher = {Institute of Electrical and Electronics Engineers},
address={Virtual Event , Greece},
url = {https://doi.org/10.1109/MICRO.2018.00029},
doi = {10.1109/MICRO.2018.00029},
abstract = {This paper presents iDO, a compiler-directed approach to failure atomicity with nonvolatile memory. Unlike most prior work, which instruments each store of persistent data for redo or undo logging, the iDO compiler identifies idempotent instruction sequences, whose re-execution is guaranteed to be side-effect-free, thereby eliminating the need to log every persistent store. Using an extension of prior work on JUSTDO logging, the compiler then arranges, during recovery from failure, to back up each thread to the beginning of the current idempotent region and re-execute to the end of the current failure-atomic section. This extension transforms JUSTDO logging from a technique of value only on hypothetical future machines with nonvolatile caches into a technique that also significantly outperforms state-of-the art lock-based persistence mechanisms on current hardware during normal execution, while preserving very fast recovery times.},
booktitle = {Proceedings of the 51st Annual IEEE/ACM International Symposium on Microarchitecture},
pages = {258--270},
numpages = {13},
location = {Fukuoka, Japan},
series = {MICRO-51}
}

@inproceedings{persistency-sfr,
author = {Gogte, Vaibhav and Diestelhorst, Stephan and Wang, William and Narayanasamy, Satish and Chen, Peter M. and Wenisch, Thomas F.},
title = {Persistency for Synchronization-Free Regions},
year = {2018},
isbn = {9781450356985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3192366.3192367},
doi = {10.1145/3192366.3192367},
abstract = {Nascent persistent memory (PM) technologies promise the performance of DRAM with the durability of disk, but how best to integrate them into programming systems remains an open question. Recent work extends language memory models with a persistency model prescribing semantics for updates to PM. These semantics enable programmers to design data structures in PM that are accessed like memory and yet are recoverable upon crash or failure. Alas, we find the semantics and performance of existing approaches unsatisfying. Existing approaches require high-overhead mechanisms, are restricted to certain synchronization constructs, provide incomplete semantics, and/or may recover to state that cannot arise in fault-free execution. We propose persistency semantics that guarantee failure atomicity of synchronization-free regions (SFRs) - program regions delimited by synchronization operations. Our approach provides clear semantics for the PM state recovery code may observe and extends C++11's "sequential consistency for data-race-free" guarantee to post-failure recovery code. We investigate two designs for failure-atomic SFRs that vary in performance and the degree to which commit of persistent state may lag execution. We demonstrate both approaches in LLVM v3.6.0 and compare to a state-of-the-art baseline to show performance improvement up to 87.5\% (65.5\% avg).},
booktitle = {Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {46--61},
numpages = {16},
keywords = {persistency models, Persistent memories, synchronization-free regions, failure-atomicity, language memory models},
location = {Philadelphia, PA, USA},
series = {PLDI 2018}
}

@inproceedings{hydra-sosp19,
author = {Kim, Seulbae and Xu, Meng and Kashyap, Sanidhya and Yoon, Jungyeon and Xu, Wen and Kim, Taesoo},
title = {Finding Semantic Bugs in File Systems with an Extensible Fuzzing Framework},
year = {2019},
isbn = {9781450368735},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3341301.3359662},
doi = {10.1145/3341301.3359662},
abstract = {File systems are too large to be bug free. Although handwritten test suites have been
widely used to stress file systems, they can hardly keep up with the rapid increase
in file system size and complexity, leading to new bugs being introduced and reported
regularly. These bugs come in various flavors: simple buffer overflows to sophisticated
semantic bugs. Although bug-specific checkers exist, they generally lack a way to
explore file system states thoroughly. More importantly, no turnkey solution exists
that unifies the checking effort of various aspects of a file system under one umbrella.In
this paper, we highlight the potential of applying fuzzing to find not just memory
errors but, in theory, any type of file system bugs with an extensible fuzzing framework:
Hydra. Hydra provides building blocks for file system fuzzing, including input mutators,
feedback engines, a libOS-based executor, and a bug reproducer with test case minimization.
As a result, developers only need to focus on building the core logic for finding
bugs of their own interests. We showcase the effectiveness of Hydra with four checkers
that hunt crash inconsistency, POSIX violations, logic assertion failures, and memory
errors. So far, Hydra has discovered 91 new bugs in Linux file systems, including
one in a verified file system (FSCQ), as well as four POSIX violations.},
booktitle = {Proceedings of the 27th ACM Symposium on Operating Systems Principles},
pages = {147--161},
numpages = {15},
keywords = {semantic bugs, fuzzing, file systems},
location = {Huntsville, Ontario, Canada},
series = {SOSP '19}
}

@inproceedings{b3-osdi18,
author = {Mohan, Jayashree and Martinez, Ashlie and Ponnapalli, Soujanya and Raju, Pandian and Chidambaram, Vijay},
title = {Finding Crash-Consistency Bugs with Bounded Black-Box Crash Testing},
year = {2018},
isbn = {9781931971478},
publisher = {USENIX Association},
address = {USA},
abstract = {We present a new approach to testing file-system crash consistency: bounded black-box
crash testing (B3). B3 tests the file system in a black-box manner using workloads
of file-system operations. Since the space of possible workloads is infinite, B3 bounds
this space based on parameters such as the number of file-system operations or which
operations to include, and exhaustively generates workloads within this bounded space.
Each workload is tested on the target file system by simulating power-loss crashes
while the workload is being executed, and checking if the file system recovers to
a correct state after each crash. B3 builds upon insights derived from our study of
crash-consistency bugs reported in Linux file systems in the last five years. We observed
that most reported bugs can be reproduced using small workloads of three or fewer
file-system operations on a newly-created file system, and that all reported bugs
result from crashes after fsync() related system calls. We build two tools, CRASHMONKEY
and ACE, to demonstrate the effectiveness of this approach. Our tools are able to
find 24 out of the 26 crash-consistency bugs reported in the last five years. Our
tools also revealed 10 new crash-consistency bugs in widely-used, mature Linux file
systems, seven of which existed in the kernel since 2014. The new bugs result in severe
consequences like broken rename atomicity and loss of persisted files.},
booktitle = {Proceedings of the 13th USENIX Conference on Operating Systems Design and Implementation},
pages = {33--50},
numpages = {18},
location = {Carlsbad, CA, USA},
series = {OSDI'18}
}

@INPROCEEDINGS{janus-sp17,
  author={W. {Xu} and H. {Moon} and S. {Kashyap} and P. {Tseng} and T. {Kim}},
  booktitle={2019 IEEE Symposium on Security and Privacy (S\&P)}, 
  title={Fuzzing File Systems via Two-Dimensional Input Space Exploration},
  year={2019},
  publisher = {Institute of Electrical and Electronics Engineers},
  pages={818--834},
  address={San Francisco, CA, USA},
  doi={10.1109/SP.2019.00035}
}

@inbook{min-sosp15,
author = {Min, Changwoo and Kashyap, Sanidhya and Lee, Byoungyoung and Song, Chengyu and Kim, Taesoo},
title = {Cross-Checking Semantic Correctness: The Case of Finding File System Bugs},
year = {2015},
isbn = {9781450338349},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2815400.2815422},
abstract = {Today, systems software is too complex to be bug-free. To find bugs in systems software,
developers often rely on code checkers, like Linux's Sparse. However, the capability
of existing tools used in commodity, large-scale systems is limited to finding only
shallow bugs that tend to be introduced by simple programmer mistakes, and so do not
require a deep understanding of code to find them. Unfortunately, the majority of
bugs as well as those that are difficult to find are semantic ones, which violate
high-level rules or invariants (e.g., missing a permission check). Thus, it is difficult
for code checkers lacking the understanding of a programmer's true intention to reason
about semantic correctness.To solve this problem, we present Juxta, a tool that automatically
infers high-level semantics directly from source code. The key idea in Juxta is to
compare and contrast multiple existing implementations that obey latent yet implicit
high-level semantics. For example, the implementation of open() at the file system
layer expects to handle an out-of-space error from the disk in all file systems. We
applied Juxta to 54 file systems in the stock Linux kernel (680K LoC), found 118 previously
unknown semantic bugs (one bug per 5.8K LoC), and provided corresponding patches to
39 different file systems, including mature, popular ones like ext4, btrfs, XFS, and
NFS. These semantic bugs are not easy to locate, as all the ones found by Juxta have
existed for over 6.2 years on average. Not only do our empirical results look promising,
but the design of Juxta is generic enough to be extended easily beyond file systems
to any software that has multiple implementations, like Web browsers or protocols
at the same layer of a network stack.},
booktitle = {Proceedings of the 25th Symposium on Operating Systems Principles},
pages = {361--377},
numpages = {17}
}

@inproceedings{samc-osdi14,
author = {Leesatapornwongsa, Tanakorn and Hao, Mingzhe and Joshi, Pallavi and Lukman, Jeffrey F. and Gunawi, Haryadi S.},
title = {{SAMC}: Semantic-Aware Model Checking for Fast Discovery of Deep Bugs in Cloud Systems},
year = {2014},
isbn = {9781931971164},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation},
pages = {399--414},
numpages = {16},
location = {Broomfield, CO},
series = {OSDI'14}
}

@inproceedings{rubio-gonzalez-pldi09,
author = {Rubio-Gonz\'{a}lez, Cindy and Gunawi, Haryadi S. and Liblit, Ben and Arpaci-Dusseau, Remzi H. and Arpaci-Dusseau, Andrea C.},
title = {Error Propagation Analysis for File Systems},
year = {2009},
isbn = {9781605583921},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1542476.1542506},
doi = {10.1145/1542476.1542506},
abstract = {Unchecked errors are especially pernicious in operating system file management code.
Transient or permanent hardware failures are inevitable, and error-management bugs
at the file system layer can cause silent, unrecoverable data corruption. We propose
an interprocedural static analysis that tracks errors as they propagate through file
system code. Our implementation detects overwritten, out-of-scope, and unsaved unchecked
errors. Analysis of four widely-used Linux file system implementations (CIFS, ext3,
IBM JFS and ReiserFS), a relatively new file system implementation (ext4), and shared
virtual file system (VFS) code uncovers 312 error propagation bugs. Our flow- and
context-sensitive approach produces more precise results than related techniques while
providing better diagnostic information, including possible execution paths that demonstrate
each bug found.},
booktitle = {Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {270--280},
numpages = {11},
keywords = {copy constant propagation, weighted pushdown systems, static program analysis, binary decision diagrams, interprocedural dataflow analysis},
location = {Dublin, Ireland},
series = {PLDI '09}
}

@inproceedings{explode-osdi06,
author = {Yang, Junfeng and Sar, Can and Engler, Dawson},
title = {EXPLODE: A Lightweight, General System for Finding Serious Storage System Errors},
year = {2006},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the 7th USENIX Symposium on Operating Systems Design and Implementation - Volume 7},
pages = {10},
numpages = {1},
series = {OSDI '06}
}

@article{yang-tocs06,
author = {Yang, Junfeng and Twohey, Paul and Engler, Dawson and Musuvathi, Madanlal},
title = {Using Model Checking to Find Serious File System Errors},
year = {2006},
volume = {24},
number = {4},
issn = {0734-2071},
url = {https://doi.org/10.1145/1189256.1189259},
doi = {10.1145/1189256.1189259},
journal = {ACM Transactions on Computing Systems},
month = nov,
pages = {393--423},
}

@inproceedings{fang2003automatic,
  title={Automatic fence insertion for shared memory multiprocessing},
  author={Fang, Xing and Lee, Jaejin and Midkiff, Samuel P},
  booktitle={Proceedings of the 17th annual international conference on Supercomputing},
  pages={285--294},
  year={2003}
}

@article{musketeer2017,
author = {Alglave, Jade and Kroening, Daniel and Nimal, Vincent and Poetzl, Daniel},
title = {Don’t Sit on the Fence: A Static Analysis Approach to Automatic Fence Insertion},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {2},
issn = {0164-0925},
url = {https://doi.org/10.1145/2994593},
doi = {10.1145/2994593},
abstract = {Modern architectures rely on memory fences to prevent undesired weakenings of memory consistency. As the fences’ semantics may be subtle, the automation of their placement is highly desirable. But precise methods for restoring consistency do not scale to deployed systems’ code. We choose to trade some precision for genuine scalability: our technique is suitable for large code bases. We implement it in our new musketeer tool and report experiments on more than 700 executables from packages found in Debian GNU/Linux 7.1, including memcached with about 10,000 LoC.},
journal = {ACM Trans. Program. Lang. Syst.},
month = may,
articleno = {6},
numpages = {38},
keywords = {Static analysis, concurrency, program synthesis, weak memory}
}

@INPROCEEDINGS{lee2000relaxed,
author={Jaejin Lee and Padua, D.A.},
booktitle={Proceedings 2000 International Conference on Parallel Architectures and Compilation Techniques (Cat. No.PR00622)}, 
title={Hiding relaxed memory consistency with compilers}, 
year={2000},
volume={},
number={},
pages={111-122},
keywords={Programming profession;Program processors;Hardware;Computer science;Yarn;Sun;Delay;Flow graphs;Memory architecture;Prefetching},
doi={10.1109/PACT.2000.888336}}
}

@inproceedings{chen-sosp17,
author = {Chen, Haogang and Chajed, Tej and Konradi, Alex and Wang, Stephanie and undefinedleri, Atalay and Chlipala, Adam and Kaashoek, M. Frans and Zeldovich, Nickolai},
title = {Verifying a High-Performance Crash-Safe File System Using a Tree Specification},
year = {2017},
isbn = {9781450350853},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3132747.3132776},
doi = {10.1145/3132747.3132776},
abstract = {DFSCQ is the first file system that (1) provides a precise specification for fsync
and fdatasync, which allow applications to achieve high performance and crash safety,
and (2) provides a machine-checked proof that its implementation meets this specification.
DFSCQ's specification captures the behavior of sophisticated optimizations, including
log-bypass writes, and DFSCQ's proof rules out some of the common bugs in file-system
implementations despite the complex optimizations.The key challenge in building DFSCQ
is to write a specification for the file system and its internal implementation without
exposing internal file-system details. DFSCQ introduces a metadata-prefix specification
that captures the properties of fsync and fdatasync, which roughly follows the behavior
of Linux ext4. This specification uses a notion of tree sequences---logical sequences
of file-system tree states---for succinct description of the possible states after
a crash and to describe how data writes can be reordered with respect to metadata
updates. This helps application developers prove the crash safety of their own applications,
avoiding application-level bugs such as forgetting to invoke fsync on both the file
and the containing directory.An evaluation shows that DFSCQ achieves 103 MB/s on large
file writes to an SSD and durably creates small files at a rate of 1,618 files per
second. This is slower than Linux ext4 (which achieves 295 MB/s for large file writes
and 4,977 files/s for small file creation) but much faster than two recent verified
file systems, Yggdrasil and FSCQ. Evaluation results from application-level benchmarks,
including TPC-C on SQLite, mirror these microbenchmarks.},
booktitle = {Proceedings of the 26th Symposium on Operating Systems Principles},
pages = {270--286},
numpages = {17},
location = {Shanghai, China},
series = {SOSP '17}
}

@inproceedings{persistence2016boehm,
author = {Boehm, Hans-J. and Chakrabarti, Dhruva R.},
title = {Persistence Programming Models for Non-Volatile Memory},
year = {2016},
isbn = {9781450343176},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2926697.2926704},
doi = {10.1145/2926697.2926704},
abstract = { It is expected that DRAM memory will be augmented, and perhaps eventually replaced, by one of several up-and-coming memory technologies. These are all non-volatile, in that they retain their contents without power. This allows primary memory to be used as a fast disk replacement. It also enables more aggressive programming models that directly leverage persistence of primary memory. However, it is challenging to maintain consistency of memory in such an environment. There is no consensus on the right programming model for doing so, and subtle differences can have large, and sometimes surprising, effects on the implementation and its performance. The existing literature describes multiple programming systems that provide point solutions to the selective persistence for user data structures. Real progress in this area requires a choice of programming model, which we cannot reasonably make without a real understanding of the design space. Point solutions are insufficient. We systematically explore what we consider to be the most promising part of the space, precisely defining semantics and identifying implementation costs. This allows us to be much more explicit and precise about semantic and implementation trade-offs that were usually glossed over in prior work. It also exposes some promising new design alternatives. },
booktitle = {Proceedings of the 2016 ACM SIGPLAN International Symposium on Memory Management},
pages = {55--67},
numpages = {13},
keywords = {transactions, locks, consistency, non-volatile memory},
location = {Santa Barbara, CA, USA},
series = {ISMM 2016}
}

@inbook{fscq-sosp15,
author = {Chen, Haogang and Ziegler, Daniel and Chajed, Tej and Chlipala, Adam and Kaashoek, M. Frans and Zeldovich, Nickolai},
title = {Using Crash Hoare Logic for Certifying the FSCQ File System},
year = {2015},
isbn = {9781450338349},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2815400.2815402},
abstract = {FSCQ is the first file system with a machine-checkable proof (using the Coq proof
assistant) that its implementation meets its specification and whose specification
includes crashes. FSCQ provably avoids bugs that have plagued previous file systems,
such as performing disk writes without sufficient barriers or forgetting to zero out
directory blocks. If a crash happens at an inopportune time, these bugs can lead to
data loss. FSCQ's theorems prove that, under any sequence of crashes followed by reboots,
FSCQ will recover the file system correctly without losing data.To state FSCQ's theorems,
this paper introduces the Crash Hoare logic (CHL), which extends traditional Hoare
logic with a crash condition, a recovery procedure, and logical address spaces for
specifying disk states at different abstraction levels. CHL also reduces the proof
effort for developers through proof automation. Using CHL, we developed, specified,
and proved the correctness of the FSCQ file system. Although FSCQ's design is relatively
simple, experiments with FSCQ running as a user-level file system show that it is
sufficient to run Unix applications with usable performance. FSCQ's specifications
and proofs required significantly more work than the implementation, but the work
was manageable even for a small team of a few researchers.},
booktitle = {Proceedings of the 25th Symposium on Operating Systems Principles},
pages = {18--37},
numpages = {20}
}

@inproceedings{sigurbjarnarson-osdi16,
author = {Sigurbjarnarson, Helgi and Bornholt, James and Torlak, Emina and Wang, Xi},
title = {Push-Button Verification of File Systems via Crash Refinement},
year = {2016},
isbn = {9781931971331},
publisher = {USENIX Association},
address = {USA},
abstract = {The file system is an essential operating system component for persisting data on
storage devices. Writing bug-free file systems is non-trivial, as they must correctly
implement and maintain complex on-disk data structures even in the presence of system
crashes and reorderings of disk operations.This paper presents Yggdrasil, a toolkit
for writing file systems with push-button verification: Yggdrasil requires no manual
annotations or proofs about the implementation code, and it produces a counterexample
if there is a bug. Yggdrasil achieves this automation through a novel definition of
file system correctness called crash refinement, which requires the set of possible
disk states produced by an implementation (including states produced by crashes) to
be a subset of those allowed by the specification. Crash refinement is amenable to
fully automated satisfiability modulo theories (SMT) reasoning, and enables developers
to implement file systems in a modular way for verification.With Yggdrasil, we have
implemented and verified the Yxv6 journaling file system, the Ycp file copy utility,
and the Ylog persistent log. Our experience shows that the ease of proof and counterexample-based
debugging support make Yggdrasil practical for building reliable storage applications.},
booktitle = {Proceedings of the 12th USENIX Conference on Operating Systems Design and Implementation},
pages = {1--16},
numpages = {16},
location = {Savannah, GA, USA},
series = {OSDI'16}
}

@article{cflalias,
author = {Zheng, Xin and Rugina, Radu}, 
title = {Demand-driven alias analysis for {C}}, 
year = {2008}, 
isbn = {9781595936899}, 
publisher = {Association for Computing Machinery}, 
address = {New York, NY, USA}, 
url = {https://doi.org/10.1145/1328438.1328464}, 
doi = {10.1145/1328438.1328464}, 
abstract = {This paper presents a demand-driven, flow-insensitive analysisalgorithm for answering may-alias queries. We formulate thecomputation of alias queries as a CFL-reachability problem, and use this formulation to derive a demand-driven analysis algorithm. The analysis uses a worklist algorithm that gradually explores the program structure and stops as soon as enough evidence is gathered to answer the query. Unlike existing techniques, our approach does not require building or intersecting points-to sets.Experiments show that our technique is effective at answering alias queries accurately and efficiently in a demand-driven fashion. For a set of alias queries from the SPEC2000 benchmarks, an implementation of our analysis is able to accurately answer 96\% of the queries in 0.5 milliseconds per query on average, using only 65 KB of memory. Compared to a demand-driven points-to analysis that constructs and intersects points-to sets on the fly, our alias analysis can achieve better accuracy while running more than 30 times faster. The low run-time cost and low memory demands of the analysis make it a very good candidate not only for compilers, but also for interactive tools, such as program understanding tools or integrated development environments (IDEs).}, 
booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages}, 
pages = {197–208}, 
numpages = {12}, 
keywords = {pointer analysis, memory disambiguation, demand-driven analysis, alias analysis, CFL reachability}, 
location = {San Francisco, California, USA}, 
series = {POPL '08} }

@misc{izraelevitz2019basic,
      title={Basic Performance Measurements of the {Intel} {Optane} {DC} Persistent Memory Module}, 
      author={Joseph Izraelevitz and Jian Yang and Lu Zhang and Juno Kim and Xiao Liu and Amirsaman Memaripour and Yun Joon Soh and Zixuan Wang and Yi Xu and Subramanya R. Dulloor and Jishen Zhao and Steven Swanson},
      year={2019},
      eprint={1903.05714},
      archivePrefix={arXiv},
      primaryClass={cs.DC}
}

@misc{gao2017dtranx,
      title={{DTranx}: A {SEDA}-based Distributed and Transactional Key Value Store with Persistent Memory Log}, 
      author={Ning Gao and Zhang Liu and Dirk Grunwald},
      year={2017},
      eprint={1711.09543},
      archivePrefix={arXiv},
      primaryClass={cs.DB}
}

@misc{libmemcached,
  year = {2011}, 
  howpublished = {https://libmemcached.org/libMemcached.html},
  title = {libMemcached},
  author = {{Brian Aker}},
}

@Misc{pmemcheck,
 author = 	 {Tomasz Kapela},
  title = 	 {An introduction to pmemcheck (part 1) - basics},
  howpublished = {\url{https://pmem.io/2015/07/17/pmemcheck-basic.html}},
  month = 	 {July},
  year = 	 {2015}
}

@misc{pmdk,
  year = {2020}, 
  howpublished = {https://pmem.io/pmdk/},
  title = {Persistent Memory Development Kit},
  author = {{Intel Corporation}},
}

@misc{pmempool,
  year = {2019}, 
  howpublished = {https://software.intel.com/content/www/us/en/develop/videos/debugging-tools-and-techniques.html},
  title = {Debugging Tools \& Techniques for Persistent Memory Programming},
  author = {{Intel Corporation}},
}

@misc{intelinspector,
  year = {2021}, 
  howpublished = {https://software.intel.com/content/www/us/en/develop/tools/oneapi/ components/inspector.html},
  title = {Intel Inspector},
  author = {{Intel Corporation}},
}

@Misc{redis,
  title = 	 {Redis},
  howpublished = {\url{https://github.com/pmem/redis}},
  month = 	 {August},
  year = 	 {2020},
  author = {Redis Labs}
}

@Misc{WLLVM,
  title = 	 {WLLVM},
  howpublished = {\url{https://github.com/travitch/whole-program-llvm}},
  month = 	 {August},
  year = 	 {2024},
}


@Misc{memcached,
  author = 	 {Danga Interactive, Inc.},
  title = 	 {Memcached},
  howpublished = {\url{https://github.com/lenovo/memcached-pmem}},
  month = 	 {November},
  year = 	 {2018}
}

@Misc{llvm-8,
  author = 	 {LLVM Foundation},
  title = 	 {LLVM-8},
  howpublished = {\url{https://github.com/llvm/llvm-project/tree/release/8.x}},
  month = 	 {August},
  year = 	 {2019}
}

@Misc{revolutionizingintel2021,
  author = 	 {Intel},
  title = 	 {Revolutionizing Memory and Storage},
  howpublished = {\url{https://www.intel.com/content/www/us/en/architecture-and-technology/intel-optane-technology.html}},
  year = 	 {2021}
}

@Misc{memoryintel2021,
  author = 	 {Intel},
  title = 	 {Memory Optimized for Data-centeric Workloads},
  howpublished = {\url{https://www.intel.com/content/www/us/en/architecture-and-technology/optane-dc-persistent-memory.html}},
  year = 	 {2021}
}

@Misc{earlysteve2019,
  author = 	 {Steve Swanson},
  title = 	 {Early Measurements of Intel's 3DXPoint Persistent Memory DIMMs},
  howpublished = {\url{https://www.sigarch.org/early-measurements-of-intels-3dxpoint-persistent-memory-dimms/}},
  month = 	 {April},
  year = 	 {2019}
}

@Misc{inteleadr2020,
  author = 	 {Intel},
  title = 	 {Third Generation Intel Xeon Processor Scalable Family Technical Overview},
  howpublished = {\url{https://software.intel.com/content/www/us/en/develop/articles/intel-xeon-processor-scalable-family-overview.html?wapkw=clwb}},
  year = 	 {2020},
  month= {June}
}

@Misc{armmanual2021,
  author = 	 {ARM},
  title = 	 {Arm Architecture Reference Manual Armv8, for A-profile architecture},
  howpublished = {\url{https://developer.arm.com/documentation/ddi0487/latest}},
  year = 	 {2021},
  month= {September}
}

@Misc{nvmdirect,
  author = 	 {Bill Bridge},
  title = 	 {Nvm-direct library},
  howpublished = {\url{https://github.com/oracle/nvm-direct}},
  year = 	 {2021},
  month= {September}
}
